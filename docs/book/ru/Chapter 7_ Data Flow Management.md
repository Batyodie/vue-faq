---
head:
  - - meta
    - name: og:site_name
      content: Vue.js 3 Design Patterns and Best Practices
  - - meta
    - name: og:image
      content: /images/book-face.jpg
  - - meta
    - name: twitter:image
      content: /images/book-face.jpg
---

# Многопоточность с Web Workers

В этой главе мы рассмотрим важные темы, которые позволят значительно
повысить производительность веб-приложений, особенно одностраничных.
Во-первых, мы узнаем, как работают веб-сайты и JavaScript, а также как
использовать **веб-рабочие** для повышения эффективности вычислительной
мощности приложения, доступа к данным и сетевых коммуникаций. Затем мы
представим два новых концептуальных паттерна проектирования и реализуем
их в примере приложения вместе с другими паттернами, с которыми мы уже
познакомились ранее. Кроме того, мы представим две библиотеки, которые
облегчат нам сетевые коммуникации, а также работу с постоянной базой
данных (базами данных) в IndexedDB. Мы также реализуем простой сервер
Node.js для обеспечения обратной связи и тестирования нашей работы в
архитектуре с высокой степенью разобщенности, где наши фронтенд- и
бэкенд-сервисы взаимодействуют с помощью стандартных API по протоколу
HTTP.

В этой главе мы рассмотрим, как можно улучшить качество работы наших
сервисов.

В этой главе мы рассмотрим следующие темы:

-   WebWorkers
-   Паттерны бизнеса и диспетчера
-   Сетевое взаимодействие внутри
    **WebWorker**
-   Постоянная встроенная база данных браузера - IndexedDB
-   Как построить простой Node.js API-сервер для тестирования

Концепции, изложенные в этой главе, можно считать "продвинутыми", но мы
сведем их к понятным фрагментам, которые можно будет сразу же
реализовать. К концу этой главы вы будете иметь твердые знания о том,
как реализовать многопоточность в своих веб-приложениях, а также
эталонный фреймворк для масштабирования и облегчения использования
сложных браузерных API.

## Технические требования

Эта глава не добавляет дополнительных требований к нашему приложению.
Однако мы увидим только соответствующие части кода, поэтому, чтобы
увидеть работу всего приложения, следует обратиться к примерам кода для
[*главы
8*](https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186),
*Multithreading with Web Workers*, в GitHub-репозитории книги <span
class="No-Break">at </span>[<span
class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08</span>](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08)

.

Ознакомьтесь со следующим примером.

Посмотрите следующее видео, чтобы увидеть код в действии:

https://packt.link/D4EHt

.

## Введение в веб-рабочие

JavaScript является однопоточным языком, то есть в нем нет возможности
порождать процессы в отдельных потоках. Это заставляет браузеры
запускать JavaScript на веб-странице в одном потоке с другими
процессами, что напрямую влияет на производительность страницы, в первую
очередь на процесс рендеринга, отвечающий за отображение страницы на
экране. Bowsers прилагает значительные усилия для оптимизации работы
всех этих движущихся частей, чтобы сделать страницу отзывчивой,
производительной, быстрой и эффективной. Однако есть задачи, которые
веб-приложение должно выполнять на JavaScript, которые являются тяжелыми
и потенциально "блокирующими рендеринг". Это означает, что браузеру
придется обратить внимание на результаты работы кода и использовать все
ресурсы для завершения выполняемой функции, прежде чем он сможет
сосредоточиться на рендеринге (представлении страницы на экране). Если
вы обнаружили на веб-странице процесс, из-за которого сайт кажется
"неотзывчивым" или "заикающимся" после начала выполнения какого-либо
действия (в некоторых случаях мышь может даже застыть), это может быть
одной из причин.

Если вы откроете браузер и увидите, что он работает в режиме ожидания.

Если открыть инструменты разработчика в современном браузере, то можно
получить доступ к некоторым инструментам производительности для анализа
поведения веб-страницы и времени, которое занимает каждый шаг процесса.
Например, вот быстрый вид первой загрузки YouTube по общей ссылке в
Firefox для Linux:

<div>

<div>

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.01_B18602.jpg)
width="968" height="314"
alt="Рисунок 8.1 - Производительность первой загрузки YouTube с помощью инструментов разработчика" />.

</div>

</div>

Рисунок 8.1 - Производительность первой загрузки YouTube при
использовании инструментов разработчика

На предыдущем скриншоте мы увеличили масштаб обработки страницы,
показав, что происходит до первого рендеринга, то есть до того, как
пользователь увидит что-то на экране. Это представлено в первой строке
**Скриншоты**, где для данного случая первые видимые элементы появляются
в конце временной шкалы (*\#1*). Вторая строка показывает, чем занят
основной **Parent Process**<span lang="en-US"> </span>, и если вы
обратите внимание, то самая первая секция (*\#2*) посвящена обработке
JavaScript. Процесс **Renderer** , выделенный и отображаемый черной
полосой (#3), не может начаться до тех пор, пока не будет запущен
JavaScript. Когда он запускается, он рисует страницу на экране, и вы
получаете видимое содержимое из *\#1*. Это дает примерное представление
о том, какую работу выполняет браузер в каждом цикле между рисованиями
на экране (так называемыми "кадрами"). Браузер старается делать как
можно больше **кадров в секунду** (**fps**). Чтобы поддерживать 60
кадров в секунду, он должен выполнять всю эту обработку примерно за
16,67 миллисекунды или меньше. В лучшем случае процесс JavaScript должен
быть решен за половину этого времени, чтобы сохранить плавность
восприятия для пользователя. Что же происходит, когда обработка
JavaScript занимает больше времени? Все просто: процесс рендеринга
откладывается, fps падает, пользователь испытывает заикание и может
возникнуть застывший **пользовательский интерфейс** (**UI**). В
зависимости от особенностей вашего веб-приложения это может стать
серьезной проблемой.

Вы можете сказать: "Минуточку, а почему бы нам не сделать тяжелые задачи
асинхронными? Разве это не решит проблему?". Ответ: и может, и нет.
Когда вы объявляете асинхронную функцию, это означает лишь то, что ее
выполнение будет отложено до того момента, когда обработка
последовательного кода будет завершена. Скорее всего, это сдвигает
асинхронный код к концу или после выполнения последовательного кода, но
затем он будет выполняться последовательно, как обычно. Если процесс
рендеринга происходит раньше, то вы можете ощутить прирост
производительности, но если нет, то вы столкнетесь с той же проблемой,
если асинхронная функция будет выполняться дольше (так как это повлияет
на следующий рендеринг).

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.02_B18602.jpg)
width="543" height="155"
alt="Рисунок 8.2 - Представление выполнения асинхронного кода, перемещенного после выполнения последовательного кода (1)" />

</div>

</div>

Рисунок 8.2 - Представление выполнения асинхронного кода, перенесенного
после выполнения последовательного кода (1)

Тогда, если асинхронные операции не решат проблему производительности
полностью, как ее решить? Помимо всех возможных оптимизаций, есть одна
технология, которую также следует рассматривать в начале списка
альтернатив: API web workers.

Веб-рабочие (Web workers API).

Web workers - это JavaScript-скрипты, выполняющиеся в собственном
процессе (или потоке, в зависимости от реализации), что позволяет не
нарушать родительский процесс, в котором происходит рендеринг. API
браузера предоставляет довольно простой, но эффективный способ связи с
родительским процессом и обратно: систему сообщений. Эти сообщения могут
передавать только сериализуемые данные. Родительский процесс и каждый
веб-рабочий работают в своем окружении и в своих границах памяти,
поэтому они не могут совместно использовать ссылки или функции, поэтому
все данные, передаваемые между ними, должны быть сериализуемыми,
поскольку они копируются в каждый процесс. Хотя это может показаться
недостатком, на самом деле при правильном использовании это
преимущество, в чем мы вскоре убедимся. Еще одним недостатком этой
архитектуры является то, что веб-рабочие не имеют доступа к
**документной объектной модели** (**DOM**) или объектам Window и,
соответственно, к любым их сервисам. Однако они имеют доступ к сети и
IndexedDB.

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.03_B18602.jpg)
width="788" height="202"
alt="Рисунок 8.3 - Послойное представление приложения Vue с фоновыми процессами, использующими веб-рабочие" />

</div>

</div>

Рисунок 8.3 - Послойное представление приложения Vue с фоновыми
процессами, использующими веб-рабочие

.

Как видно из предыдущей диаграммы, мы можем инстанцировать несколько
веб-рабочих для представления различных типов слоев в нашем приложении
(**Бизнес**, **Данные**, **Коммуникация** и т.д.). Хотя веб-рабочий
может запускаться и завершаться из родительского процесса по своему
усмотрению, оба эти действия требуют больших вычислительных затрат,
поэтому рекомендуется, чтобы созданные веб-рабочие оставались активными
в течение всего времени работы приложения и обращались к ним по мере
необходимости. Также не рекомендуется злоупотреблять этим ресурсом,
создавая "слишком много" веб-рабочих, поскольку каждый из них является
отдельным процессом со своими собственными ресурсами. Четкого
определения того, что такое "слишком много", не существует, поэтому
рекомендуется проявлять осторожность. По моему опыту, если количество
рабочих станций не превышает однозначных значений, то даже на маломощных
устройствах ваше приложение будет работать с отличной
производительностью. Как и во многих других вещах, хорошего может быть
слишком много, и это относится и к веб-рабочим.

Теперь мы знаем, что такое количество веб-рабочих.

Теперь, когда мы знаем, что такое веб-рабочие и чем они могут быть
полезны, давайте посмотрим, как реализовать их на чистом JavaScript, а
затем как сделать это с помощью Vite.

### Реализация веб-рабочего

Создание веб-рабочего на чистом JavaScript довольно простое и понятное.
Объект **window** предоставляет конструктор, правильно названный
**Worker**, который получает в качестве параметра путь к файлу сценария.
Например, если учесть, что наш веб-рабочий содержится в файле
**my_worker.js**, то создать его можно следующим образом:

``` source-code
if(window.Worker){
    let my_worker=new Worker("my_worker.js")
     ...
}
```

Достаточно просто, если конструктор существует в объекте **окно**, то мы
просто создаем нового рабочего, обращающегося к конструктору напрямую.
Вновь созданный рабочий снова предоставляет простой API:

-   **.postMessage(message)**: Это отправит сообщение на веб-рабочий.
    Это может быть любой тип данных, который может быть сериализован
    (основные типы данных, массивы, объекты и т.д.).
-   **.onm\>.**
-   **.onmessage(callback(event))**: Это событие срабатывает, когда
    рабочий отправляет сообщение родительскому процессу. Полученное
    событие имеет поле **.data**, которое содержит сообщение/данные,
    переданные рабочим.
-   **.onerror(callback(event))**: При возникновении ошибки в рабочем,
    срабатывает это событие, которое будет содержать следующие поля:
    -   **.filename**: Имя файла скрипта, сгенерировавшего <span
        class="No-Break">ошибку.</span>
    -   **.lineno**: Номер строки, на которой произошла <span
        class="No-Break">ошибка.</span>
    -   **.message**: Строка, содержащая описание
        ошибки.

Эта система обмена сообщениями позволяет нам осуществлять то, что в
противном случае могло бы быть очень сложной формой **межпроцессного
взаимодействия** (**IPC**). После ее внедрения наш предыдущий код должен
выглядеть следующим образом:

``` source-code
let my_worker=new Worker("my_worker.js")
my_worker.onmessage=event=>{
     // обрабатываем сообщение здесь
     console.log(event.data)
}
my_worker.onerror=err=>{
     //обработать ошибку здесь
}
my_worker.postMessage("Привет от родительского процесса");
```

Для завершения этой работы нам необходимо реализовать скрипт
**my_worker.js**. Для данного примера он может быть таким простым:

./my_worker.js

``` source-code
self.onmesssage=event=>{
     console.log(event.data)
})
setTimeout(()=>{
     self.postMessage("Привет от рабочего")
},3000)
```

Наш пример рабочего очень прост. Он печатает полученные данные в
консоль, а через 3 секунды после активации отправляет сообщение
родительскому процессу. Обратите внимание, что мы используем
зарезервированное слово **self**. Оно необходимо при обращении к API
изнутри функции, так как ссылается на сам рабочий процесс. Именно
поэтому оно необходимо внутри обратного вызова **setTimeout**. На
корневом уровне он необязателен, поэтому можно написать
**self.onmessage**, как в нашем примере, или непосредственно <span
class="No-Break">**onmessage**</span>

.

.

Веб-рабочие могут инстанцировать других рабочих, а также импортировать
другие скрипты с помощью метода **self.importScript()** или просто
**importScript()**. Этот метод получает в качестве параметра строку с
именем файла скрипта. Это аналогично тому, как мы используем оператор
**import** в наших сервисах и компонентах в основном приложении.

При использовании Vite, как мы это делаем для комплектации нашего
Vue-приложения, у нас есть альтернативный способ импорта и создания
рабочего с помощью суффикса. Например, добавьте следующее в наш скрипт
**main.js**

:

./main.js

``` source-code
import MyWorker from "my_worker.js?worker"
const _myWorker=new MyWorker()
_myWorker.postMessage("Hi there!")
_myWorker.onmessage=(event)=>{...}
```

.

При использовании суффиксальной нотации **worker** Vite оборачивает
реализацию в конструктор, который мы можем использовать для
инстанцирования нашего рабочего. Такой подход делает работу с рабочими
более похожей на работу с любым другим классом в нашем приложении,
поскольку мы можем использовать тот же подход для включения его в наше
приложение, и именно этот синтаксис мы будем использовать в наших
примерах. Кроме того, Vite будет обрабатывать скрипты нашего рабочего,
поэтому мы можем использовать более привычный синтаксис для импорта
ресурсов (**import ... from ...**) вместо родного <span
class="No-Break">**self.importScript()**</span>

.

.

Еще много интересного можно узнать о веб-рабочих. Для наших целей этого
достаточно, и мы будем использовать именно это. Если вы хотите узнать
больше, обратитесь к документации на сайте Mozilla Developer Network
([<span
class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers</span>](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)

).

Получив эти компоненты, мы можем реализовать надежное и удобное
соединение с нашими веб-рабочими, применяя паттерны проектирования.
Перед этим нам необходимо концептуально изучить еще два паттерна:
бизнес-делегат и диспетчер.

## Паттерн бизнес-делегат

Этот паттерн используется для того, чтобы скрыть сложность доступа к
бизнес-сервисам или бизнес-слою от клиента или презентационного слоя,
предоставляя единую точку доступа с хорошо определенным и простым(r)
интерфейсом. Его можно рассматривать как вариант или развитие паттернов
proxies и decorator, рассмотренных в [*главе
2*](https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040)
*"Принципы и паттерны проектирования ПО"*, но в более широком логическом
масштабе между архитектурными слоями. Обычно она включает в себя как
минимум

следующие сущности:

-   Сущность **бизнес-делегат**, которая выступает в качестве единой
    точки входа клиента во все доступные сервисы
-   Сущность **business lookup или router**, функция которой состоит в
    том, чтобы направить выполнение входящего запроса к соответствующему
    сервису
-   Службы **бизнеса**, которые предоставляют общий интерфейс (напрямую
    или через прокси-шаблон) с предоставляемой функцией

Для наших целей этот паттерн можно представить в виде следующей
диаграммы:

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.04_B18602.jpg)
width="605" height="310"
alt="Рисунок 8.4 - Представление паттерна бизнес-делегата" />

</div>

</div>

Рисунок 8.4 - Представление паттерна бизнес-делегата

Этот паттерн может быть применен на нескольких архитектурных уровнях. В
нашем конкретном случае мы хотим применить его к нашему приложению с
веб-рабочими. В качестве презентационного слоя мы будем рассматривать
родительский процесс, а в качестве бизнес-слоя - веб-рабочий. В
родительском (или главном) процессе, как обычно, будет находиться наше
приложение Vue, ориентированное в первую очередь на обеспечение
отличного пользовательского опыта. Рабочий процесс будет отвечать за
предоставление нам доступа к сервисам, либо локальным, как в случае с
IndexedDB, либо удаленным, инкапсулируя связь с нашим сервером и
дополнительными сервисами, а также любые дополнительные
вычислительноемкие функции. Такое разделение задач имеет множество
преимуществ, причем не только с точки зрения производительности, но и с
точки зрения проектирования и реализации приложения в целом.

Перед тем как реализовать приложение, мы должны проанализировать его
работу.

Перед тем как приступить к реализации кода для этой главы, необходимо
рассмотреть еще один паттерн, который мы будем реализовывать, поскольку
мы можем передавать между процессами только сериализуемые данные и не
можем выполнять вызовы функций, как это предлагает обычный паттерн
Business Delegate. Мы расширим идею паттерна команд и будем использовать
так называемый паттерн диспетчера.

Диспетчер

## Шаблон диспетчера

Ранее мы видели, что родительский процесс или рабочий веб-процесс могут
инициировать взаимодействие, отправляя друг другу сообщение. Если
определен соответствующий слушатель (**onmessage**), то любой из них
может получать эти события и реагировать на них. В паттерне Dispatcher
эти сообщения содержат информацию, связанную с событием, например,
данные. Ключевым фактором, разделяющим этот паттерн проектирования,
является то, что *сообщения о событиях должны публиковаться между
потоками и планироваться для выполнения по их приходу*. Разумеется,
такое планирование может включать и "немедленное выполнение" некоторой
задачи или функции.

Реализация этого паттерна довольно тривиальна, и можно считать, что он
сродни паттерну Command, который мы рассматривали в [*главе
2*](https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040),
*Принципы и паттерны проектирования программного обеспечения*, поэтому
больше мы его рассматривать не будем. Вместо этого мы воспользуемся
концепциями взаимодействия между потоками, планирования и событий с
данными, чтобы создать наше решение для работы с

web workers.

Установка потоков.

## Установка конвейера взаимодействия с веб-рабочим

Теперь мы рассмотрели ключевые концепции, которые мы хотим применить в
нашей реализации взаимодействия с веб-рабочими для нашего
Vue-приложения. Эту модель можно использовать многократно от приложения
к приложению и совершенствовать по мере необходимости. В качестве общего
плана действий вот что мы построим, используя рассмотренные ранее
паттерны проектирования:

-   Мы создадим веб-рабочего с единой точкой доступа в нашем приложении
    Vue, следуя паттерну Business Delegate
-   Каждое сообщение будет вызывать событие для любого процесса
    (родитель-работник или работник-родитель) и включать данные о
    команде и полезной нагрузке, а также информацию об отслеживании для
    планирования, как в паттерне Dispatcher

Достаточно простая архитектура, описанная в предыдущих пунктах,
позволяет организовать рабочий процесс, как показано здесь:

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.05_B18602.jpg)
width="700" height="376"
alt="Рисунок 8.5 - Реализация рабочего процесса связи с веб-рабочим" />

</div>

</div>

Рисунок 8.5 - Реализация коммуникационного рабочего процесса с
веб-рабочим

Теперь, когда у нас есть теоретическая база и общее представление о том,
что мы будем создавать, пришло время перейти к коду. Мы остановимся на
наиболее актуальных частях кода, реализующих упомянутую ранее модель.
Чтобы увидеть весь код приложения, пожалуйста, ознакомьтесь с полным
исходным кодом из репозитория GitHub. Начнем с создания сервиса, который
будет нашей точкой входа в клиентское приложение:

./services/WebWorker.js

``` source-code
import WebWorker from "../webworker/index.js?worker"
const _worker = new WebWorker()                                 //1
const service = {
     queue:{},                                               //2
    запрос(command, payload = {}) {                              //3
         return new Promise((resolve, reject) => {            //4
         let message = {
             id: crypto.randomUUID(),
               команда,
                полезная нагрузка
          }
         service.queue[message.id]={resolve, reject}            //5
         _worker.postMessage(message);                      //6
          })
     }
    processMessage(data) {
         let id=data.id
          if(data.success){
             service.queue[id].resolve(data.payload)            //7
         }else{
             service.queue[id].reject(data.payload)
          }
          delete service.queue[id];                            //8
      }
}
_worker.onmessage = (event) => {
     service.processMessage(event.data);                      //9
}
export default service;                                           //10
```

Эта реализация проста, но эффективна. Она хорошо помогает нам понять,
как работают эти паттерны. Начнем с импорта конструктора веб-работника с
использованием специального суффикса Vite **worker** и последующего
создания ссылки на экземпляр в строке *//1*. Как обычно, этот сервис
будет синглтоном, поэтому мы создаем его как объект JavaScript, который
экспортируем позже в строке *//10*. У сервиса всего три члена:

-   **queue**: Он определяется в строке *//2* и представляет собой
    словарь, который мы будем использовать для хранения запланированных
    обращений к веб-рабочему с использованием уникального
    идентификатора. В каждой записи будет храниться ссылка на методы
    разрешения обещания (**resolve** и <span
    class="No-Break">**reject**</span>
    ).
-   Метод **request()**: Определенный здесь в строке //3, он будет
    использоваться другими сервисами и компонентами ("клиентами") для
    запроса задач у веб-работника. Он всегда возвращает обещание (строка
    //4). Сообщение, передаваемое веб-рабочему, инкапсулирует
    **команду** и **платежную нагрузку**, полученные в качестве
    параметров, с уникальным идентификатором. Мы сохраняем ссылки на
    методы **resolve()** и **reject()** в **queue** (строка //5), и,
    наконец, используя собственный метод обмена сообщениями
    веб-работника, публикуем сообщение в строке //6.
-   Метод **processMessage()**: Здесь мы получаем данные, переданные
    веб-рабочим, и на основании идентификации и результата операции,
    переданного в атрибуте **.success** (Boolean), обращаемся к
    **queue** и либо используем функцию **resolve()**, либо
    **reject()**, чтобы разрешить или отклонить обещание (строка //7).
    Наконец, мы удаляем ссылку из **queue** в строке //8.

Последним шагом в этом файле является связывание входящих сообщений,
передающих данные непосредственно из рабочего в
**service.processMessage()** в строке //9. Теперь, наверное, понятно,
что мы приняли некоторые решения относительно структуры сообщения, а
также ответа. Сообщения состоят из трех компонентов: **id**, **команда**
и **платежная нагрузка**. Ответы также состоят из трех элементов:
**id**, **success** и **payload**. На стороне клиента мы решили
оперировать обещаниями, так как они не имеют "тайм-аута"

.

После того как с клиентской частью разобрались, пришло время поработать
над сценарием веб-рабочего. Создайте следующий файл **index.js** в
каталоге **webworker**

:

./webworker/index.js

``` source-code
import testService from "./services/test"
const services=[testService]                                    //1
function sendRequest(id, success=false, payload={}){
    self.postMessage({id, success, payload})              //2
}
self.onmessage=(event)=>{                                      //3
     const data=event.data;
    services.forEach(service=>{                                //4
          if(service[data.command]){                      //5
         сервис[data.command](data.payload)                //6
                  .then(result=>{
                       sendRequest(data.id, true, result)       //7
                  }, err=>{
                       sendRequest(data.id, false, err)
              })
          }
      })
}
```

Веб-рабочий стал еще короче, и мы также приняли некоторые решения
относительно интерфейса, реализуемого каждым базовым сервисом: каждый из
их методов должен возвращать Promise. Давайте посмотрим код и выясним,
почему.

Начнем со строки //1 с импорта **testService** (мы создадим его позже) и
включим его в массив сервисов. Это облегчит добавление новых сервисов
путем их импорта и включения в этот массив (это может стать ступенькой к
архитектуре плагинов, но пока мы останемся простыми). Затем мы
определяем глобальную функцию **sendRequest()**, которая будет
отправлять родительскому процессу закодированное сообщение с тремя
полями: **id**, **success** и **payload**, как и ожидает клиент в
определенном нами . Вот что происходит в строке<span class="No-Break">
</span>

//2.

В строке //3 мы определяем обработчик события **onmessage** для
обработки входящих сообщений. При получении одного из них мы обращаемся
к массиву **сервисов** в поисках подходящей команды (строка //4), а
когда находим (строка //5), то выполняем функцию, передавая в качестве
параметра полезную нагрузку (строка //6) после ее разбора с помощью
утилиты JSON. Затем, разрешив или отклонив обещание, мы передаем клиенту
соответствующий результат в строке *//7*. Этот короткий фрагмент кода
выполняет роль *делегатора и диспетчера*. Наконец, давайте посмотрим на
**testService**, чтобы увидеть, как он работает:

./webworker/services/test.js

``` source-code
const service={
   test(){
      return new Promise((resolve, reject)=>{
           setTimeout(()=>{
              resolve("Рабочий жив и работает!")
           }, 3000)
       })
    }
}
export default service;
```

Как вы можете оценить, этот тестовый сервис не делает ничего особенного,
кроме как возвращает Promise и устанавливает таймер на его разрешение
через 3 секунды. Эта задержка является искусственной, поскольку в
противном случае ответ был бы немедленным. Если запустить пример
приложения, то при нажатии на кнопку **Отправить запрос** можно увидеть,
как через 3 секунды сообщение изменится с **Ожидание...** на **Воркер
жив и работает!**, как и ожидалось:

.

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.06_B18602.jpg)
width="803" height="168"
alt="Рисунок 8.6 - Тестовое приложение отправляет команду рабочему и показывает результат" />.

</div>

</div>

Рисунок 8.6 - Тестовое приложение отправляет команду рабочему и
показывает результат

Для того чтобы это сделать, необходимо выполнить следующие действия.

Для этого в компоненте **App.vue** мы импортируем наш сервис web worker
и отправляем запрос со строкой command в качестве имени функции в
сервисе, которую мы хотим выполнить. Для данного примера добавим
следующий код:

``` source-code
import webWorker from "./services/WebWorker.js"
webWorker.request("test").then(data=>{...}, err=>{...})
```

.

Эти простые строки кода для создания и управления веб-рабочим
обеспечивают приложению значительный прирост вычислительной мощности и
производительности. Теперь, когда все готово, пришло время сделать
что-то более существенное с нашим сервисным работником. Давайте
обеспечим ему доступ к нашей локальной базе данных и к сети.

## Получение доступа к IndexedDB с помощью DexieJS в веб-рабочем

.

IndexedDB - это очень мощная база данных с ключами-значениями, однако ее
собственная реализация предоставляет API, с которым довольно сложно
работать. Фактически рекомендуется не использовать его, а работать с ним
через фреймворк или библиотеку. Движок базы данных быстр и очень
податлив, поэтому на его основе создано множество библиотек,
воссоздающих функции и возможности, отсутствовавшие изначально.
Некоторые библиотеки даже имитируют SQL и базы данных на основе
документов. Среди доступных и свободно используемых библиотек можно
назвать следующие:

-   **DexieJS** (<https://dexie.org/>): Очень быстрая и хорошо
    документированная библиотека, реализующая NoSQL-базу данных на
    основе документов.
-   **PouchDB** (<https://pouchdb.com/>): База данных, имитирующая
    функциональность CouchDB от Apache и обеспечивающая встроенную
    синхронизацию с удаленными серверами.
-   **RxDB** ([]()).
-   **RxDB** (<https://rxdb.info/>): Это база данных, реализующая
    реактивную модель. Она также поддерживает репликацию в CouchDB.
-   **IDB** (<https://www.npmjs.com/package/idb>): Это легкая реализация
    обертки поверх API IndexedDB с некоторыми изменениями для улучшения
    удобства использования.

В зависимости от ваших требований к локальному хранилищу, вам подойдут
эти или другие варианты. В данном примере мы будем использовать DexieJS,
поскольку он хорошо документирован и может похвастаться впечатляющей
скоростью выполнения массовых операций. Мы расширим наш предыдущий
пример и создадим однокомпонентное мини-приложение для хранения,
извлечения, удаления и просмотра заметок. Здесь рассматриваются самые
основные операции **создания, чтения, обновления и удаления**
(**CRUD**). При выполнении кода примера он будет выглядеть примерно так:

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.07_B18602.jpg)
width="526" height="105"
alt="Рисунок 8.7 - Пример однокомпонентного CRUD" />

</div>

</div>

Рисунок 8.7 - Пример однокомпонентного CRUD

.

В данном примере можно создавать новые заметки, просматривать ранее
сохраненные (они будут постоянными в зависимости от домена), выделять их
для просмотра текста, а также удалять. Все операции будут выполняться в
веб-рабочем. Давайте включим Dexie в наше приложение с помощью <span
class="No-Break">**npm**</span>

:

``` console
$ npm install dexie
```

.

Следующим шагом создадим наш пример компонентного приложения:

/src/components/DbNotes.vue

``` source-code
<script setup>
import webWorker from "../services/WebWorker"                 //1
import { ref } from "vue"
const _notes=ref([]),_note=ref({}),_selected=ref({})            //2
loadNotes()
function saveNote(){                                         //3
   if(_note.value.title && _note.value.text){
       webWorker
           .request("addNote", JSON.stringify(_note.value))
          .then(id=>{loadNotes()},err=>{...})
          .finally(()=>{_note.value={}})
    }
}
function deleteNote(id){                                          //4
   WebWorker
       .request("deleteNote", {id})
       .finally(()=>{loadNotes()})
}
function openNote(note){_selected.value=note;}                //5
function loadNotes(){                                          //6
   webWorker
       .request("getNotes",[])
       .then(data=>{_notes.value=data;}
             ()=>{_notes.value=]})
}
</script>
<template>
<div>
   <section>
      <h3>Новая заметка</h3>
      <input type="text"
             v-model="_note.title"
              placeholder="Title">
      <textarea v-model="_note.text"
             placeholder="Текст заметки..."></textarea>
      <кнопка @click="saveNote()">Save</button>
   </section>
   <section>
      <h3>Примечания</h3>
      <div v-for="n in _notes" :key="n.id">
          <a @click="openNote(n)">{{ n.title }}</a>
         <a @click="deleteNote(n.id)">[X]</a>
      </div>
   </section>
   <section>
      <h3>Выбранная заметка</h3>
      <strong>{{ _selected.title }}</strong>
      <p>{{ _selected.text }}</p>
   </section>
</div>
</template>
```

Предшествующий файл очищен от стилей и других элементов оформления,
поэтому мы можем сосредоточиться на активных частях кода, реализующих
изучаемые операции. Мы начинаем с импорта нашего класса сервиса для
работы с веб-работником в строке *//1* и создания нескольких внутренних
реактивных переменных в строке *//2*. Мы будем использовать **\_notes**
для хранения полного списка заметок, извлеченного из базы данных,
**\_note** в качестве заполнителя для создания новых заметок, и
**\_selected** для отображения заметки, на которую был сделан щелчок в
списке. Вы можете найти CRUD-операции в каждой функции (строки с *//3*
по *//6)* и заметите, что они очень похожи, за исключением работы с
реактивными элементами пользовательского интерфейса. Они просто собирают
необходимую информацию для создания запроса к веб-рабочему и затем
применяют результат. Однако обратите внимание, что в функции
**saveNote()**, когда нужно передать объект, описывающий нашу новую
заметку, мы стробируем реактивное значение Vue. Это связано с тем, что
реализация прокси, которую Vue использует для работы с реактивностью, не
является сериализуемой, поэтому, если мы не создадим копию обычного
объекта или не применим другие подобные техники для извлечения значений,
связь с веб-работником будет нарушена и выдаст ошибку. Простой способ
убедиться в том, что объект данных предоставляется в виде клонируемого
объекта, - преобразовать его в строку с помощью
**JSON.stringify(\_note.value)**, как в нашем коде (можно также создать
непосредственно клон, используя
**JSON.parse(JSON.stringify(\_note.value))**. Необходимо помнить о том,
как будет передаваться информация, чтобы она могла быть правильно
обработана на принимающей стороне веб-рабочего. Сейчас это станет
очевидным, когда мы увидим **dbService.js** в рабочем:

./src/webworker/services/dbService.js

``` source-code
import Dexie from "dexie"
const db=new Dexie("Notes")                                    //1
db.version(1).stores({notes: "++id,title"});               //2
const service={
addNote(note={}){                                           //3
  return new Promise(async (resolve, reject)=>{
    try{
      let result_id=await db.notes.add(JSON.parse(note))    //4
      resolve({id:result_id})
    }catch(err){reject({})}
})},
getNotes(){
  return new Promise(async (resolve, reject)=>{
    try{
      let result=await db.notes.toArray();                 //5
      resolve(result)
    }catch{reject([])}
})},
deleteNote({id}){
  return new Promise(async (resolve, reject)=>{
    try{
      await db.notes.delete(id)                            //6
       resolve({})
    }catch{reject({})}
})}}
export default service;
```

Для использования Dexie мы сначала импортируем конструктор, как в строке
*//1*, и создаем новую базу данных с именем **Notes**. Прежде чем
приступить к ее использованию, необходимо определить версию и простую
схему таблиц/коллекций с полями, которые будут индексироваться. Это и
происходит в строке *//2*, где мы определяем коллекцию **notes** с двумя
индексируемыми полями: **id** и **title**. Эти индексированные поля
передаются в виде строки, разделенной запятыми по именам полей. Мы также
включили двойной знак плюс в качестве префикса для поля **id**.
Благодаря этому поле автоматически генерируется базой данных и
автоматически увеличивается с каждой новой записью.

Следующая важная функция - функция индексации.

Следующая важная функция, **addNote()**, добавляет запись в коллекцию
**notes**. Поскольку мы передаем данные, сериализуя объект в виде
строки, в нашем компоненте в строке *//4* необходимо разобрать строку,
чтобы перекомпоновать объект.

В строке **addNote()** мы видим, что объект не является объектом.

В функции **getNotes()** мы просто извлекаем все элементы из коллекции и
используем метод **toArray()**, предоставляемый Dexie, который
преобразует их в массив JavaScript (строка *//5*). Таким образом, мы
сможем вернуть его непосредственно в качестве результата для разрешения
обещания.

Последнее замечание по этому коду касается метода **deleteNote()**: в
строке *//6* мы не перехватываем результат асинхронной операции. Это
связано с тем, что данная операция не возвращает полезного значения. В
данном случае эта операция всегда будет разрешаться, если только ошибка
движка базы данных не прервет ее выполнение.

Важно помнить, что ошибки на веб-рабочем не повлияют на родительский
процесс, и любые операции в нем не будут затронуты.

После того как мы создали службу, пришло время немного изменить
индексный файл веб-работника. Добавьте следующие строки:

./src/webworker/index.js

``` source-code
import dbService from "./services/dbService";
const services=[dbService, testService];
```

Других изменений в этом файле не требуется. Как видим, для реализации
CRUD-операций на веб-рабочем требуется не так уж много. Несмотря на то,
что их можно выполнять в родительском процессе, а также на небольшой
штраф за межпроцессное взаимодействие, выигрыш в производительности
значителен и вполне оправдывает затраченные усилия. Особенно если наше
приложение включает в себя фоновые процессы, такие как синхронизация с
удаленным сервером, то они должны выполняться веб-рабочим. Далее
рассмотрим, как можно получить доступ к сети и использовать
**Representational State Transfer API** (**RESTful API**) также из
рабочего.

Потребление RESTful API с помощью веб-рабочего

Одним из наиболее распространенных применений сетевых API сегодня в
веб-разработке является реализация RESTful API. Это протокол, в котором
каждое сообщение не имеет статистики и представляет собой тип действия,
требуемого в месте назначения. Протокол HTTP, используемый в Интернете,
идеально подходит для такого типа API, поскольку каждый сетевой вызов
раскрывает метод, определяющий тип требуемой операции:

-   Операции **GET** позволяют получать данные и файлы
-   Операции **PUT** обновляют данные
-   Операции **POST** создают новые данные на сервере
-   Операции **DELETE** удаляют данные на сервере

Легко заметить, что эти методы соответствуют операциям CRUD, поэтому,
сделав соответствующий сетевой вызов, сервер знает, как обработать
данные, полученные в соответствующей конечной точке. Существует
множество стандартов, используемых для форматирования данных,
передаваемых между конечными точками. В частности, одним из наиболее
распространенных является формат JSON, который мы так удобно используем
в JavaScript.

Обработка асинхронных данных

Работа с асинхронными вызовами с помощью собственной реализации в
браузере, как минимум, громоздка, но не невозможна. В целях практичности
и безопасности рекомендуется использовать известную библиотеку, например
**Axios**. Для установки библиотеки необходимо выполнить в терминале
следующую команду:

``` console
$ npm install axios
```

.

Через несколько мгновений библиотека будет установлена в наш проект в
качестве зависимости. Библиотека предоставляет очень удобные методы для
запуска сетевых вызовов для каждого метода HTTP. Например, **axios.get**
выполняет запрос **GET**, **axios.post** - запрос **POST** и т.д.

Мы реализовали в нашей библиотеке метод **POST**.

В рамках учебного упражнения мы реализуем простую службу, которая будет
выполнять сетевые вызовы на удаленный сервер из веб-рабочего. Для
простоты мы создадим только два метода:

./webworker/services/network.js

``` source-code
import axios from "axios"
axios.defaults.baseURL="http://localhost:3000"
const service={
   GET(payload={}){
      return new Promise((resolve, reject)=>{
       axios
           .get(payload.url,{params:{data:payload.data}})
          .then(result=>{
              if(result.status>=200 && result.status<300){
                    resolve(result.data)
               }else{reject()}
            }).catch(()=>{reject()})
   })},
  POST(payload={}){
    return new Promise((resolve, reject)=>{
      axios
           .post(payload.url,{data:payload.data})
          .then(result=>{
             if(result.status>=200 && result.status<300){
                  resolve(result.data)
             }else{reject()}})
           .catch(()=>{reject()})
})}}
export default service;
```

Этот сервис достаточно прост. В промышленном приложении он будет
являться промежуточным звеном для обслуживания других сервисов. В данном
примере реализовано всего два метода, соответствующих методам
HTTP-запроса. Обратите внимание, что они очень похожи, меняется только
название метода и сигнатура некоторых параметров. Первым параметром
всегда является конечная точка (URI) для подключения. Второй параметр -
это либо данные, либо объект с опциями. О том, как обрабатывать каждый
конкретный запрос и решать крайние случаи, я отсылаю вас к официальной
документации ([<span
class="No-Break">https://axios-http.com/docs/intro</span>](https://axios-http.com/docs/intro)

)

.

Следует отметить, что в начале файла мы задаем домен по умолчанию для
всех остальных сетевых вызовов. Таким образом, мы избегаем его
повторения в каждом вызове. С помощью этой библиотеки мы можем легко
задавать специфические HTTP-заголовки и опции, например **JSON Web
Tokens** для аутентификации, о чем мы рассказывали в [*главе
5*](https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130),
*Одностраничные приложения*, когда упоминали различные <span
class="No-Break">методы аутентификации</span>.

Чтобы включить этот сервис в наш веб-рабочий, мы импортируем его и
добавим в массив **services**, как мы это делали ранее. Изменим начало
этого файла так, чтобы оно выглядело следующим образом:

./webworker/index.js

``` source-code
import netService from "./services/network"
const services=[dbService, netService, testService]
```

С этим новым включением наш веб-рабочий готов. Теперь мы реализуем один
компонент для тестирования взаимодействия, и он будет выглядеть
следующим образом:

<div>

<div>

<img
src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781803238074/files/image/Figure_8.08_B18602.jpg)
width="601" height="100"
alt="Рисунок 8.8 - Простой тест, в котором сервер зеркально отражает отправленную информацию" />.

</div>

</div>

Рисунок 8.8 - Простой тест, в котором сервер зеркально отражает
отправленную информацию

.

Наш компонент позволяет выбрать метод HTTP-запроса (**GET** или
**POST**) и отправить произвольные данные. Тестовый сервер будет просто
зеркально отражать полученные данные обратно клиенту, где компонент
будет отображать их на экране. Реализация достаточно проста:

./src/components/NetworkCommunication.vue

``` source-code
<script setup>
import webWorker from "../services/WebWorker"
import { ref } from "vue"
const
    _data_to_send = ref(""),
     _data_received = ref(""),
    _method = ref("GET")
function sendData(){
     webWorker
         .request(_method.value,                            //1
              {url:"/api/test", data: _data_to_send.value})
         .then(reply=>{_data_received.value=reply},
        ()=>{_data_received.value="Error"
          })
}
</script>
<template>
    <div>
       <section>
            <h4>Текст для отправки</h4>
           <div>
                <label>
                    <input
                         type="radio"
                           value="GET"
                         name="method"
                        v-model="_method">
                      <span>GET Method</span>
                </label>
                <label>
                    <input
                         type="radio"
                          value="POST"
                         name="method"
                        v-model="_method">
                      <span>POST Method</span>
                </label>
            </div>
                <input type="text" v-model="_data_to_send">
                <button @click="sendData()">Send</button>
       </section>
       <section>
            <h4>Данные получены с сервера</h4>
                 {{ _data_received }}
        </section>
    </div>
</template>
```

В этом компоненте мы импортируем сервис **webWorker** и объявляем три
реактивные переменные для отправки и получения данных и одну для
хранения выбранного метода для выполнения запроса. Наш простой тестовый
сервер будет получать запрос и просто зеркально отражать данные, которые
мы отправляем. Позже мы рассмотрим, как создать этот простой сервер с
помощью Node.js.

В шаблоне мы рассмотрим, как создать простой сервер с помощью Node.js.

В шаблоне пользователь может выбрать тип отправляемого запроса (**GET**
или **POST**), этот выбор мы сохраняем в переменной **\_method**. Это
значение мы используем в качестве команды, передаваемой рабочему в
строке *//1*. В качестве полезной нагрузки мы передаем данные в виде
объекта-члена. Когда обещание разрешается, мы сохраняем значение из
ответа в переменной **\_data_received**. Остальная часть исходного кода
должна быть тривиальна для понимания, так как в ней рассматривается в
основном шаблон и представление информации на экране. Прежде чем
закончить эту главу, давайте посмотрим, как тестовый сервер может быть
реализован с помощью Node.js.

## Простой сервер Node

.

## Простой NodeJS-сервер для тестирования

Для тестирования сетевых взаимодействий нам представляется
целесообразным реализовать небольшой сервер на Node.js для реализации
конечных точек, которые мы тестируем. В отдельной директории от нашего
приложения Vue откроем окно терминала и введем следующую команду:

``` console
$ npm init
```

.

Мастер командной строки задаст несколько вопросов для создания файла
**package.json**, который представляет собой приложение Node.js. После
этого выполните эту команду для установки зависимости **Express.js**,
которая предоставит нам фреймворк для создания веб-сервера:

``` source-code
$ npm install express cors
```

После завершения процесса создайте файл **index.js** со следующим кодом:

./server/index.js

``` source-code
const express = require("express")                        //1
const cors=require("cors")                                  //2
const app=express()                   ;                    //3
const PORT=3000
app.use(cors())                                          //4
app.use(express.json())                                    //5
app.get("/api/test", (req, res)=>{                //6
     const data=req.query                                  //7
     res.jsonp(data)                                       //8
})
app.post("/api/test", (req, res)=>{
     const data=req.body                                  //9
     res.jsonp(data)
})
app.listen(PORT, ()=>{                                     //10
     console.log("Server listening on port " + PORT)
})
```

С помощью этих нескольких строк кода мы можем запустить небольшой
сервер, принимающий и отвечающий на запросы в формате JSON. Мы
импортируем конструктор express (строка *//1*), а также плагин (строка
*//2*). Это важно для того, чтобы мы могли обращаться к этому серверу с
любого домена (origin). **Cross-Origin Request Sharing** (**CORS**)
служит для обхода мер безопасности, применяемых серверами для
предотвращения обслуживания запросов из других источников (origins),
кроме своего собственного. Чтобы разрешить запросы из других источников,
его необходимо включить. После создания серверного приложения (строка
*//3*) мы передаем плагин (строка *//4*). Также мы передаем еще один
плагин (строка *//5*), чтобы сервер идентифицировал и отвечал на сетевые
вызовы с помощью JSON-объектов. Далее мы создаем две конечные точки,
одну для **GET** запросов (строка *//6*) и вторую для **POST** запроса.
Первый параметр - это URL, по которому сервер будет прослушивать
обращения. В данном случае они одинаковы, так как единственным отличием
будет тип метода запроса. Это стандартная практика.

Каждая конечная точка получает в качестве последнего аргумента функцию
обратного вызова, имеющую не менее двух параметров: **req** (запрос) и
**res** (ответ). Эти объекты содержат методы и информацию о полученном
запросе, а также необходимые методы для создания ответа клиенту.

Для конечных точек **req** (запрос) и **res** (ответ).

Для запросов **GET** полученные данные передаются вместе с URL в виде
"строки запроса", поэтому для доступа к ним *Express* красиво
упаковывает их в виде объекта в поле **request.query** (строка *//7*).
Поскольку мы просто отвечаем теми же полученными данными, в строке *//8*
мы используем объект **res**(ponse) для создания дополненного
JSON-ответа с тем же объектом данных. Мы делаем это потому, что считаем,
что можем получать вызовы из любого домена (поскольку включили CORS), и
хотим быть уверены, что ответ будет полностью понятен. **JSON with
Padding** (**JSONP**) - это метод отправки ответа с помощью другого
метода. Нам не нужно беспокоиться об этом, так как оба конца
(отправитель и получатель) обрабатываются сервером Express и клиентом
Axios.

В **Таблице **JSON with Padding** (**JSONP**) мы указываем, что ответ не
будет понят.**

В методе **post** разница заключается в том, что данные содержатся в
теле сообщения (строка *//9*), отсюда и разная обработка. Наконец,
сервер начинает прослушивать указанный порт (строка *//10*). Теперь мы
можем обращаться к серверу по адресу
[http://localhost:3000](http://localhost:3000/), который мы настроили в
нашей сетевой службе как адрес по умолчанию для Axios.

В результате мы получили возможность работать с сервером по адресу
[http://localhost:3000](http://localhost:3000/).

После внедрения этого сервера мы можем провести полное тестирование всех
частей системы.

## Обзор

В этой главе мы рассмотрели несколько очень важных концепций,
позволяющих кардинально улучшить архитектуру и производительность нашего
приложения. Web workers - это удивительная технология, позволяющая
веб-приложениям использовать преимущества современных аппаратных
архитектур и современных операционных систем. С точки зрения
стационарности, многопоточность с использованием web workers не требует
особых дополнительных усилий и сложностей, а выигрыш от ее применения
весьма ощутим. Мы также увидели, как использовать рабочие для доступа к
сетевым сервисам, а также к локальной постоянной базе данных,
предоставляемой браузером (IndexedDB). Мы познакомились еще с двумя
паттернами проектирования для реализации масштабируемой архитектуры
нашего приложения и проверили их концепции и реализацию на примере
простых компонентов и сервисов. Использование веб-рабочих значительно
повышает производительность и качество выполнения хорошо
спроектированного веб-приложения. В следующей главе мы рассмотрим
инструменты и методы автоматического тестирования нашего кода,
обеспечивающие соответствие отдельных его частей своему назначению в
соответствии со спецификациями и требованиями к программному
обеспечению.

Вопросы на рецензию.

## Вопросы к обзору

-   Какие ограничения JavaScript могут повлиять на производительность
    веб-приложения?
-   Что такое веб-рабочие? Каковы их ограничения?
-   Как приложения Vue могут взаимодействовать с веб-рабочими?
-   Какие преимущества дает использование такого паттерна
    проектирования, как бизнес-делегат, для работы с веб-рабочими?
-   Что можно изменить в коде примера, чтобы управлять несколькими
    веб-рабочими, а не одним? В каких случаях, по вашему мнению, это
    целесообразно?

</div>

</div>
