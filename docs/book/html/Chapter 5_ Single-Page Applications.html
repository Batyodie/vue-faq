			<h1>Single-Page Applications</h1>
			<p>In this chapter, we continue to increase our skills in Vue 3 with the introduction of <b>single-page applications</b> (<b>SPAs</b>). We will learn what distinguishes them from regular websites and will dive into their key characteristics. To put this into action, we will build a new version of our To-Do application using the Vue Router and a different pattern of communication than the previous chapters. We will also learn authentication methods with code samples.</p>
			<p>By the end of this chapter, you will know the following:</p>
			<ul>
				<li>How to create SPAs with Vue 3</li>
				<li>How to organize your application to make use of the Vue Router with different routing strategies</li>
				<li>How to reimplement our To-Do application with a practical application of different patterns</li>
				<li>How to implement different patterns of authentication in your SPA</li>
			</ul>
			<p>While the previous chapter was somewhat heavy with foundational knowledge, from now onward, we center more on practical matters. Because of this, you will need access to the example applications to follow through.</p>
			<h2>Technical requirements</h2>
			<p>The code for this chapter can be found on GitHub, at </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05</span></a><span class="No-Break">.</p>
			<p>Check out the following video to see the Code in Action: </span><a href="https://packt.link/RnAyz"><span class="No-Break">https://packt.link/RnAyz</a></p>
			<h2>What is a SPA?</h2>
			<p>To explain what a SPA is, we should first explain how we interact with the <b>World Wide Web</b> (<b>WWW</b> or <b>W3</b>). When we enter an address in a web browser, we receive a web page sent by a web server. In the most basic form, a website is just a collection of pages, mostly what we call “static pages”. Static in this context means that the same files in the server are sent without modification. This makes a website very fast and secure. However, a purely static site does not offer much interactivity with the end user. Sometimes this is referred to as <b>Web 1.0</b>. Server and browser scripting came in to solve this limitation and gave birth to <b>multi-page applications</b> (<b>MPAs</b>). Pages could now be either static or dynamically generated on the server, which in turn could also receive calls for new pages with additional data that processes them and returns a new page in response. These new pages “generated on the fly” are called <b>dynamic</b> and made it possible to have applications. These technologies made it possible for blogs, services, and businesses to proliferate.</p>
			<p>It was with the introduction of key technologies such as asynchronous communications (<b>AJAX</b>), more powerful JavaScript, local storage methodologies, increased network speeds, and computational power that we came to what is known as <b>Web 2.0</b>. It was now possible to load a single file into the browser and use JavaScript to take control of the entire interface and interactivity, producing rich and heavily interactive applications without generating new pages on the server. The SPA only contacts the server to load bits of data, the UI, and so on, as needed. It is now possible to migrate to web technologies what were traditional “desktop-only” applications, such as text editors, spreadsheets, rich email clients, graphic design suites, and so on. <i>Office 365</i>, <i>Google Docs</i>, <i>Photoshop online</i>, <i>Telegram</i>, <i>Discord</i>, <i>Netflix</i>, <i>YouTube</i>, and so on are good examples of SPAs. It is important to acknowledge that the introduction of SPAs does not invalidate the use of MPAs or make them obsolete—each has its utility in certain contexts. Most blogs and news sites today are, in fact, MPAs and still constitute a significant part of the internet. The most complex web applications today include a mixture of MPAs and SPAs, working together. SPAs can even be installed as hybrid applications on desktop and mobile devices. We will see how to implement this in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_06.xhtml#_idTextAnchor148"><i>Chapter 6</i></span></a>, <i>Progressive </i><span class="No-Break"><i>Web Applications</i></span><span class="No-Break">.</p>
			<p>Moving forward, with the explosion of distributed and decentralized computing, and smart blockchains, the technology that makes up SPAs has gained even more relevance. While not fully rooted in general use, this new era in web evolution is called <b>Web 3.0</b>. We will see in this chapter more about this topic, with examples.</p>
			<p>All the applications that we have made this far fall into the SPA category, even if we have not used their full potential yet. Vue 3 is specially designed to create these types of applications, and is one of the most relevant technologies for such an approach, together with <i>React</i>, <i>Angular</i>, <i>Svelte</i>, and others. But not everything is sugar, glitter, and rainbows. As with any technology, there are trade-offs to using SPAs. In the next table, we list some of them:</p>
			<table id="table001-3" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Advantages</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Disadvantages</b></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<ul>
								<li>Faster and smarter loading times</li>
								<li>Local caching for improved performance</li>
								<li>Rich UIs and interactivity</li>
								<li>Easier to develop and test than MPAs</li>
								<li>More efficient use of code and templates, with less network communication (as compared to full-page re/loads)</li>
							</ul>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Difficult for search engines to index or discover</li>
								<li>Increased complexity</li>
								<li>Increased load time and slower time for first interactivity</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Advantages and trade-offs for SPAs</p>
			<p>As you can see, the list of advantages is by far more important than the disadvantages. You should consider using a SPA when the application requires significant user interactivity and real-time feedback. Now that we have a better idea of what a SPA is, let’s see the key concept at the core of their functionality: the application </span><span class="No-Break"><b>router</b></span><span class="No-Break">.</p>
			<h2>The Vue 3 router</h2>
			<p>Vue is a great framework to build SPAs, but without a router, the task would soon become quite complex. The Vue router is an official plugin that takes over the navigation of the application and matches a URL to a component. This gives us the advantages of an MPA. With the router, we can do the following:</p>
			<ul>
				<li>Create and manage dynamic routes to components, matching parameters to props automatically if needed</li>
				<li>Identify routes (addresses and components) by name and trigger navigation by code</li>
				<li>Load components dynamically when needed, thus reducing the bundle size</li>
				<li>Create a natural and logical way to approach website navigation and code splitting</li>
				<li>Control navigation with well-known events, before and after navigation occurred</li>
				<li>Create page transition animations in a way that is not possible with MPAs</li>
			</ul>
			<p>The implementation of the Vue 3 router is simple and follows the same methodology as with other components of the ecosystem. Let’s take our project from <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><i>Chapter 4</i></span></a>, <i>User Interface Composition with Components</i>, and modify it to use the <span class="No-Break">Vue router.</p>
			<h3>Installation</h3>
			<p>When starting a new project, you may have noticed that the installer menu gives you the option to install the Vue router. If you have not selected this option, as we did in our example app, the installation afterward is quite simple. In a terminal, in the project directory, just execute the following command:</p>
			<pre class="console">$ npm install vue-router@4</pre>
			<p>The command will download and install the dependencies, just as with any other package in the <b>node_modules</b> directory. In order to use it in our application, we need to do the following:</p>
			<ol>
				<li>Create our routes.</li>
				<li>Link the routes to our components.</li>
				<li>Include the router in our application.</li>
				<li>Set our templates where the router will display our components.</li>
			</ol>
			<p>As with much of the framework, the router does not specify in which directories or organization your routes should be placed, or your components for that matter. However, there is a convention that we will use that has become the de facto standard in the industry. In the <b>/src</b> folder, create the following directories:</p>
			<ul>
				<li><b>/router</b> (or <b>/routes</b>): Here, we will have our JavaScript files with the routes for our application</li>
				<li><b>/views</b>: This folder will contain the top-level components that match the application navigation (as a best practice)</li>
			</ul>
			<p>With these directories in place, we are ready to start modifying our application to include route navigation. Before that, let’s take a look at what we want to achieve with our router.</p>
			<h3>A new To-Do application</h3>
			<p>Our new application will reuse the components to display our To-Do list, but also will accommodate the creation of multiple lists or projects. We will display a sidebar with all our projects, and when selecting them, the list will be updated11. These projects will also be persisted in the browser, so we can come back to them later by using <b>localStorage</b>. We will then have a very simple navigation, with two top-level pages (components):</p>
			<ul>
				<li>A landing page where we can create new projects</li>
				<li>A project page where we can work with our to-do list</li>
			</ul>
			<p>Following these simple premises, our application once finished will look like this:</p>
			<div>
				<div>
					<img src="images/Figure_5.01_B18602.jpg" alt="Figure 5.1 – Our landing page" width="991" height="390">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Our landing page</p>
			<p>As you can see in <i>Figure 5</i></span><i>.1</i>, the landing page is also the place where we can create new projects. We use modal dialogs to collect user input, just as we did before. On the sidebar, we display a link to the <b>Home</b> page (the landing page) and a list with all the names of the different projects that we have created. When you click on each one, the route in the browser (URL) will update as well as the page, and we will see something <span class="No-Break">like this:</p>
			<div>
				<div>
					<img src="images/Figure_5.02_B18602.jpg" alt="Figure 5.2 – A To-Do project page" width="1015" height="448">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A To-Do project page</p>
			<p>You may recognize this last screenshot, as it is what our <b>ToDoProject.vue</b> component displays. As a matter of fact, it will require very little modification to reach this result. For now, let’s begin with the routes.</p>
			<h3>Routes’ definition and the Router object</h3>
			<p>To create routes for our project, we need to first define them in their own module. In the <b>/router</b> directory, create an <b>index.js</b> file with the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/router/index.js</p>
			<pre class="source-code">import {<b>createRouter</b>,<b>createWebHashHistory</b>} from 'vue-router'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
import Landing from "../views/Landing.vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
const <b>routes </b>= [
&nbsp;&nbsp;&nbsp;&nbsp;{path: "/",name: "landing",component: Landing},
&nbsp;&nbsp;&nbsp;&nbsp;{path: "/project/:id",name: "project",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component: <b>() =&gt;</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import(</b>"../views/ToDoProject.vue"<b>)</b>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props: true
}],
<b>router </b>= createRouter(<b>{</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
&nbsp;&nbsp;&nbsp;&nbsp;history: createWebHashHistory(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
&nbsp;&nbsp;&nbsp;&nbsp;routes,
&nbsp;&nbsp;&nbsp;&nbsp;scrollBehavior(to, from, savedPosition){return{top:0}}
<b>}</b>)
export default router;</pre>
			<p>We start our file by importing two constructors from the <b>vue-router</b> package, in line </span><span class="No-Break"><b>//1</b></span><span class="No-Break">:</p>
			<ul>
				<li><b>createRouter</b>, which will create a router object that we can inject into our application as a plugin</li>
				<li><b>createWebHashHistory</b>, which is a constructor that we will pass to our router object and indicates how it will manage the URL rewriting in the browser</li>
			</ul>
			<p><b>Web hash history</b> will display <b>#</b> (a numeral sign) in the URL and will indicate that all navigation points to a single file. All navigation and URL parameters will follow this sign. It is the easiest method and does not require any special configuration. However, the other available methods are <b>Web history</b> (also known as <i>HTML5 mode</i> or <i>pretty URLs</i>) and <b>Memory</b>. Web history does not use the hash notation, but does require a special server configuration. We will see how to accomplish this with examples in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_10.xhtml#_idTextAnchor224"><i>Chapter 10</i></span></a>, <i>Deploying Your Application</i>. Memory mode does not modify the URL and is mostly used for web views (as in hybrid frameworks such as NW.js, Electron, Tauri, Cordova, Capacitor, and so on) and <b>server-side rendering</b> (<b>SSR</b>). For now, we will stay with the <b>Web hash </b><span class="No-Break"><b>history</b></span><span class="No-Break"> method.</p>
			<p>In line <b>//2</b>, we import a component using the static notation, and we define a <b>routes</b> array with our routes. Each route is represented by an object with at least the following fields:</p>
			<ul>
				<li><b>path</b>: A string that represents the URL associated with the component</li>
				<li><b>name</b>: A string that behaves like a unique ID for the route and that we can call programmatically</li>
				<li><b>component</b>: The component to render</li>
			</ul>
			<p>Notice how in line <b>//2</b> we import a static component, but in line <b>//3</b>, we use the dynamic import notation. This implies that the first route (named <b>"landing"</b>) will be included in the main bundle, but the second route ( in line <b>//3</b>, named <b>"project"</b>) will only be loaded the first time it is needed, from a separate bundle. Using routes, we can create a strategy for improving our application loading and bundle size.</p>
			<p>Finally, in line <b>//4</b>, we create our <b>router</b> object using the constructor and passing an options object. Notice in line <b>//5</b> how we pass the <b>history</b> field a constructor for our chosen <b>history</b> method. We also pass our routes (obviously), and also as an example here, we create one of the possible <i>navigation guards</i>, to make sure that after navigating to each route, the window scrolls all the way to the top. Without this, we may encounter a strange side effect, with the scroll not changing between “<i>pages</i>." Navigation guards are triggered before and after a navigation event. They can be used in a multitude of situations, such as authentication control or data preloading. Please refer to the official documentation for a complete list of guards, with examples (</span><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html"><span class="No-Break">https://router.vuejs.org/guide/advanced/navigation-guards.html</span></a><span class="No-Break">).</p>
			<p>In our second route, we have also included a variant in the notation of the path, with the inclusion of a named parameter prefixed by a semicolon (<b>:id</b>). This route will match anything following <b>/project/</b> and assign it to a reactive variable, which we can access programmatically (we will see how this works later). The route also has an additional field, <b>props: true</b>. This indicates that the parameter named in the path will be automatically passed as a prop to the component if the component has defined a prop with the same name. This will become useful and apparent in the next sections.</p>
			<p>With our routes and router defined, it is time to import them into our <b>main.js</b> file and attach them to our application. The file will look now like this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/main.js</p>
			<pre class="source-code">import { createApp } from 'vue'
import router from “./router”
import App from './App.vue'
import Modals from "./plugins/modals"
import styles from "./assets/styles.css"
createApp(App)<b>.use(router)</b>.use(Modals).mount('#app')</pre>
			<p>Easy enough—it is now time to create components that are currently missing and adapt the ones we have. Before dealing with the code, let’s see which new components the router provides our application with.</p>
			<h3>Router template components</h3>
			<p>When we include the router in the application, it injects into the global scope the following new components:</p>
			<ul>
				<li><b>RouterView</b>: This component provides the placeholder where the route components will be rendered.</li>
				<li><b>RouterLink</b>: Provides an easy way to link to routes; through the use of handy props and styles, we can control the appearance and final render element.</li>
			</ul>
			<p>Together with the router and routes definition, these two components in our template make it possible to offer navigation and better organize our code. Before we dig into their details, let’s see them in action in our application. Let’s start modifying our <b>App.vue</b> component to turn it into a layout container (styles omitted):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">App.vue</p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import Sidebar from './components/Sidebar/Sidebar.vue';
&lt;/script&gt;
&lt;template&gt;
&lt;div class="app"&gt;
&nbsp;&nbsp;&nbsp;&lt;Sidebar&gt;&lt;/Sidebar&gt;
&nbsp;&nbsp;&nbsp;&lt;main&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;router-view&gt;&lt;/router-view&gt;
&nbsp;&nbsp;&nbsp;&lt;/main&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>As you can see, we include a new component, <b>Sidebar</b>, which will contain the main navigation for our application. Then, we just place a single <b>&lt;router-view&gt; </b>component, where our router will render each page. When it comes to the styles, I will refer to the code in GitHub for the details. Now, it is time to create the <b>Sidebar</b> component in the <b>/src/components/Sidebar/Sidebar.vue</b> path and copy the code from the repository. There is a lot to see in this small file. Let’s start looking into the template and how we use the <b>RouterLink</b> instances. The first one is static and points to the landing page. Instead of just using a link or an anchor tag, we define the target of the link as an object where we reference the name of the route directly:</p>
			<pre class="source-code">&lt;RouterLink <b>:to="{name:'landing'}"</b> class="w3-padding" active-class="w3-yellow"&gt;Home&lt;/RouterLink&gt;</pre>
			<p>When this component is rendered, by default, it will become an anchor tag, and the <b>href</b> attribute will be dynamically converted to the appropriate route. If we change our route’s definition and give it another path, it won’t affect this code. It is a good practice to reference routes by their names, instead of by their URL. In the case that we need to pass some query string parameters to the URL, we can easily do it by passing an object with key/value members as a <b>params </b>attribute. Here is an example:</p>
			<pre class="source-code">&lt;RouterLink :to="{name:'search',<b>params:{text:'abc' }</b>}" &gt;Search&lt;/RouterLink&gt;</pre>
			<p>The preceding <b>params</b> attribute will be rendered as a URI with the <b>?text=abc</b> query string. As we mentioned, if the route has the <b>props</b> attribute active and the receiving component has defined a prop of the same name, the value will be automatically assigned. This is a situation that allows us to generate a list of links and pass to our project page the ID of each project, as you can see next in the file:</p>
			<pre class="source-code">&lt;div v-for="p in _projects" :key="p.id"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterLink <b>:to="{name:'project',params:{id:p.id}}"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{p.name}}
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/RouterLink&gt;
&lt;/div&gt;</pre>
			<p>When we create a project on the landing page, we automatically assign a unique ID to each one, which we use in the previous code. Just as with other props, we can watch the changes and react by loading the respective To-Do items for each project. With that in mind, we modified the <b>ToDoProject.vue</b> file to define the prop (no need to define the type):</p>
			<pre class="source-code">$props=defineProps(["id"])</pre>
			<p>And then, we also set a watcher to detect changes with these lines in the <b>script </b></span><span class="No-Break">section:</p>
			<pre class="source-code">import { <b>watch </b>} from "vue"
watch(<b>()=&gt;$props.id</b>, loadProject)</pre>
			<p>This watch receives a function that returns the <b>prop</b> attribute and then runs the <b>loadProject()</b> function. At this point, you may ask why we need to do this since each URL is different. The answer is that Vue and the router only load a component the first time it’s needed. As long as it remains in view, it doesn’t reload it and only updates reactive properties. Since our <b>script setup</b> code only runs during the first load, at the moment of creation, we need a way to detect changes to run non-reactive operations, such as loading the To-Do items for the project from </span><span class="No-Break"><b>localStorage</b></span><span class="No-Break">.</p>
			<p>You can follow the rest of the changes in the repository. There is very little that changes in the components that work with the To-Do list, and that is the point of the encapsulation. Even the modification of <b>ToDoProject.vue</b> is small. However, there is one design decision that we need to point out: the use of the <i>pub/sub model</i> to keep the sidebar menu synchronized.</p>
			<p>We have created a singleton with an event bus (<b>eventBus</b>). When we create a new project or delete it, we trigger an update event with this line:</p>
			<pre class="source-code">eventBus.emit("<b>#UpdateProjects</b>")</pre>
			<p>We register the listening events in those components that need it during the <i>mounting </i>lifecycle event of the component, and we de-register it before is <i>unmounted</i>. In our case, we only need this in the <b>Sidebar</b> component, but we could have it anywhere in our application as needed:</p>
			<pre class="source-code">onMounted(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;eventBus.on("<b>#UpdateProjects"</b>, updateProjects)
})
onBeforeUnmount(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;eventBus.off("<b>#UpdateProjects</b>", updateProjects)
})</pre>
			<p>The name of the event is trivial and does not follow any convention. In this book, we prefix it with a numeral sign, as a personal preference.</p>
			<p>In previous implementations, as well as in the <b>ToDoProject.vue</b> component, we use the parent as the conduit to share information between sibling components, as we discussed previously. Here, we use another model, the <i>pub/sub pattern</i>, to avoid polluting the <b>App.vue</b> component with such a task. In <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>Chapter 7</i></span></a>, <i>Data Flow Management</i>, we will see other approaches for central state management. Let’s now take a closer look into more examples and details of using the router with more <span class="No-Break">advanced scenarios.</p>
			<h3>Nested routes, named views, and programmatic navigation</h3>
			<p>This far, we have created static and dynamic routes, even with some parameters in the address. But the router can do even more than that. By using named routes, we can also create “sub-routes” and named “sub-views” to create deeper navigation trees and complex layouts.</p>
			<p>Let’s start with an example. Suppose we have a data structure on three levels, and we want to reactively present this to the user in such a way that they can choose one level, and then “drill down” to the details. We also want to have this reflected in the URL, in such a way that we can share or reference the full case. The levels, in this case, would be country, state, and city. The UI would then look something like this:</p>
			<div>
				<div>
					<img src="images/Figure_5.03_B18602.jpg" alt="Figure 5.3 – A selection using multiple named views and sub-routes" width="908" height="367">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – A selection using multiple named views and sub-routes</p>
			<p>As you can already guess from the screenshot, when the user selects the country, the state list is populated, and the URL is updated. When selecting a state, the city list is updated... and finally, when selecting the city, the information appears in the last column. You may have seen this method of navigation before. There are multiple ways to implement this, some more efficient than others. Our intent is to implement this as a learning exercise, so let’s start with the routes’ definition. Here is a segment of our routes’ definition array:</p>
			<pre class="source-code">{
path: "/directory", name: "directory",
component: () =&gt; import("../views/Directory.vue"),
children:[
{ path:"<b>:country</b>", name: "states", props: true,
&nbsp;&nbsp;component: ()=&gt;import("../views/State.vue"),
&nbsp;&nbsp;<b>children:[</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ path:"<b>:state</b>", name: "cities", props: true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component: ()=&gt;import("../views/City.vue")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<b>&nbsp;]</b>
} <b>]</b> }</pre>
			<h4>Nested routes’ definition</h4>
			<p>At first sight, you will notice that not much has changed, save for the inclusion of a new attribute on the route: <b>children[]</b>. This attribute receives an array of routes, which in turn can have other children, as we see in the previous code snippet. Children routes will be rendered in the <b>RouteView</b> component of their parents, and their paths will be concatenated with their parents as well, unless they start with the root (with a backslash).</p>
			<p>To navigate to each route, we could use any of the methods recognized by the router. However, it is a good practice to use their names and pass any parameter or query string through an object, and let the router resolve the URL. As an example, see how in the <b>Directory.vue</b> component we use the <b>RouterLink</b></span><span class="No-Break"> element:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/views/Directory.vue component, lines 13-18</p>
			<pre class="source-code">&lt;div v-for="c in countries" :key="c.code"&gt;
&lt;RouterLink
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:to="<b>{name:'states', params:{country:c.code}}</b>"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active-class="selected"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{c.name}}
&lt;/RouterLink&gt;
&lt;/div&gt;</pre>
			<p>We have included our <b>RouterLink</b> component inside of a loop, to create as many links as needed based on our data. The target of the link is set to an object, where we pass the name of the route (<b>states</b>), and pass parameters respecting the route and props definition for the component. Notice that the path of the component has been defined as a parameter (it starts with a colon character—<b>:country</b>) and it also matches the props definition of the object in <b>State.vue</b>. This correlation is what enables the router to automatically pass the data for us.</p>
			<p>As you inspect the code, you will notice that in our smallest child component, the <b>City.vue</b> file, we define in our props both country and state. However, in the route definition, only one parameter appears: the state (<b>:state</b>). Nevertheless, when you run the example, you will notice that the prop is also populated. This happens because children components inherit, together with the URL path, all the parameters defined in the route of the parents. In this case, our component then also receives the <b>:country</b> parameter that was passed to the parent, even if it doesn’t show up in its specific route.</p>
			<p>When you run the application, you will see something similar to this screenshot:</p>
			<div>
				<div>
					<img src="images/Figure_5.04_B18602.jpg" alt="Figure 5.4 – Nested routes example, with selections" width="855" height="486">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Nested routes example, with selections</p>
			<p>Only two countries have been included from static files, for simplicity. In a real-life project, this data would be retrieved from a database.</p>
			<p>We have used until now “default” <b>RouteView</b> components, but the Vue router allows us to include multiple views in one component, by assigning them different names. We will only see the notation here, as the implementation is trivial. Consider a component with the following template:</p>
			<pre class="source-code">&lt;div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterView <b>name="header"</b>&gt;&lt;/RouterView&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterView <b>name="sidebar"</b>&gt;&lt;/RouterView&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterView&gt;&lt;/RouterView&gt;
&lt;/div&gt;</pre>
			<p>In the preceding code, we give our routes an identification with the <b>name</b> attribute. We also have a view without a name, in which case it is considered the “default” view, or with the name <b>default</b> as well. To make use of this new layout, the routes’ definition changes slightly. In each definition now, we do not have a <b>component</b> attribute, but instead, a <b>components</b> (in plural) attribute that expects an object. Each field’s name in the object must match the names given to our <b>RouterView</b> components and be equal to an object. For the previous piece of code, the equivalent route definition would be something like this:</p>
			<pre class="source-code">{ path:"/layout", name: "main",
&nbsp;&nbsp;components:<b>{</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: ()=&gt;import('...'),</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header: ()=&gt;import('...'),</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sidebar: ()=&gt;import('...')</b>
<b>}</b>}</pre>
			<p>Using this type of definition, we can create complex layouts, as we can also define sub-routes to make use of—for example—the header and sidebar from the parent and only render in the default view. We have an impressive number of possibilities for building dynamic UIs.</p>
			<p>One important topic that we must cover before moving to the next section is that of programmatic navigation. We have used thus far the new components provided by the router, but we can also trigger navigation directly from our JavaScript without having to rely on the user triggering an event. For this, the Vue Router provides us with two handy constructors to use in our components’ scripts: <b>useRoute</b> and <b>useRouter</b>. We import these constructors into our components with the following line:</p>
			<pre class="source-code">import {useRoute, useRouter} from "vue-router"
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$route=useRoute(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$router=useRouter()</pre>
			<p>As you can imagine, <b>$route</b> provides us with information about the current route, while <b>$router</b> allows us to modify and trigger navigation events.</p>
			<p>The <b>$router</b> object provides several methods, of which the most often used are summarized in this table:</p>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Method</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Description</b></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>push()</b></p>
						</td>
						<td class="No-Table-Style">
							<p>The most important method. It pushes a new URL into the web history and navigates to the corresponding component. It is the programmatic equivalent of using <b>RouterLink</b>. It accepts either a string with the URL to navigate or an object with optional attributes. Here are some examples for each accepted parameter:</p>
							<pre class="source-code">// Navigate to an URL
$router.push(<b>"/my/route"</b>)
// Navigate to a URL, using an object
$router.push(<b>{path: "/my/route"}</b>)
// Navigate to a route, with parameters
$router.push({
&nbsp;&nbsp;&nbsp;<b>name:"route-name",</b>
<b>&nbsp;&nbsp; params:{key:value}</b>
})
// Navigate to a route, with query strings
$router.push({
&nbsp;&nbsp;&nbsp;<b>name:"route-name",</b>
<b>&nbsp;&nbsp; query:{key:value}</b>
})</pre>
							<p>Of course, you can create complex routes by passing parameters and query strings. What is important to remember is that <b>.push </b>will update the navigation history in the browser.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>replace()</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Replace the current navigation component, without modifying the URL.
It accepts the same parameters as </span><span class="No-Break"><b>.push</b></span><span class="No-Break">.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>go()</b></p>
						</td>
						<td class="No-Table-Style">
							<p>This method receives an integer number as a parameter and triggers navigation using the browser’s history. Positive numbers navigate forward and negative numbers go backward in the navigation history. Its most common use is for implementing a “go back” link in an application. Here are some examples:</p>
							<pre class="source-code">// Go back one entry
$router.go(-1)
// Go forward one entry
$router.go(1)</pre>
						</td>
					</tr>
				</tbody>
			</table>
			<p>As mentioned, these are the most commonly used methods and the ones you should have present. I can say that using these will cover the vast majority of regular necessities. A full list of methods available can be found in the official documentation and allow you to manage also edge cases that may arise. I encourage you to check them out, at least to be aware of them, at <a href="https://router.vuejs.org/api/interfaces/Router.html">https://router.vuejs.org/api/interfaces/Router.html</a>#properties. Some of these edge cases could be: add and remove routes dynamically (<b>.addRoute()</b> and <b>.removeRoute()</b>), retrieve the registered routes (<b>.getRoutes()</b>), check whether a route exists before navigating to it (<b>.hasRoute()</b>), and so on. We will not use them, so it is not relevant to see them in detail here.</p>
			<p>In contrast, the <b>$route</b> object gives us information about the current path (URL) where our component is being rendered. As with the previous example, here is a list of the most commonly used attributes, and their function:</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Attributes</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Description</b></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>name</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the current name of the route.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>params</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an object with the parameters provided with the path (URL). If these have been matched to props, the values may overlap.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>query</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an object with the decoded query string attached to the current path.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>hash</b></p>
						</td>
						<td class="No-Table-Style">
							<p>If any, it returns the path in the URL following and including the hash sign (</span><span class="No-Break"><b>#</b></span><span class="No-Break">).</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>fullPath</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a string with the full path of the route.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>In the examples of this book, we will use <b>.name()</b>, <b>.params()</b>, and <b>.query()</b> on more than one occasion, as they tend to be the most commonly used as well. A full list of methods and properties can be found in the official documentation.</p>
			<h6>Important notation differences</h6>
			<p class="callout">We have been using the <b>useRoute</b> and <b>useRouter</b> constructors in the Composition API with the <b>script setup</b> notation. In the Options API, there is no need to initialize these objects. Both are available automatically through <b>this.$route</b> and <b>this.$router</b>. Also, the <b>$route</b> and <b>$router</b> objects are available automatically in the template, when using the Composition API.</p>
			<p>A full code example can be found in the GitHub repository, under <b>Chapter 5</b></span><b>/Nested Routes</b>, at this <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05</span></a><span class="No-Break">.</p>
			<p>Now that we know how to handle routes, parameters, and query strings, it is time to look into some common patterns for authentication in SPAs, since different paths (URLs) are necessary for many of them.</p>
			<h2>Exploring authentication patterns</h2>
			<p>The power of SPAs becomes apparent when there is also a server behind them providing additional services. One such service is authentication. In most applications, there will be the need to identify users and provide additional services based on their rights, status, privacy, group, or any other category pertaining to the context of the application. A clear example of this is webmail applications, such as <i>Outlook</i> or </span><span class="No-Break"><i>Gmail</i></span><span class="No-Break">.</p>
			<p>Current web standards provide us with several options to perform asynchronous communications with a server. These are often called <b>AJAX</b> (<i>AJAX stands for Asynchronous JavaScript and XML</i>). In the most basic form, we could use the <b>XMLHttpRequest</b> object for these network communications, but the new specifications provide us with a direct function, <b>fetch()</b>, which is more convenient and standard between browsers. While these methods are perfectly valid, for other uses than simple needs, it is better to use a library that provides more functionalities built on top of these technologies—for example, one that provides an <b>API</b> to match <b>HTTP </b>request methods (<b>GET</b>, <b>POST</b>, <b>PUT</b>, <b>OPTIONS</b>, and <b>DELETE</b>) to easily consume <b>RESTful APIs</b> (where <b>REST</b> stands for <b>Representational State Transfer</b>, a type of architecture used in network communications). We will see more about this in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><i>Chapter 8</i></span></a>, <i>Multithreading with Web Workers</i>. For now, just keep in mind that a library to handle network asynchronous communications is a better path. In our case, we will use the excellent <b>Axios</b> library (<a href="https://axios-http.com/">https://axios-http.com/</a>), which you can install in your application with the <span class="No-Break">following command:</p>
			<pre class="source-code">$ npm install axios</pre>
			<p>Then, in your service or component, you can import and use the library with the following code:</p>
			<pre class="source-code">import axios from “axios”</pre>
			<p>The library exposes methods to match each HTTP request (<b>.get()</b>, <b>.post()</b>, <b>.put()</b>, and so on), each one returning a promise that resolves to the result of the request or rejects it in the case of error.</p>
			<p>With this introduction, we are ready to see some common patterns for authenticating users in our applications.</p>
			<h3>Simple username and password authentication</h3>
			<p>This is the simplest approach to authenticating users, where the validation of credentials is made by our implementation on the server. In this case, our server backend provides the API to validate a set of credentials, gathered by our SPA. Traditionally, the credentials are stored in the server, on a database, and the communication will be performed on top of <b>Secure Sockets Layer</b> (<b>SSL</b>) or encrypted communication, which are the same thing. Let’s see the workflow graphically:</p>
			<div>
				<div>
					<img src="images/Figure_5.05_B18602.jpg" alt="Figure 5.5 – Simple username and password authentication" width="566" height="235">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Simple username and password authentication</p>
			<p>In this workflow, the following occurs:</p>
			<ol>
				<li>The SPA collects username and password values and transmits them to a specific endpoint in our server for authentication.</li>
				<li>The server uses information stored in a database to validate the username and password.</li>
				<li>The result of the operation is returned to the client SPA in response to their initial query (</span><span class="No-Break"><i>1</i></span><span class="No-Break">).</li>
			</ol>
			<p>Even though <i>Figure 5</i></span><i>.5</i> shows the number of steps, consider that all this is done in just one network call and its reply. Developing the validation code on the server is beyond the scope of this book, but the code inside our service or Vue 3 component would look something similar <span class="No-Break">to this:</p>
			<pre class="source-code">import axios from "axios"
import {ref} from "vue"
const _username=ref(""), _password=ref("")
function doSignIn(){
axios.post(<b>"https://my_server_API_URL",</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>{username:_username.value,password:_password.value})</b>
&nbsp;&nbsp;.then(response=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(<b>response.status)</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(<b>response.data</b>)
&nbsp;&nbsp;}).catch(err=&gt;{...})
}</pre>
			<p>As you can see, the implementation is quite straightforward and depends on our own logic and server API design. What is important to remember is to check the status of the response (everything between <b>200</b> and <b>299</b> is a success) and the data sent back by the server to act accordingly. Axios handles all the communication and data conversion for us (assuming our API receives and process JSON data).</p>
			<p>In the case of success, we should save the result in our application state and allow access to the user accordingly, mostly by unlocking the navigation to private or restricted routes. We could apply this protection in a fair number of different ways, the most common being the use of navigation guards, the creation of dynamic routes, and so on.</p>
			<p>This method is perfectly valid, and commonly implemented by most applications. However, it has several drawbacks:</p>
			<ul>
				<li>We are responsible for maintaining a database with usernames and passwords (encrypted, please!) and implementing the validation logic</li>
				<li>We are legally responsible for handling the user data according to local legislation</li>
				<li>We are responsible for the entire security of the system, end to end</li>
				<li>The user has to remember or be responsible for their own credentials</li>
				<li>We should provide ways to handle edge cases, as well as user problems and credential retrievals</li>
			</ul>
			<p>These drawbacks are in no way a deterrent, but huge bullet points to keep in mind if we go this way. One way or another, most applications need to have a way to authenticate users, which depends on their own logic and implementation since not all of our users (depending on the context) will be willing to use another form of authentication, as we will see next.</p>
			<h3>OpenID and third-party authentication</h3>
			<p>Beyond security concerns, a major issue when dealing with authentication is how easily these credentials are lost or mishandled by the end user. This happens to us all. The more services we access online, the larger the number of credentials a user needs to “remember." There are many different methods to tackle this issue, to reduce the load on the user in keeping track of all these usernames and passwords. One such standard is the <b>OpenID</b> protocol (</span><a href="https://openid.net/"><span class="No-Break">https://openid.net/</span></a><span class="No-Break">).</p>
			<p>The OpenID protocol authenticates users without the need to share credentials (usernames and passwords) between sites. It is based on the workflow of the <b>OAuth 2.0</b> protocol, which is used to securely shared information and resources without the need to use passwords as well. This is achieved by sharing tokens between the different actors. The standard for these communications is to use <b>JSON Web Tokens</b> (<b>JWTs</b>). There is a lot to unravel in this paragraph, so let’s see each one of these terms in a bit more detail so that we can better understand how this protocol works.</p>
			<p>A JWT is a string that contains three sections, separated by a dot (<b>.</b>), and that have been encoded in Base64. Each section then encodes a JSON object with the following information:</p>
			<ul>
				<li><b>Header</b>: This contains cryptographic information used to encode the token, such as the algorithm, the type of token (usually <b>JWT</b>), and in some cases even the type of data submitted in the payload.</li>
				<li><b>Payload</b>: This object contains the information we want (need) to share, and is mostly “free format”, meaning that it can contain any <b>key:value</b> pair as needed. However, there are a few well-defined fields that can also be used, such as “<b>iat</b>”(<b>Issued At Time</b>), which shares the timestamp for the creation of the token. Most importantly, this object must contain a unique ID for the user (“<b>sub</b>”field, for subject).</li>
				<li><b>Signature</b>: The signature is a string form by concatenating the encrypted string representations of the header and payload, expressed in Base64. For the encryption, a secret key (a password) is used, only known to both the authenticating server and the website server.</li>
			</ul>
			<p>When a website in the workflow receives a token, it decodes and validates it using the secret key, using the same method as the issuer. If the signatures don’t match, then it is assumed that the token is corrupted or compromised, and it is rejected. A JWT can be intercepted and decoded by a third party, so this method acts as a failsafe against tampering. Let’s see an example of the creation of a token:</p>
			<ul>
				<li><b>Header</b>: <b>{"alg": "HS256", "typ": "JWT"}</b>. Here, we use the <b>HS256 </b>algorithm and declare the type used as </span><span class="No-Break"><b>JWT</b></span><span class="No-Break">.</li>
				<li><b>Payload</b>: <b>{"sub":"1234567890","name":"Pablo </b><b>D. Garaguso","iat":</b><strong class="source-inline">
</strong><b>1516239022}</b></span><span class="No-Break">.</li>
				<li><b>Secret encryption key</b>: <b>secret key</b></span><span class="No-Break">.</li>
			</ul>
			<p>With the preceding information, a signature field is created with this formula (assuming we have a function that encrypts text using the HS256 algorithm):</p>
			<p><b>HMACSHA256(base64UrlEncode(header) + "." + </b><b>base64UrlEncode</b><strong class="source-inline">
(</strong><b>payload),"secret key")</b></p>
			<p>Finally, the resulting strings in Base64 encoding are concatenated again to give us a perfectly functional token. Also, notice how each section (header, payload, and signature) appears separated by a period (</span><span class="No-Break"><b>.</b></span><span class="No-Break">):</p>
			<p><b>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi bmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551</b><strong class="source-inline">
</strong><b>xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo</b></p>
			<p>To test this token, you can use a service such as <a href="https://jwt-decoder.com/">https://jwt-decoder.com/</a>. To validate it, however, you will need to use the secret key. You can test this at <a href="https://jwt.io/">https://jwt.io</a>, where you can also find more information about this standard.</p>
			<p>In the OpenID protocol, JWTs are used to transmit and validate information between parties, hence why is so important to understand this concept well. There are several workflows recognized by the protocol. Let’s see here a simplified representation of the <b>authorization code flow</b> (<a href="https://openid.net/specs/openid-connect-core-1_0.html">https://openid.net/specs/openid-connect-core-1_0.html</a>) of the protocol with all the actors, and then see the parts we need to implement this in our Vue 3 SPAs:</p>
			<div>
				<div>
					<img src="images/Figure_5.06_B18602.jpg" alt="Figure 5.6 – The OpenID authorization code flow in all its beauty" width="602" height="280">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The OpenID authorization code flow in all its beauty</p>
			<p>As you can see, for this workflow to happen, we need three actors: 1) our SPA, handling multiple routes, 2) the authentication <b>service provider</b> (<b>SP</b>) server, and 3) our own backend server. It is possible to do the authentication and validation of our backend in the browser, then only needing two actors, but this is not recommended as it exposes the secret key in our JavaScript. The option is there, however, for embedded applications such as mobile apps where the user has no easy access to the page code (in hybrid applications).</p>
			<p>In order to implement the workflow, the client (our application) must register with the authentication service. The process depends on each entity, but as a result, we will have registered the following:</p>
			<ul>
				<li>A <b>client_id</b> identification string, unique to our application.</li>
				<li>A <b>secret_key</b> value, which will be known only to the authentication server and our backend application. This will be used to encode and sign our tokens.</li>
				<li>A series of <i>endpoints</i> in the authentication server, and in our application where the user will be redirected in each step. Appropriate exchange of tokens will be done in these redirects as part of the query string in the URL.</li>
			</ul>
			<p>So, let’s see these steps in detail, and how to implement them in our Vue 3 application:</p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Step</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Description</b></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p>The user needs to be authenticated, so we redirect them to the endpoint given to us by the authentication server. The query string needs to be included with the following (mandatory) fields:</p>
							<ul>
								<li><b>scope</b></span><span class="No-Break">: </span><span class="No-Break"><b>openid</b></li>
								<li><b>response_type</b></span><span class="No-Break">: </span><span class="No-Break"><b>code</b></li>
								<li><b>client_id</b>: The client identification given by the authentication server</li>
								<li><b>redirect_uri</b>: The same address that we registered with the server where the user will be redirected upon successful authentication</li>
								<li><b>state</b>: Any data or application state that we want to receive in return after the authentication</li>
							</ul>
							<p>To prepare the redirection URL, we first create an object with the preceding fields and values, and use the <b>URLSearchParams</b> creator to create a query string (see </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams</span></a><span class="No-Break">):</p>
							<p><b>const </b><b>query_data={scope:"openid", ...},</b></p>
							<p><b>query_string=new URLSearchParams(query_data).toString()</b></p>
							<p>Next, we can use the location object to execute the redirection:</p>
							<p><b>location.assign("https://auth_endpoint" + "?" + </b><b>query_string)</b></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p>On successful authentication, the authentication server will redirect the user to the endpoint that we registered as the receiver. The query parameters sent will depend on the result of the operation:</p>
							<ul>
								<li>Successful sign-in:</span><ul><li><b>code</b>: The <b>code_token</b> that needs to be exchanged later for <span class="No-Break">an </span><span class="No-Break"><b>identity_token</b></span><span class="No-Break">.</span></li><li><b>state</b>: Any data we sent to the server and want back. We can use this to redirect the user inside our application, <span class="No-Break">for example.</li></ul></li>
								<li>Unsuccessful sign-in:</span><ul><li><b>error</b>: An error code as specified by the protocol (<b>interaction_required</b>,<b> invalid_request_uri</b>, and <span class="No-Break">so on).</li></ul></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"></td>
						<td class="No-Table-Style">
							<p>The redirect will trigger our application being loaded, and the router will render our designated component. In our script setup, we need to capture the query string passed to us, to be used later in the next step. One approach to do this without the use of third-party libraries is with the following code:</p>
							<pre class="source-code">import {useRoute} from "vue-router"
const <b>$route=useRoute()</b>
if(<b>$route.query.error</b>){
&nbsp;&nbsp;&nbsp;// The authentication failed, take action
}else{
&nbsp;&nbsp;&nbsp;// Authentication succeeded do something
&nbsp;&nbsp;&nbsp;sendToServer(<b>$route.query.code)</b>
}</pre>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p>In this step, we just send the code received to our backend, which would mean implementing the <b>sendToServer()</b> function mentioned previously. Since now we are dealing with our own implementation, the way to do this is trivial. In this example, we are using Axios:</p>
							<pre class="source-code">import{axios}from "axios"
function sendToServer(<b>code</b>){
axios
&nbsp;&nbsp;.post("our server URL", {<b>code</b>})
&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;// Set the token in our headers
&nbsp;&nbsp;&nbsp;&nbsp;axios.defaults.headers.common={
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>"Authorization":"Bearer " +&nbsp;result.data.identity_token</b>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}).catch(()=&gt;{
&nbsp;&nbsp;&nbsp;// Handle the error
})}</pre>
							<p>In the previous example, we have sent to our server the <b>code_token</b> string and received from our server the <b>identity_token</b> string as response. We then go one step beyond and set the default headers for our application to use the standard <b>Authorization </b>header, with a <b>Bearer</b> token. From then on, our server only needs to check the headers and verify that the operation requested belongs to a valid user.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Implementing the validation of the tokens and <i>steps 4</i> and <i>5</i> go beyond the scope of this book, as we are focusing on Vue 3 applications. As you can see, the part that our SPA needs to handle is quite simple and does not really involve much code (some error checking was omitted for the sake of brevity).</p>
			<p>There is a good number of syndicated authentication services, both free and paid, that we can implement in our application. Most common these days is to see badges redirecting users to use them, such as signing in with <i>Google</i>, <i>Facebook</i>, <i>Twitter</i>,<i> GitHub</i>, <i>Microsoft</i>, and so on. There are also meta-services that provide all the aforementioned providers inside well-packaged libraries, such as <b>Auth0 </b>(<a href="https://auth0.com/">https://auth0.com/</a>, now part of <b>Okta</b>, <a href="https://www.okta.com/">https://www.okta.com/</a>). When it comes to implementing this workflow, we are certainly not short of options.</p>
			<h3>Passwordless or one-time password (OTP) authentication</h3>
			<p>Another solution to remove the use of credentials is to remove them altogether with passwordless access. The basic idea is to rely on the security of another system (email, mobile texts, authenticator apps, and so on) to validate the user. The process generates a time-sensitive “one-time use only” code and sends it to the user through the supporting system via the backend service. The frontend service (the application) awaits the right to be entered by the user in a determined time frame. For example, a common implementation is for the backend to send a text message to the user’s phone containing the code, which has to be entered into the application before the time expires.</p>
			<p>Here is a visual representation of this workflow, considering that the user has been registered with an email or phone number. These are supposed to be <i>well known</i>, meaning that the ownership has been verified:</p>
			<div>
				<div>
					<img src="images/Figure_5.07_B18602.jpg" alt="Figure 5.7 – Passwordless authentication based on email" width="537" height="331">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Passwordless authentication based on email</p>
			<p>In the preceding workflow, notice that the OTP code never reaches the web application until the user inputs it. The validation occurs in the backend, not in the frontend. This makes our application very simple, as it only needs to collect the email first and submit it to the server, and then wait for the specified time for a new input. In a service or component, using Axios, this code would look something like this:</p>
			<pre class="source-code">const _user_email=ref(""),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_wait_seconds=ref(0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_show_input_code=ref(false),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_otp_code=ref("")
function <b>signInUser()</b>{
&nbsp;&nbsp;&nbsp;&nbsp;axios.post("https://requestOTP_url",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>{email:_user_email.value</b>})
&nbsp;&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_wait_seconds.value=result.data.wait_time;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_show_input_code.value=true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startOTPtimer();
&nbsp;&nbsp;&nbsp;&nbsp;}).catch(err=&gt;{...})
}
function <b>startOTPtimer()</b>{
&nbsp;&nbsp;&nbsp;let interval_id=setInterval(()=&gt;{
&nbsp;&nbsp;&nbsp;if(_wait_seconds.value&gt;0){_wait_seconds.value--;}
&nbsp;&nbsp;&nbsp;else{clearInterval(interval_id);}},1000)
}
function <b>checkOTP()</b>{
&nbsp;&nbsp;&nbsp;axios.post("https://validateOTP_URL",<b>{code:_otp_code.value}</b>)
&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(result.status&gt;200 &amp;&amp; result.status&lt;300){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// User validated, proceed to protected route</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Validation failed. Redirect to error route</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 }).catch(err=&gt;{...})
}</pre>
			<p>In the preceding code, we have omitted the imports and the template, as at this point they should be trivial for the reader. Our template should have at least an input to collect the email of the user, and a second input to collect the OTP code, plus two buttons to trigger on click the <b>signInUser()</b> function and the <b>checkOTP()</b> function. The first one will pass the email to the backend, and wait for a reply with at least a time in seconds to wait, which we use to start a timer (it is always good to let the user know how much time they have to enter the code). Nowadays, for emails and text messages, the standard is 60 seconds. When this happens, we also hide the first input and then show the “OTP” input form. When the user enters the code and clicks <b>Submit</b>, the <b>checkOTP()</b> function is activated, and we pass the code again to the server waiting for a reply. On success, we can redirect the user to a protected area according to our application logic. Considering the triviality of the template, it would be a good exercise for the reader to create the component and template by themself. Then, a possible solution can be found in the code examples, in the <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>Chapter </i></span><span class="No-Break"><i>5</i></span></a><span class="No-Break"> folder.</p>
			<p>Following a progressive approach to security, the next step is to join the previous approaches into a common new process: <b>two-factor authentication</b> (<b>2FA</b>), which we will see now.</p>
			<h3>2FA - Two Factors Authentication</h3>
			<p>In 2FA, our application merges two or more of the previous approaches to validate a user. The key concept behind this method is that even a third party or simple username and password are not enough, and the user needs to have a “secondary factor” to be validated—for example, the use of a registered email, phone number (for SMS submission of codes), authentication apps (example: Google Authenticator), a USB device, a security card (with a chip or band reader), and so on.</p>
			<p>The workflow is simple but does require more from our backend than from our frontend application. Once our SPA authenticates our user using any of the methods listed previously, a second request is triggered on the backend to submit the proper query to the security device. Let’s assume that our user receives an SMS from our server with a code. Our SPA will wait and collect this code during a specific time frame (usually, 60 seconds), and submit it to the backend to a specific endpoint. It is the server that then validates the code. In reality, this is like having two or multiple passwords, whose validation is made in cascade. Any step fails, and the entire operation is discarded.</p>
			<p>Here’s a visualization of the process:</p>
			<div>
				<div>
					<img src="images/Figure_5.08_B18602.jpg" alt="Figure 5.8 – A simplified view of our SPA and server interactions with 2FA" width="656" height="325">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – A simplified view of our SPA and server interactions with 2FA</p>
			<p>As we can see from the simplified workflow, the process of validating a user with 2FA (as with passwordless and OTM methods) does not rely so much on the code or some specific cryptography but on the use of clever communication and data isolation. The data and validation process never leaves our server or could be visible to an end user, even if opening the code of our SPA. In a way, you can think of this workflow as the concatenation of an OpenID or credentials authentication, followed by an OTP implementation.</p>
			<p>Our application’s main responsibility is just to collect the bits of data that make up each step and relay them to the server. In between, we could change the route or update the interface, but this implementation is trivial, so we won’t see specific code here (you can see previously how to programmatically change a route, for example).</p>
			<p>In general, 2FA is considered a “more secure method”, but it is not without its drawbacks, and it may not be the right fit for every application. For example, what happens if you know your username and password, but lose your secondary device (your mobile gets stolen, hacked, and so on)? Organizations that use this method often provide a way to recover your identity, often with expensive implementations (think of a bank and phone service). In the end, this method does apply one more layer of complexity in the authentication of users, and with it, another possible point of failure, ending with very frustrated users if not handled properly.</p>
			<p>Let’s see next another authentication method that is gaining traction as the new kid on the block of authentication patterns: Web3 authentication.</p>
			<h3>Web3 authentication</h3>
			<p>Before we dig into the topic, we need to define what <b>Web3</b> is. There seems to be some confusion as to the extent of the definition, so for our purposes, Web3 is believed to be the next iteration or evolution of the internet, where the processing power is done in decentralized and distributed servers, using blockchain technologies. The most well-known and popular applications of these technologies nowadays are cryptocurrencies, decentralized self-governing organizations, decentralized finances, play-to-earn games, distributed cloud storage, and much more.</p>
			<p>A <b>blockchain</b> is a ledger that is maintained by a network of distributed computers. Anything written to it is immutable, and publicly visible by anyone on the network. Some blockchains are “smart”, meaning that they can contain not only data but also run applications, much like any backend service. The frontend applications that connect to a blockchain are called <b>distributed applications (DApps</b>), which are, for the most part, <i>SPAs</i>. For this task, the Vue 3 framework is very well suited, as we have seen thus far. A DApp must connect with a backend server that is part of the target blockchain network. These types of servers are known as <b>nodes</b>. In some cases, the DApp can interact directly with the blockchain. Most, if not all, blockchains use cryptocurrencies to regulate operations and reward the contributing nodes supporting the network. Cryptocurrencies are logically assigned to a unique blockchain ID called a “wallet”. These wallets implement some very smart cryptographic techniques to validate each other when performing operations, through the use of public and private keys. A user may have many wallets. There are no emails or ways to recover lost keys in a blockchain, and each wallet is unique.</p>
			<p>In order to resolve all this cryptographic signage and validation, and to make it easier for users, there are special plugins for browsers called “digital wallets," as well as mobile application wallets that also implement web browsing. These applications hold the credentials and do the heavy lifting when dealing with the blockchain. There are, of course, numerous libraries to do the same tasks in pure JavaScript, but this goes beyond the scope of this book. What we will see next is how in our SPA, we can leverage the power of these technologies to identify a user, even automatically when visiting our application page.</p>
			<p>We will focus mainly on the biggest smart blockchain, the Ethereum network, as an example. The same workflow with more or fewer steps applies to other networks using different SDKs, so the migration or incorporation of additional blockchains is not too far away from our examples. The basic conceptual workflow is as follows:</p>
			<p>Import a library to connect to the network in our JavaScript, either through a library such as <b>web3js</b> (<a href="https://www.npmjs.com/package/web3">https://www.npmjs.com/package/web3</a>), <b>ethjs</b><b> </b>(<a href="https://www.npmjs.com/package/ethjs">https://www.npmjs.com/package/ethjs</a>), or use the one injected directly by a browser wallet—in our example, <b>MetaMask</b>, in </span><span class="No-Break"><b>window.ethereum</b></p>
			<ul>
				<li>Using the <b>ethereum</b> object, we request the user to connect their wallet to our site and retrieve the selected wallet address</li>
				<li>Our application then can send to our backend the wallet ID (that is public) and use it as the unique ID for the user’s account</li>
			</ul>
			<p>As just mentioned, we will use the object injected by <b>MetaMask</b> (https://metamask.io/) since it is one of the best-known browser wallets. In this case, here is the code that requests the current user’s wallet:</p>
			<pre class="source-code">ethereum
<b>.request({ method: 'eth_requestAccounts' })</b>
.then(
&nbsp;&nbsp;&nbsp;&nbsp;result=&gt;console.log(result[0]),
&nbsp;&nbsp;&nbsp;&nbsp;err=&gt;console.log(err)
)</pre>
			<p>That’s it! The highlighted line prompts <i>MetaMask </i>to open a new window and request the user’s permission to connect their wallet to your web application, and then return a handy promise. If approved, the result will be an array of strings, where the first position is the wallet address for the current network. If rejected, an error will be triggered.</p>
			<h6>Tip</h6>
			<p class="callout">With MetaMask, you can open the <b>Developer Tools</b> in the browser and type in one line the preceding code to test it.</p>
			<p>Using <b>MetaMask</b>, the same code for the <b>Ethereum</b> network also works when connected to the <b>Polygon</b> and <b>Binance Smart Chain</b> networks (three for the price of one!). Other networks and wallets, such as the Phantom wallet, follow the same principle and inject into the <b>windows</b> object a new object called <b>.solana</b>. Check the documentation of your target blockchain to become acquainted with the details of each implementation.</p>
			<p>Interacting with each blockchain and the code thereof is beyond the scope of this book, so we will limit ourselves to identifying the user by their wallet address. Having obtained this identification, it is up to our application logic to store them for future reference, as it acts like the user ID.</p>
			<p>There are also third-party solutions to authenticate and interact with multiple blockchains, and we should consider them before implementing our own solution.</p>
			<h2>Summary</h2>
			<p>In this chapter, we considerably improved our application and created a sound SPA with navigation using the Vue router. This is an important concept to segment our application and organize the work between the members of a development team. Fractioning our application following the navigation path makes development and maintenance easier to approach and better organized. We also learned several authentication standard patterns that we can consider for our applications, covering a good number of scenarios used today in the industry, from the very basic username and password, all the way to the new Web3 DApps. We also took time to understand how standard protocols such as OAuth work, as well as OTPs, and how these can be implemented for an extra layer of security as a second-factor authentication. All these skills are relevant and necessary for today’s web application standards.</p>
			<p>In the next chapter, we continue expanding our technical knowledge with the introduction of <b>progressive web </b><b>applications</b></span><span class="No-Break"> (</span><span class="No-Break"><b>PWAs</b></span><span class="No-Break">).</p>
			<h2>Review questions</h2>
			<p>We have covered multiple different topics and introduced new concepts in this chapter. Use the following questions to solidify what you just learned:</p>
			<ul>
				<li>When is better to use a SPA instead of an MPA and vice versa?</li>
				<li>What are the benefits of using a router in our SPA? Name at least three from your own analysis.</li>
				<li>How can you use views to define the layout of your application?</li>
				<li>How can you access the parameters and query string passed to your route in your JavaScript?</li>
				<li>What are some common standard patterns to authenticate users?</li>
				<li>What are some security considerations when authenticating users in a SPA?</li>
			</ul>
		</div>
	</div></div>