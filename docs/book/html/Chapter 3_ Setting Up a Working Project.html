			<h1>Setting Up a Working Project</h1>
			<p>In the previous chapters, we laid the theoretical foundation for designing a web application in JavaScript using the <i>Vue 3 framework</i>. However, so far, we have not really gotten into a real project. That is what this chapter is about. We will use the new set of tools that comes along with Vue 3 to create a project from scratch and prepare a template that we will use in other projects. As is custom, this initial project for a web application is to build a <i>To-Do list</i> (the equivalent of <i>Hello World</i>). As we progress with the introduction of each new concept, we will over-engineer the application to turn it into something much more useful, or at the very least, more interesting to look upon.</p>
			<p>Some of the practical skills we will learn here are as follows:</p>
			<ul>
				<li>Setting up your working environment and <b>integrated development </b><b>environment</b></span><span class="No-Break"> (</span><span class="No-Break"><b>IDE</b></span><span class="No-Break">)</li>
				<li>Using the new command-line tools and the new <b>Vite</b> bundler to scaffold our application</li>
				<li>Modifying the basic template and folder structure to accommodate <i>best practices</i> and advanced architecture <i>design patterns</i></li>
				<li>Integrating out-of-the-box <b>CSS frameworks</b> into our application</li>
				<li>Configuring the Vite bundler to accommodate our needs</li>
			</ul>
			<p>Unlike in previous chapters, this one will be mostly practical, and there will be references to the official documentation for each element of the ecosystem, as these change from time to time. You don’t need to memorize the steps, as starting up a project from scratch is not so common for large projects and the tools to scaffold them evolve. Let’s start.</p>
			<h2>Technical requirements</h2>
			<p>To follow the practical steps in this chapter, you will need the following:</p>
			<ul>
				<li>A computer running <b>Windows</b>, <b>Linux</b>, or <b>macOS</b> with a 64-bit architecture. I will be using <b>Ubuntu 22.04</b>, but these tools are cross-platform, and the steps translate between OSs (when something is different, I will point it out).</li>
				<li><b>Node.js 16.16.0 LTS</b> with <b>npm</b> (<b>node package manager</b>) installed. You can find the steps to install Node.js in the official documentation, at <a href="https://nodejs.org/">https://nodejs.org/</a>. The building tools work on top of Node.js, so without this, you can’t go very far. Node.js is a JavaScript version adapted to run on servers and in systems “outside” the browser, something that makes it very, very handy and powerful. Most of today’s bundlers for web development use Node.js in one way or another, if not at least for the great convenience it provides.</li>
				<li>A <b>text editor</b> that works with plain text, in UTF-8 format, preferably an IDE. For this tool, there is no shortage of options to choose from. In theory, you can go without an IDE, but I highly recommend that you get one, if not for anything else than the code assistance they provide (also known as <b>IntelliSense</b>, <b>code completion</b>, etc.). Here are some of the most popular options:</span><ul><li><b>Visual Studio Code</b> (free): An excellent and very popular option among developers made by Microsoft, which provides good support to Vue 3 through the <b>Volar</b> plugin. The official site is <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>, and in this book, we will be using this editor as the recommended IDE to work with Vue <span class="No-Break">and Vite.</span></li><li><b>Sublime Text</b> (free trial/paid): This is another popular option, especially among macOS users. The official site <span class="No-Break">is </span><a href="https://www.sublimetext.com/"><span class="No-Break">https://www.sublimetext.com/</span></a><span class="No-Break">.</span></li><li><b>Jetbrains WebStorm</b> (free trial, paid): The official site <span class="No-Break">is </span><a href="https://www.jetbrains.com/webstorm/"><span class="No-Break">https://www.jetbrains.com/webstorm/</span></a><span class="No-Break">.</span></li><li><b>Komodo IDE</b> (free): The official site <span class="No-Break">is </span><a href="https://www.activestate.com/products/komodo-ide/"><span class="No-Break">https://www.activestate.com/products/komodo-ide/</span></a><span class="No-Break">.</span></li><li><b>NetBeans IDE</b> (free): The official site <span class="No-Break">is </span><a href="https://netbeans.apache.org/"><span class="No-Break">https://netbeans.apache.org/</span></a><span class="No-Break">.</li></ul></li>
				<li>A <b>console</b> or <b>terminal emulator</b>. Users of Linux and macOS will be most familiar with this concept. Windows users can use <b>Command Prompt</b>, an integrated terminal on some IDEs, or install a <b>Windows Terminal</b> from the Microsoft Store.</li>
				<li>A modern web browser, either based on the Chromium engine (Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi, etc.) or Mozilla Firefox.</li>
			</ul>
			<p>With these installed, we are ready to follow the examples and basic projects. However, I would recommend that you also install <b>Git</b>, for code versioning control. We will use it later in this book, in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_09.xhtml#_idTextAnchor199"><i>Chapter 9</i></span></a>, <i>Testing and Source Control</i>. In modern development, it is hard to imagine working on a project without some tool to keep track of code changes and version control. Git has become the industry standard. You can install it following the documentation from the official website <span class="No-Break">at </span><a href="https://git-scm.com/"><span class="No-Break">https://git-scm.com/</span></a><span class="No-Break">.</p>
			<p>The code files of this chapter can be found on GitHub here: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03</span></a><span class="No-Break">.</p>
			<p>Check out the following video to see the Code in Action: </span><a href="https://packt.link/CmuO9"><span class="No-Break">https://packt.link/CmuO9</a></p>
			<p>Now, with our tools in place, we are ready to start our first project in Vue 3.</p>
			<h2>Project setup and tools</h2>
			<p>We will create a new project using <b>Vite</b> as our bundler, directly from the command line. Open a terminal window in the directory where you will place our project, and follow these steps:</p>
			<ol>
				<li>Type the following command:</li>
			</ol>
			<p><b>$ npm create vite@latest</b></p>
			<ol>
				<li value="2">If you get a prompt to install additional packages, type <b>Y</b></span><span class="No-Break"> (yes).</li>
				<li>Next, you will be prompted to enter project information in the following order:</span><ol><li><b>Project name</b>: This will be used to identify the project, and to create a new folder to place it. If you want the project to be installed in the current folder, enter a period (<b>.</b>) as <span class="No-Break">the name.</span></li><li><b>Package name</b>: This name will be used internally for the package configuration. For this example, enter <b>chapter-3</b> (or any name of your choosing). This option may not show if you entered or accepted a project name or accepted the default name suggested. If you entered a period (<b>.</b>) as the name to create the project in the current directory, then this option will <span class="No-Break">be mandatory.</span></li><li><b>Select framework</b>: Here, the assistant will display a menu with options. Select <b>vue</b> with the arrow keys and <span class="No-Break">press </span><span class="No-Break"><i>Enter</i></span><span class="No-Break">.</span></li><li><b>Select variant:</b> Just like before, use the arrow keys and select JavaScript (or TypeScript, but we will use plain JavaScript throughout <span class="No-Break">this book).</li></ol></li>
			</ol>
			<p>Next, you will see how the assistant downloads additional content based on your selections and scaffolds the project. It will create a directory structure with multiple files. However, if we intend to run the project, we soon will discover that it just doesn’t work. That is because the scaffolding does not install dependencies, only the skeleton. So, there is still one more step to do, and that is to install the dependencies using <b>npm</b>. In the terminal, enter the following command and hit <i>Enter</i> (if you installed in the current directory; if not, first enter the directory just created):</p>
			<pre class="console">$ npm install</pre>
			<p>The package manager will download and install the dependencies for our project and place them in a new directory named <b>node_modules</b>. As you can guess already, our development environment for <b>Vue</b> with <b>Vite</b> is a <b>Node.js</b></span><span class="No-Break"> project.</p>
			<p>With the dependencies in place, now is the time to run the project and see what the scaffolding tool prepared for us. In the terminal, enter the following command:</p>
			<pre class="console">$ npm run dev</pre>
			<p>What happens next may be quite fast. Vite will parse your project files and launch a developer server on your machine with a web address that you can use in your browser. You will see something like this in your terminal:</p>
			<div>
				<div>
					<img src="images/Figure_3.01_B18602.jpg" alt="Figure 3.1 - The result of running the development server with Vite" width="794" height="115">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 - The result of running the development server with Vite</p>
			<p>The most important information here is <b>localhost</b> and the port where your project website is being served. The milliseconds shown there are just to let you know how fast Vite is to get you up and running (bragging rights, if you ask me). Next, to see the results of our labor so far, open the <b>local address</b> in your web browser, and you should be welcomed by a website looking something like the following screen:</p>
			<div>
				<div>
					<img src="images/Figure_3.02_B18602.jpg" alt=" Figure 3.2: Basic Vite + Vue project in the browser" width="1453" height="724">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 3.2: Basic Vite + Vue project in the browser</p>
			<p>This website is fully functional as it is, if not very productive. To test that Vue 3 is working, click the button in the middle of the screen and you’ll see how the counter increases with each click. This is reactivity in action! Moreover, Vite offers us a development server with live updates and <b>Hot Module Replacement</b> (<b>HMR</b>), which means that as soon as we make changes in our code and save the files, the website will update automatically. In practice, it is very common when developing user interfaces to keep this self-updating site open in the browser to preview our work, and in some cases, several browsers at the same time. Very neat!</p>
			<p>We have advanced in our journey, but we are far from over. The scaffolded site is nothing more than a starting point. We will modify it to better serve our purposes and will create a simple To-Do application in the rest of the chapter.</p>
			<p>In the next section, we will take a closer look at the structure and organization of our starting project.</p>
			<h2>Folder structure and modifications</h2>
			<p>In <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_01.xhtml#_idTextAnchor017"><i>Chapter 1</i></span></a>, <i>The Vue 3 Framework</i>, we mentioned that frameworks prescribe some structure for your application. Vue 3 is not an exception, but the conventions used in the directory structure are minimal when compared to other frameworks. If you open the directory where you installed the project in the Files Explorer (either from your OS or in your IDE), you will find a structure like <span class="No-Break">this one:</p>
			<div>
				<div>
					<img src="images/Figure_3.03_B18602.jpg" alt="Figure 3.3: Project structure in Visual Code" width="625" height="251">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Project structure in Visual Code</p>
			<p>The <b>.vscode</b> folder was created by the IDE, and <b>node_modules</b> was created by <b>npm</b> to allocate the dependencies. We will ignore them, as we don’t need to worry or work with them. Starting from the top, let’s review what each directory is:</p>
			<ul>
				<li><b>public</b></li>
			</ul>
			<p>This folder contains a directory structure and files that will not be processed by the bundler and will be copied directly into the final website. You can freely place your own static content here. This is where you will place your images, web fonts, third-party CSS libraries, icons, and so on. As a general rule, files here are those that will never be referenced by your code, such as <b>manifest.json</b>, <b>favicon.ico</b>, <b>robots.txt</b> and so on.</p>
			<ul>
				<li><b>src</b></li>
			</ul>
			<p>Here is where we will place our JavaScript, dynamic CSS, components, and so on. If we expand this folder, we will find that the scaffolding tool has already created a minimal structure with the following:</p>
			<ul>
				<li>An <b>assets</b> folder with an SVG file. In this folder, we can include files that will be manipulated either by the code or by the bundler. You can import them directly into your code, and the bundler will take care of mapping them properly when serving them on a web server.</li>
				<li>A <b>components</b> folder, where we will place our <b>single-file components</b> (<b>SFCs</b>), with the <b>.vue</b> extension. We can create the directory structure here as we please. The scaffolding tool has been placed inside a <b>HelloWorld.vue</b> component for us.</li>
				<li>An <b>App.vue</b> file. This is the main component of our application and the root component of our hierarchy. It is a convention to call it this way.</li>
				<li>A <b>main.js</b> file, which is the starting point of our application. It is in charge of loading the initial dependencies, the main component (<b>App.vue</b>), creating the Vue 3 application with all extras (plugins, global directives, and components), and launching and mounting the application to the web page.</li>
				<li>A <b>styles.css</b> file, which is a global stylesheet that will apply to our entire application. Previous versions of the scaffolding tool used to place it in the <b>assets</b> folder, but now it has moved to the <b>src/</b> root giving it a more predominant place. This file, when imported into the <b>main.js</b> file, will be parsed and bundled with our JavaScript.</li>
			</ul>
			<p>It is now time to investigate the files in the project root, in the same order as they appear:</p>
			<ul>
				<li><b>.gitignore</b> is a file that controls what is excluded from the Git source control. We will see Git in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_09.xhtml#_idTextAnchor199"><i>Chapter 9</i></span></a>, <i>Testing and </i><span class="No-Break"><i>Source Control</i></span><span class="No-Break">.</li>
				<li><b>index.html</b> is the main file and the starting point for our web application. The bundler will start accessing and processing other files in the order they appear, starting with <b>index.html</b>. You can modify it to fit your needs, as the generated file is quite basic. Notice how towards the end of the <b>body</b> tag, the scaffolding tool included a <b>script</b> tag to load our <b>main.js</b> file. This file is the one that creates our Vue application. Unlike other bundlers that automatically generate this file and then inject it into <b>index.html</b>, Vite requires that you have this imported explicitly. Among other advantages, this gives you control of when the Vue application will be loaded inside your web page.</li>
				<li><b>package-lock.json</b> is used by <b>npm</b> to manage the dependencies in <b>node_modules</b>. Ignore it.</li>
				<li><b>package.json</b> is very important. This file defines the project, keeps track of your development and production dependencies, and provides some nice features such as the automation of some tasks by simple commands. Of interest at this time is the <b>scripts</b> section, which defines simple aliases for commands. We can run these from the command line by typing <b>npm run &lt;script name&gt;</b>. The scaffolding tool already prepared three Vite commands for us:</span><ul><li><b>npm run dev</b>: This will launch the website in developer mode, with a local server and <span class="No-Break">live reload.</span></li><li><b>npm run build</b>: This will bundle our code and optimize it to create a <span class="No-Break">production-ready version.</span></li><li><b>npm run preview</b>: This is a middle point between the previous two. It will allow you to see locally the built production-ready version. This may sound confusing until you consider that while in development, the addresses and resources that your application access, as well as the public URL, may be different than those in production. This option lets you run the application locally, but still reference and use those production endpoints and resources. It is a good practice to run a “preview” before you deploy <span class="No-Break">your application.</li></ul></li>
				<li><b>vite.config.js</b> is the configuration file that governs how Vite will behave during development and when bundling for production. We will see some of the most important or common options later in this chapter.</li>
			</ul>
			<p>Now that we have a clearer view of what was given to us by the Vite scaffolding tool, it is time to start building our sample application. Before we dig deep into the code, there are a couple more items we need to address: how to integrate third-party stylesheets and CSS frameworks, and some Vite configurations that will make our life easier.</p>
			<h2>Integration with CSS frameworks</h2>
			<p>If we remember the last three principles discussed in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a>, <i>Software Design Principles and Patterns</i>, (<i>don’t repeat yourself</i>, <i>keep it clean</i>, and <i>code for the next</i>), reinventing the wheel in matters of visual appearance and graphic language is something not desirable in most cases. The web has an ever-growing collection of CSS frameworks and libraries that we can easily incorporate into our applications. From the old popular Bootstrap to atomic design, to utility classes such as Tailwind, and passing by graphics languages such as Material Design and skeuomorphism, the spectrum of options is huge. Vue has a good number of component libraries already implementing some of these libraries, which you can find in the <b>npm</b> repositories. Using these, you’ll be restricted to learning about and applying the conventions applied by the designer, which, in some cases, may set in stone how you can build your user interface. Typical examples of these are the use of <b>Vue-material</b> (and others) that adheres to Google’s Material Design specifications or the incorporation of web fonts and icon fonts. It is impossible to discuss each one, but here are guidelines and some examples of how to incorporate these libraries into <span class="No-Break">your project:</p>
			<ol>
				<li>Place the static assets provided by the framework or library in the <b>public</b> folder, following their required structure, and respecting whatever tree structure is needed.</li>
				<li>Include the dependencies for the CSS framework or libraries in your <b>index.html</b> file, following their instructions. Often, this will imply importing stylesheets and JavaScript files in the <b>head</b> section or the <b>body</b> tag. In either case, make sure these are placed before the loading of our application (the <b>script</b> tag that references our <b>main.js</b></span><span class="No-Break"> file).</li>
				<li>If the framework or library needs to be instantiated, do so before we mount our application. You can do this directly in <b>index.html</b> in a <b>script</b> tag, in <b>main.js</b>, or in another module.</li>
				<li>Use the classes (and JavaScript functions) in your component’s template section normally, as you would in plain HTML using these libraries. Some frameworks create JavaScript global objects attached to the <b>window</b> object, so you can access them directly in your component’s <b>script</b> section. If this is not the case, consider encapsulating the functionality to use it in your application, using a design pattern such as a <i>singleton</i>, <i>proxy</i>, or <i>decorator</i></span><span class="No-Break"> patterns.</li>
			</ol>
			<p>Now let’s put these simple instructions to work by applying them to our example project. We will incorporate a CSS-only framework (meaning that it doesn’t use additional JavaScript), and font icons to include basic iconography. In a production build, we should remove unused CSS rules. Some CSS frameworks provide this feature out of the box, such as Tailwind (<a href="https://tailwindcss.com/">https://tailwindcss.com/</a>). However, this topic is beyond the scope of this book but is worth researching online.</p>
			<h3>The w3.css framework</h3>
			<p>The website <a href="http://w3school.com/">w3school.com</a> offers a free CSS-only framework that is partially based on the Material Design language, made popular by Google, and used in many mobile applications. It offers many utility classes that you can implement, license-free, in your applications. You can find out more on the official website: </span><a href="https://www.w3schools.com/w3css/"><span class="No-Break">https://www.w3schools.com/w3css/</span></a><span class="No-Break">.</p>
			<p>We will follow the guidelines mentioned before, so let’s follow the steps:</p>
			<ol>
				<li>Download the <b>w3.css</b> file from <a href="https://www.w3schools.com/w3css/w3css_downloads.asp">https://www.w3schools.com/w3css/w3css_downloads.asp</a> and place it in a new folder named <b>css</b> in the <b>public</b> directory. When you are done, it should look like this:</li>
			</ol>
			<div>
				<div>
					<img src="images/Figure_3.04_B18602.jpg" alt="Figure 3.4 - Location for the w3.css file" width="573" height="72">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 - Location for the w3.css file</p>
			<ol>
				<li value="2">Modify <b>index.html</b> at the root of our project by adding the reference to the <b>w3.css</b> file using a <b>link</b> tag like this:<pre class="console">&lt;link rel="stylesheet" href="<b>/css/w3.css</b>"&gt;</pre></li>
			</ol>
			<p>With that inclusion, the classes defined in the CSS file are now ready to be used in our component’s templates. Also, to avoid unwelcome styles from the scaffolding of a project, remember to clear the<b> styles.css</b> file provided by the installer. If we now run the development server with <b>npm run dev</b>, we will see that the appearance of the website has changed slightly, as the new stylesheet has been successfully applied. The next step now is to add an <i>icon font</i></span><span class="No-Break">.</p>
			<h2>FontAwesome is just awesome</h2>
			<p>One of the ways that developers save resources when dealing with a multitude of icons is with the use of <b>font icons</b>. These are font files that, instead of characters, display icons. This concept is not new, but it has a lot of applications in web development. Using fonts for icons, as opposed to other techniques (such as CSS sprite sheets, for example) has plenty of benefits. One of the most relevant is that these icons are subject to the same manipulation as regular fonts, so we can easily alter their size, color, and so on, and keep them in coordination with the rest of the text. Not all is joy and happiness with this approach, since now, the major trade-off is that these icons display only one or two colors at most and have to be rather simple by necessity.</p>
			<p><b>FontAwesome</b> is a website that offers <b>icon fonts</b> to use in our applications, both web and desktop. It has been doing this for years and has some of the best icon collections out there. We can download and use its free tier for our project. Let’s follow again the guidelines to implement them in our project:</p>
			<ol>
				<li>Download the fonts <i>for the web</i> from <a href="https://fontawesome.com/download">https://fontawesome.com/download</a>. It will download a rather large ZIP file with all the different alternatives.</li>
				<li>From within the ZIP file, copy the <b>css/</b> and <b>webfonts/</b> directories as they are, to our <b>public/</b> folder. We will not use everything in this folder in our projects here, so you can delete what we don’t use later.</li>
				<li>Edit the <b>index.html</b> file to add the stylesheets that we will use. These CSS files will automatically load the icon fonts from the <b>/</b><b>webfonts/</b></span><span class="No-Break"> folder:<pre class="console">&lt;link rel="stylesheet"<b> </b>href="<b>/css/fontawesome.min.css</b>"
&gt;
&lt;link rel="stylesheet" href="<b>/css/solid.min.css</b>"&gt;
&lt;link rel="stylesheet" href="<b>/css/brands.min.css</b>"&gt;</pre></li>
			</ol>
			<p>And that is all we need to do to include FontAwesome in our project. There are other alternatives that have encapsulated the fonts into Vue components, and even the website provides a Vue implementation. However, for our purposes in this book, we will use the <i>direct</i> approach. If we open the icons section of the site, we can browse and search all the available icons. You can restrict the search to “solid” and “brands” since those are the ones we have included in our project. For example, if you want to display the Vue icon using FontAwesome, we can include the following in our template:</p>
			<pre class="source-code">&lt;i class="<b>fa-brands fa-vuejs"</b>&gt;&lt;/i&gt;</pre>
			<p>These classes make all the magic happen in any empty element, but for tradition and convenience, we always use the <b>i</b> tag. Moreover, you do not even need to type them. Once you locate the icon you want to use, the website offers this neat feature to “click and copy” the code. The previous line came from here:</p>
			<div>
				<div>
					<img src="images/Figure_3.05_B18602.jpg" alt=" Figure 3.5 - FontAwesome icon page" width="596" height="200">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 3.5 - FontAwesome icon page</p>
			<p>Let’s keep in mind that including a large library of icons when only using a few of them will impact performance. For production builds, ensure that you only include the icons you will use in your application by creating icon fonts only with the necessary icons. For the purposes of our book and during development, we can skip this practice.</p>
			<p>With a nice stylesheet and some good icon fonts, we are almost ready to start our coding. There is just one more thing to do and it is to include a few extra options in our Vite configuration.</p>
			<h2>Vite configuration options</h2>
			<p>The <b>vite.config.js</b> file exports the configuration that Vite will use for development and also for production. Vite was meant to be functional for many different frameworks and not only for Vue 3, even though it is the official bundler for it. When we open the file, we notice that Vue is a plugin for Vite. Internally, Vite uses <b>Rollup.js</b> (<a href="https://www.rollupjs.org/">https://www.rollupjs.org/</a>) and <b>esbuild </b>(<a href="https://esbuild.github.io/">https://esbuild.github.io/</a>), for development and production build, respectively. This means that we can pass options to Vite, but also have even more fine-grained control over some edge cases by passing arguments to these two underlining tools. Additionally, you can pass different configurations for each processing mode (development and production), so we are not left without options here.</p>
			<p>We will see some specific configurations for deployment in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_10.xhtml#_idTextAnchor224"><i>Chapter 10</i></span></a>, <i>Deploying Your Application</i>, but for now, we will focus only on the development part with a few additions to keep us from typing too much and repeating ourselves in <span class="No-Break">the code.</p>
			<p>Open the <b>vite.config.js</b> file and add the following import:</p>
			<pre class="console">import path from "path"</pre>
			<p>Yes, the path import is not JavaScript, but Node.js, and we can do this because this file is read and executed in a Node.js context. It will never reach the browser or any JavaScript</span><span class="No-Break"><b> </b></span><span class="No-Break">context.</p>
			<p>Modify the export configuration so it looks like this:</p>
			<pre class="source-code">export default defineConfig<b>({</b>
plugins: [vue()],
&nbsp;&nbsp;<b>resolve:{</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>alias:{</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>"@components":</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.resolve(__dirname, "src", "components")</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>}</b>
&nbsp;&nbsp;<b>}</b>
})</pre>
			<p>In these lines, we are indicating an alias named <b>@components</b> matched to the project path <b>/src/components</b>. This way, when we are importing components, we can avoid writing relative or full paths, and just reference the imports inside components in this manner:</p>
			<pre class="source-code">import <b>MyComponent</b> from "<b>@components/MyComponent.vue"</b></pre>
			<p>Having aliases for paths is a nice feature to have for a developer experience. Paths to components can get quite long in a large project, and code reorganization does happen from time to time, making maintenance yet another point of possible disruption. Having an alias defined gives us more flexibility by making changes only in one place (<i>principle: Don’t </i><i>repeat yourself</i></span><span class="No-Break">).</p>
			<p>You can find a complete reference of the Vite configuration file at <a href="https://vitejs.dev/config">https://vitejs.dev/config.</a> Vite offers a short list of official plugins (such as for Vue) at https://vitejs.dev/plugins/, but the community has provided a fair share of plugins to cover many scenarios at https://github.com/vitejs/awesome-vite#plugins. These can be installed and imported into our configuration file when and if needed.</p>
			<p>At this point, we have enough preparation done so we can move ahead and finally create our simple To-Do app.</p>
			<h2>The To-Do app</h2>
			<p>Our example application will build on the scaffolding files of a basic application. It will provide us with an input element to enter our to-do items and will display the list of tasks pending and completed.  The purpose of this exercise is as follows:</p>
			<ul>
				<li>Develop the application with live updates</li>
				<li>Create a component, with reactive elements in the <b>script </b><b>setup</b></span><span class="No-Break"> syntax</li>
				<li>Apply styles and icon fonts from third-party libraries</li>
			</ul>
			<p>When we are done, we will have a simple website that should look like this (the to-do items have been added as an example):</p>
			<div>
				<div>
					<img src="images/Figure_3.06_B18602.jpg" alt=" Figure 3.6 - The final result of our To-Do List application with styles applied" width="537" height="348">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 3.6 - The final result of our To-Do List application with styles applied</p>
			<p>For the purpose of this exercise, we will develop the entire To-Do application in one single component, which we will import into our <b>main</b> component (<b>App.vue</b>). This, of course, is purposely breaking some of the principles that we saw in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a>, <i>Software Design Principles and Design Patterns</i>. In <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><i>Chapter 4</i></span></a>, <i>User Interface Composition with Components</i>, we will take this product and “make it right” with <span class="No-Break">multiple components.</p>
			<p>In the application, the user will do the following:</p>
			<ol>
				<li>Type a short description and press the <i>Enter</i> key or click the plus sign to enter it as a task.</li>
				<li>The system will display the pending and completed tasks in separate lists, displaying how many are in each group.</li>
				<li>The user can click on any task to mark if it has been done or undone, and the application will move it to the corresponding group.</li>
			</ol>
			<p>Knowing how the application has to work, let’s move onto the code.</p>
			<h4>App.vue</h4>
			<p>This is our main component. In the starter application, we need to remove the content from each section and change it to the following (we’ll explain next what each part does):</p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import <b>ToDos </b>from "@components/ToDos.vue"
&lt;/script&gt;</pre>
			<p>In the <b>script</b> section, we only need to import a component named <b>ToDos</b> (we will create this file next). Notice how we are using already an alias for the path (<b>@components</b>). Our main component will not handle any other data or functionality, and we are using it only as a wrapper to control the layout of this application. With that in mind, our template now will look like this:</p>
			<pre class="source-code">&lt;template&gt;
&nbsp;&nbsp;&lt;div class="app w3-blue-gray"&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&lt;ToDos /&gt;</b>
&nbsp;&nbsp;&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>We declare a <b>div</b> element with a private class (<b>.app</b>) that we will define in the <b>style</b> section. We also applied one of the styles we imported from <b>W3.css</b> to give our application a background color. Inside our <b>div</b> element, we place our <b>ToDos</b> component. Notice that we are using the same name as imported into our <b>script</b> section in Pascal case. We can use this notation, or the HTML kebab-case equivalent,<b> &lt;to-dos /&gt;</b>, (lowercase words separated by hyphens). However, the recommendation is to always use Pascal case in our templates, with multiple words, to avoid conflicts with HTML components, present or future. This name will be transformed into kebab case in the final HTML.</p>
			<p>Next, we will define the style, using the CSS <b>flex</b> layout to center our component in the center of the screen:</p>
			<pre class="source-code">&lt;style scoped&gt;
.app {
&nbsp;&nbsp;display: <b>flex</b>;
&nbsp;&nbsp;justify-content: <b>center</b>;
&nbsp;&nbsp;width: 100vw;
&nbsp;&nbsp;min-height: 100vh;
&nbsp;&nbsp;padding: 5rem;
}
&lt;/style&gt;</pre>
			<p>With our main component in place, now let’s create our <b>ToDos</b> component in the <b>/src/components</b> directory, properly named </span><span class="No-Break"><b>ToDos.vue</b></span><span class="No-Break">.</p>
			<h4>ToDos.vue</h4>
			<p>In this component, we will place all the logic of this simple application. We will need the following reactive variables:</p>
			<ul>
				<li>A variable to capture the text from the input, and create our task</li>
				<li>An array where we will host our task objects with the following fields: a unique ID, a description, and a Boolean value to indicate whether it is complete or not</li>
				<li>A filtering function or computed property (or properties) to display only the tasks that are completed</li>
			</ul>
			<p>With the preceding requirements, let’s populate our <b>script</b> section with the following code:</p>
			<pre class="source-code">import { <b>ref, computed </b>} from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
<b>&nbsp;&nbsp;&nbsp;&nbsp;_todo_text </b>= ref(""),
<b>&nbsp;&nbsp;&nbsp;&nbsp;_todo_list </b>= ref([]),
<b>&nbsp;&nbsp;&nbsp;&nbsp;_pending = computed</b>(() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _todo_list.value.filter(item =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!item.checked)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),
<b>&nbsp;&nbsp;&nbsp;&nbsp;_done = computed(</b>() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _todo_list.value.filter(item =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.checked)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
function <b>clearToDo</b>() {_todo_text.value = ""}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
function <b>addToDo</b>() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6
&nbsp;&nbsp;&nbsp;&nbsp;if (_todo_text.value &amp;&amp; _todo_text.value !== "") {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_todo_list.value.push({id:&nbsp;&nbsp;new Date().valueOf(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: _todo_text.value, checked: false})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearToDo()
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
			<p>We start by importing the <b>ref</b> and <b>computed</b> constructors from Vue in line <b>//1</b>, since this is all that we will need in this application from the framework. In line <b>//2</b>, we start declaring two constants to point to reactive values: <b>_todo_text</b>, which will host our user’s task description in the input element, and <b>_todo_list</b>, which will be the array of tasks (to-do items). In lines <b>//3</b> and <b>//4</b>, we declare two <b>computed</b> properties named <b>_pending</b> and <b>_done</b>. The first one will have a reactive array of all the to-do items that are incomplete, and the second one all those marked as completed. Notice that by using a <b>computed</b> property, we only need to keep a single array with all the items. Computed properties are used to get a view segment of the list according to our needs. This is a commonly used pattern for these kinds of circumstances as opposed to, for example, having two arrays for each group and moving items between them.</p>
			<p>Finally, we have a helper function in line <b>//5</b>, to reset the value of our item text, and in line <b>//6</b>, we have a simple function that checks the value of the description and creates a task (to-do item) to add to our list. It is important to note that the moment we modify <b>_task_list</b>, all the properties and variables that depend on it will be automatically re-evaluated. Such is the case with the <b>computed</b></span><span class="No-Break"> properties.</p>
			<p>This is all that we will need in our component’s logic to achieve the results we want. Now, it is time to create the template with HTML. We will split the code into sections for convenience. The segments that appear highlighted mark those with bindings or interactions with the framework and our code in the <b>script</b></span><span class="No-Break"> section:</p>
			<pre class="source-code">&lt;div class="todo-container w3-white w3-card-4"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- Simple header --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div class="w3-container w3-black w3-margin-0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w3-bottombar w3-border-blue"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i class="fa-solid fa-clipboard-list"&gt;&lt;/i&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To-Do List
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/h1&gt;
&lt;/div&gt;</pre>
			<p>The template of our component starts in line <b>//1</b> by defining a wrapper element with some styles. Then, in line <b>//2</b>, we place a simple header with styles and an icon font. Notice how we are using CSS classes from the <b>W3 CSS framework</b>, at the same time as our own scoped styles. The next lines in the code will focus on capturing the user input:</p>
			<pre class="source-code">&lt;!-- User input --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&lt;div class="w3-container flex-container w3-light-gray w3-padding"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input class="w3-input w3-border-0" type="text"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autofocus
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-model="_todo_text"</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>@keyup.enter="addToDo()"</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder="Type here your to-do item..."&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;button class="w3-button w3-gray" <b>@click="clearToDo()"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i class="fa-solid fa-times"&gt;&lt;/i&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;button class="w3-button w3-blue"<b> @click="addToDo()"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i class="fa-solid fa-plus"&gt;&lt;/i&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&lt;/div&gt;</pre>
			<p>The interactivity with the user starts in the section in line <b>//3</b>, where we define an input element and attach our <b>_todo_text</b> reactive variable with the <b>v-model</b> directive. From this time on, anything that the user types into our input box will be the value of our variable in the code. Just for convenience, we are also capturing the <i>Enter</i> key with the following attribute:</p>
			<pre class="source-code">@keyup.enter="addToDo()"</pre>
			<p>This will trigger the <b>addToDo</b> function from our script. We will add the same in the plus button next to the input field, also on the <b>click</b></span><span class="No-Break"> event:</p>
			<pre class="source-code">@click="addToDo()"</pre>
			<p>This gives us two ways to enter our descriptions as tasks for our to-do list, using multiple events linked to the same function. The following code now focuses on displaying the input data:</p>
			<pre class="source-code">&lt;!-- List of pending items --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
&lt;div class="w3-padding w3-blue"&gt;Pending (<b>{{ _pending.length }}</b>)
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-for="todo in _pending" :key="todo.id"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="checkbox" <b>v-model="todo.checked"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span class="w3-margin-left"&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ todo.text }}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-show="_pending.length == 0"</b>&gt;No tasks
&lt;/div&gt;
&lt;!-- List of completed tasks --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
&lt;div class="w3-padding w3-blue"&gt;Completed (<b>{{ _done.length }}</b>)
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-for="todo in _done" :key="todo.id"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="checkbox" <b>v-model="todo.checked"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span class="w3-margin-left"&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ todo.text }}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-show="_done.length == 0"</b>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6
&nbsp;&nbsp;No tasks
&lt;/div&gt;
&lt;/div&gt;</pre>
			<p>To display our task list, we have two almost identical blocks of code, starting on lines <b>//4</b> and <b>//5</b> – one for the pending tasks and the other for the completed ones. We will only focus on the first block (starting on line <b>//4</b>) since the behavior of these blocks is almost the same. In the first <b>div</b> element, we create a small header that displays the number of items on the <b>_pending</b> array, by interpolating its length. We do this with the following line:</p>
			<pre class="source-code">Pending (<b>{{ _pending.length }}</b>)</pre>
			<p>Notice how we can access the array attributes directly inside the double curly brackets, without the use of the <b>.value</b> attribute. While in our JavaScript code, we should write this as <b>_pending.value.length</b>, when we are using interpolation in our HTML, Vue is smart enough to identify the reactive variable in our <b>template</b> section and access the value directly. This is true for <b>computed</b> properties as well as reactive variables created with </span><span class="No-Break"><b>ref()</b></span><span class="No-Break">.</p>
			<p>In the next <b>div</b> element, we create a list with a <b>v-for/:key</b> directive that will iterate over our <b>_pending</b> array and create a copy of the element for each item. Inside each one, we can now reference each item with the name <b>todo</b>, which we declared in the <b>v-for</b> directive. Next, we wrap an <b>input</b> checkbox and a span inside a <b>label</b> element and bind the <b>todo.checked</b> property (Boolean) to the input with <b>v-model</b>. Vue will take care of assigning a <b>true</b> or <b>false</b> value depending on the state of the checkbox. When that happens, it will also trigger the recalculation of the <b>computed</b> properties and we will see how just by checking/unchecking an item, it moves between groups (pending and completed) and also updates the total number of each block. We also have a <b>span</b> element to display the text of the task.</p>
			<p>Finally, for the cases when a list group is empty, we also have a <b>div</b> element that will be visible only when that list is empty in line <b>//</b><b>6</b></span><span class="No-Break"> (</span><span class="No-Break"><b>_pending.length==0</b></span><span class="No-Break">).</p>
			<p>As mentioned before, the part that displays our “done” list works in the same way, applying the same logic.</p>
			<p>Our scoped styles will be quite small in this case, as we only need a couple of extra settings since most of the heavy lifting has been done using the <b>w3.css</b> library. Inside our <b>style</b> section, add the following:</p>
			<pre class="source-code">.todo-container {max-width: 100%; min-width: 30rem;}
label {cursor: pointer; display: flex;}</pre>
			<p>The <b>todo-container</b> class limits the maximum and minimum width of our component, and we also modify the <b>label</b> element to display its children using the <b>flex</b></span><span class="No-Break"> layout.</p>
			<p>To see the application in action, save all the changes and start the Vite development server with the following command in the terminal:</p>
			<pre class="console">$ npm run dev</pre>
			<p>Once Vite is ready, open the address in the web browser just as we did before. If all is well, you should see our To-Do list working as expected. If not, check with the source code in the repository to make sure that your typed code matches the full example.</p>
			<h4>A quick critique of our To-Do application</h4>
			<p>The application we just made is working and is a bit more advanced than a simple <b>Hello World</b> or a counter button. However, we have not applied all the best practices and patterns that we should or could. This is done on purpose, as a learning exercise. Sometimes, to know how to build something right, we first need to build it to work as is. In general, all engineering practices understand that there is an iterative refinement process that provides learning and sophistication with each interaction. Once we build our first prototype, it is time to take a step back and do a sincere critique of it, thinking about how we can improve it and do things better. In this case, here is our critique:</p>
			<ul>
				<li>We have duplication of code in our template, as the <b>_pending</b> and <b>_done</b> computed properties are basically the same, with a minor difference based on the value of a variable.</li>
				<li>We are not leveraging the power of components, as everything is built in a single component.</li>
				<li>Our component is also creating our models (the To-Do items), so our business logic is tied to our component.</li>
				<li>We have done very little in terms of input sanitization and control. It is foreseeable that some code, even equal inputs, will break our application.</li>
				<li>Our to-do list is volatile. A refresh of the page will wipe clean our list.</li>
				<li>Our task only accommodates two states (done and pending). What if we want to have a third state or more? For example, in progress, waiting, or next in line?</li>
				<li>The current design does not provide a way to edit or delete a task once it has been created.</li>
				<li>We can only manage one list of items at a time.</li>
			</ul>
			<p>As we move forward, we will improve our application and apply principles and patterns to make this a more resilient and useful application. In the next chapter, we will look at how to compose a web application with web components in a more approachable way.</p>
			<h2>Summary</h2>
			<p>In this chapter, we have started to create applications using real-life tools, from IDEs to command-line tools, to scaffold, preview, and build our application. We have also created a simple To-Do application and learned how we can integrate third-party CSS libraries and icon fonts into our application and defined some general guidelines to incorporate others. We also took a critical approach to our simple application as a step to improve its functionality and, at the same time, our skills. In the next chapter, we will look into how to better organize our code and create a component hierarchy to create our user interfaces.</p>
			<h2>Review questions</h2>
			<ul>
				<li>What are the requirements to develop a Vue 3 application with Vite?</li>
				<li>Is it possible to integrate third-party libraries and frameworks with Vue 3?</li>
				<li>What are some steps to integrate a CSS-only library with a Vue application?</li>
				<li>Is creating an application inside a single component a good idea? Why yes or no? Can you think of scenarios when a single-component application is the right fit? How about a scenario when it is not?</li>
				<li>Why is software development an iterative refinement process?</li>
			</ul>
		</div>
	</div></div>