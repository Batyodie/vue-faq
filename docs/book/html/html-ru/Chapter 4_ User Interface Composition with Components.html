			<h1>Композиция пользовательского интерфейса с помощью компонентов</h1>
			<p>В этой главе мы подробно рассмотрим, как компоновать пользовательские интерфейсы с помощью компонентов. Хотя мы могли бы просто создать всю веб-страницу с помощью одного компонента, как мы это сделали с нашим начальным приложением <i>Список дел</i> в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>главе 3</i></span></a>, <i>Установка рабочего проекта</i>, такой подход не является хорошей практикой, за исключением простых приложений, частичного переноса функциональности в существующих веб-приложениях или некоторых крайних случаев, когда другого варианта быть не может. Компоненты занимают центральное место в подходе Vue к <span class="No-Break">построению интерфейсов.</p> <p>В этой главе мы расскажем о том, как в Vue реализовано построение интерфейсов.
			<p>В этой главе мы сделаем следующее:</p>
			<ul>
				<li>Узнаем, как компоновать пользовательские интерфейсы с помощью иерархии компонентов</li>
				<li>Познакомимся с различными способами взаимодействия и связи компонентов друг с другом</li>
				<li>Рассмотрим специальные и пользовательские компоненты</li>
				<li>Создать пример плагина с применением паттернов проектирования</li>
				<li>Перепишите наше приложение для выполнения дел, используя наш плагин и композицию компонентов</li>.
			</ul>
			<p>В этой главе мы познакомимся с основными и расширенными концепциями и получим инструменты для создания надежных веб-приложений с многократно используемыми компонентами. В частности, мы применим наши знания о паттернах проектирования из <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>главы 2</i></span></a>, <i>Принципы и паттерны проектирования программного обеспечения</i>, при реализации <span class="No-Break">кода.</p> <h6>Примечание о стилях</i>.
			<h6>Примечание о стилях</h6>
			<p class="callout">Чтобы избежать длинных списков кода, мы опустим примеры иконок и стилей в примере кода. Полный код, а также стили и иконки можно найти в репозитории GitHub этой книги по адресу </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></a><span class="No-Break">.</p>.
			<h2>Технические требования</h2>
			<p>Требования к выполнению этой главы такие же, как и в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>главе 3</i></span></a>, <i>Setting Up a </i><span class="No-Break"><i>Working Project</i></span><span class="No-Break">.
			<p>Посмотрите следующее видео, чтобы увидеть код в действии: </span><a href="https://packt.link/eqm4l"><span class="No-Break">https://packt.link/eqm4l</a></p> <p>.
			<p>Файлы кода этой главы можно найти на GitHub здесь: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04</a></p> <p>Кодовые файлы этой главы можно найти на GitHub здесь.
			<h2>Составление страницы с помощью компонентов</h2>
			<p><a id="_idTextAnchor106"></a> Для создания пользовательского интерфейса необходимо иметь отправную точку, будь то грубый набросок или фантазийный полноценный дизайн. Графический дизайн веб-приложения выходит за рамки данной книги, поэтому мы будем считать, что он уже создан. Чтобы воплотить дизайн в компоненты, мы можем подойти к этому как к процессу, который отвечает на следующие вопросы:</p>
			<ol>
				<li>Как мы можем представить макет и множество элементов с помощью компонентов?</li>
				<li>Как эти компоненты будут взаимодействовать друг с другом и связаны между собой?</li>
				<li>Какие динамические элементы будут входить и выходить из сцены, и какие события или состояния приложения будут их вызывать?</li>
				<li>Какие паттерны проектирования мы можем применить, чтобы наилучшим образом удовлетворить требованиям данного сценария использования, учитывая компромиссы?</li>
			</ol>
			<p>Vue 3 специально подходит для создания динамичных, интерактивных интерфейсов. Эти вопросы приводят нас к повторяемому подходу к реализации. Итак, давайте определим общий процесс с четко определенными этапами, шаг за шагом.</p>
			<h3>Этап 1 - определение макетов и элементов пользовательского интерфейса</h3>.
			<p>Этот этап отвечает на вопрос: <i>Как мы можем представить макет и множество элементов </i><i>с помощью компонентов?</i></p>
			<p>Мы возьмем страницу в целом и подумаем, какой макет будет работать лучше всего, учитывая дизайн. Следует ли использовать колонки? Разделы? Навигационные меню? Острова контента? Есть ли диалоговые или модальные окна? Простой подход заключается в том, чтобы взять изображение дизайна и обозначить прямоугольниками участки, которые могут представлять собой компоненты, начиная с самого крайнего и заканчивая единичной единицей взаимодействия. Итерируйте эту <i>нарезку</i> страницы до тех пор, пока не получите комфортное количество компонентов. Если рассматривать новый дизайн приложения To-Do, то этот шаг может выглядеть следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_4.01_B18602.jpg" alt="Рисунок 4.1 - Нарезка дизайна на компоненты с пунктирными рамками" width="697" height="428">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Рисунок 4.1 - Разбивка конструкции на компоненты с пунктирными рамками</p>
			<p>После того как мы определили компоненты, необходимо выявить связи между ними, создав иерархию от самого верхнего корневого компонента (обычно это наш <b>App.vue</b>). Новые компоненты могут появиться в результате группировки компонентов по контексту или функциональности. Это подходящее время для присвоения имен компонентам. Эта начальная архитектура будет развиваться по мере реализации паттернов проектирования. В соответствии с этим примером иерархия может выглядеть следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_4.02_B18602.jpg" alt="Рисунок 4.2 - Начальный подход к иерархии компонентов" width="527" height="220">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 4.2 - Начальный подход к иерархии компонентов</p>
			<p>Заметьте, как из группировки других компонентов появился новый компонент <b>ToDoProject.vue</b>. Компонент <b>App</b> обычно имеет дело с основным макетом приложения и является отправной точкой в иерархии. Теперь, когда мы создали первоначальный дизайн, пора переходить к следующему шагу.</p> <h3>Шаг 2 - компонент <b>App</b>.
			<h3>Шаг 2 - определение связей, потока данных, взаимодействий и событий</h3>.
			<p>Этот шаг отвечает на вопрос: <i>Как эти компоненты будут взаимодействовать и относиться друг к другу?
			<p>На этом этапе нам необходимо понять, как будет взаимодействовать пользователь (с вариантом использования, пользовательской историей или чем-то еще). Для каждого компонента мы решаем, какую информацию он будет хранить (состояние), что будет передавать своим дочерним компонентам, что ему нужно от родителя и какие события он будет вызывать. В Vue компоненты могут соотноситься друг с другом только по вертикали. Братья и сестры по большей части игнорируют существование друг друга. Если компоненту-сиблингу необходимо поделиться данными с другим компонентом, то эти данные должны быть размещены у общей третьей стороны, которая может поделиться ими с обоими компонентами, обычно это родитель, который имеет общую видимость. Для этого существуют и другие решения, например, реактивное управление состоянием, которое мы подробно рассмотрим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>главе 7</i></span></a>, <i>Управление потоками данных</i>. В этой главе мы остановимся на базовой функциональности <span class="No-Break">отношений.</p>
			<p>Существует множество способов документирования этой информации: заметки в дереве иерархии (см. <i>Рисунок 4</i></span><i>.2</i>), описательная формальная документация, UML-диаграммы (<b>UML</b> означает <b>Universal Modeling Language</b>, иконографическое представление компонентов программного обеспечения) и многое другое. Для простоты запишем только один сегмент дерева в формате <span class="No-Break">таблицы:</p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col>
					<col>
					<col>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Компонент</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Функция</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Состояние, </b><b>входы/выходы, события</b></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ToDoProject.vue</p>
						</td>
						<td class="No-Table-Style">
							<p>Хостит список дел и координирует взаимодействие с пользователем. Этот компонент будет активно изменять элементы.</p>
						</td>
						<td class="No-Table-Style">
							<p>Состояние: Список дел</p>
							<p>События: Открытие новых, редактирование и удаление модалов</p> <p>.
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ToDoSummary.vue</p>
						</td>
						<td class="No-Table-Style">
							<p>Отображает суммарный подсчет элементов дел по состоянию.</p>
						</td>
						<td class="No-Table-Style">
							<p>Ввод: Список дел</p> <p>
							<p>Состояние: Счетчики для каждого состояния элемента</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ToDoFilter.vue</p>
						</td>
						<td class="No-Table-Style">
							<p>Собирает строку для фильтрации списка дел.</p>
						</td>
						<td class="No-Table-Style">
							<p>Выход: Строка фильтра</p> <p>
							<p>Состояние: Вспомогательная переменная</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ToDoList.vue</p>
						</td>
						<td class="No-Table-Style">
							<p>Отображает список дел и сигнальные операции для каждого из них.</p>
						</td>
						<td class="No-Table-Style">
							<p>Входные данные: Список дел, строка фильтра</p> </p> <p>События.
							<p>События: Переключение состояния элемента, редактирование и удаление элемента</p> <p>.
						</td>
					</tr>
				</tbody>
			</table>
			<p>Для краткости я опустил компоненты и взаимодействия, которые будут составлять пользовательские диалоги.
Мы увидим их позже в этой главе, но достаточно сказать, что за управление взаимодействием с помощью модальных диалогов отвечает <b>ToDoProject.vue</b>.</p>.
			<h3>Шаг 3 - определение элементов пользовательской интерактивности (входов, диалогов, уведомлений и т.д.)</h3>
			<p>Этот шаг отвечает на вопрос: <i>Какие динамические элементы будут выходить на сцену или покидать ее, и какие события или состояния приложения будут их </i><i>вызывать?</i></p> <p>В нашем приложении мы используем динамические элементы, которые будут выходить на сцену или покидать ее, и какие события или состояния приложения будут их вызывать.
			<p>В нашем приложении основные CRUD-операции (<b>CRUD</b> расшифровывается как <b>Create, Read, Update, Delete</b> данных) связаны с использованием модальных диалогов, представляемых пользователю. Как уже говорилось, именно компонент <b>ToDoProject.vue</b> управляет этим взаимодействием в ответ на определенные события. Этот процесс проиллюстрирован на данной диаграмме последовательности:</p>
			<div>
				<div>
					<img src="images/Figure_4.03_B18602.jpg" alt="Рисунок 4.3 - Взаимодействие пользователя через модалы - редактирование элемента" width="460" height="253">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 4.3 - Взаимодействие пользователя через модалы - редактирование элемента</p>.
			<p>На этой диаграмме компонент <b>ToDoProject</b> разделяет список дел с компонентом <b>ToDoList</b>. Когда пользователь вызывает событие <b>edit</b>, дочерний компонент уведомляет родительский, поднимая такое событие. После этого родительский компонент создает копию элемента и открывает модальный диалог, передавая эту копию. Когда диалог принят, родитель модифицирует исходный элемент с учетом изменений. Затем реактивность Vue отражает изменение состояния в дочерних компонентах.</p> <p> Часто такие взаимодействия происходят с дочерними компонентами.
			<p>Зачастую такое взаимодействие помогает нам выявить необходимость в дополнительных компонентах, которые не были очевидны в <i>шаге 1</i>, например, в реализации паттернов проектирования... что является следующим шагом.</p>
			<h3>Шаг 4 - выявление паттернов проектирования и компромиссов</h3>
			<p>Этот шаг отвечает на вопрос: <i>Какие паттерны проектирования мы можем применить, чтобы наилучшим образом удовлетворить требованиям конкретного случая использования, </i><i>с учетом компромиссов?</i></p>
			<p>Решение вопроса о том, какие паттерны использовать, может быть очень творческим процессом. Не существует "серебряной пули", и несколько решений могут дать разные результаты. Обычно создается несколько прототипов для тестирования различных подходов.</p> <p> В нашем новом приложении мы используем несколько прототипов.
			<p>В нашем новом приложении мы ввели концепцию модальных диалогов для получения пользовательского ввода. Модальные диалоги используются в тех случаях, когда для выполнения операции требуется действие или решение пользователя. Пользователь может принять или отклонить диалог и не может взаимодействовать с другими частями приложения до тех пор, пока не примет решение. Учитывая эти условия, одним из возможных паттернов для применения является паттерн <b>Async </b><b>Promise</b></span><span class="No-Break">.
			<p>В нашем коде мы хотим открыть модальный диалог в виде обещания, которое, по определению, предоставит нам функцию <b>resolve()</b> (принять) или <b>reject()</b> (отменить). Более того, мы хотим иметь возможность использовать это решение в нескольких проектах и глобально в нашем приложении. Для этого мы можем создать плагин и использовать паттерн <b>инъекции зависимостей</b> для доступа к модальной функциональности из любого компонента. Эти паттерны обеспечат нам решение, необходимое для того, чтобы сделать наш модальный диалог многократно используемым.</p> <p>На данном этапе мы можем создать плагин.
			<p>На данном этапе мы практически готовы приступить к концептуальной реализации компонентов. Однако, чтобы создать более подходящее и прочное приложение и реализовать вышеупомянутые паттерны, нам следует уделить время более подробному изучению компонентов Vue.</p> <h>Компоненты в Vue
			<h2>Компоненты в деталях</h2>
			<p>Компоненты - это строительные блоки фреймворка. В <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_01.xhtml#_idTextAnchor017"><i>главе 1</i></span></a>, <i>Фреймворк Vue 3</i>, мы рассмотрели, как работать с компонентами, объявлять реактивные переменные и многое другое. В этом разделе мы рассмотрим более продвинутые возможности <span class="No-Break">и определения.</p>
			<h3>Локальные и глобальные компоненты</h3>
			<p>При запуске нашего приложения Vue 3 мы монтируем главный компонент (<b>App.vue</b>) к элементу HTML в файле <b>main.js</b>. После этого в секции script каждого компонента мы можем импортировать другие компоненты для локального использования с помощью следующей команды:</p>
			<pre class="source-code">import MyComponent from "./MyComponent.vue"</pre>
			<p>Таким образом, чтобы использовать <b>MyComponent</b> в другом компоненте, нам необходимо импортировать его в этот компонент еще раз. Если один компонент постоянно используется в нескольких компонентах, то это повторяющееся действие нарушает принцип DRY разработки (см. <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Глава 2</i></span></a>, <i>Принципы и паттерны проектирования программного обеспечения</i>). Альтернативный вариант - объявить компонент как <b>глобальный</b>, прикрепив его непосредственно к нашему приложению Vue вместо каждого компонента. В файле <b>main.js</b> мы можем использовать метод <b>App.component()</b> для этого <span class="No-Break">случая использования:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Main.js</p>
			<pre class="source-code">Импортируем { createApp } из "vue"
import App from './App.vue'
<b>Импортируем MyComponent из "./MyComponent.vue"</b>
createApp(App)
&nbsp;&nbsp;&nbsp;&nbsp;<b>.component('MyComponent', MyComponent)</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mount("#app")</pre>
			<p>Метод <b>component()</b> получает два аргумента: <b>String</b>, представляющий собой HTML-тег компонента, и объект с определением компонента (импортированным или встроенным). После регистрации он становится доступным для всех компонентов нашего приложения. Однако у использования глобальных компонентов есть несколько недостатков:</p>
			<ul>
				<li>Компонент будет включен в финальную сборку, даже если никогда не будет использоваться</li>.
				<li>Глобальная регистрация затушевывает отношения и зависимости между компонентами</li>
				<li>Возможна коллизия имен с локально импортированными компонентами</li>
			</ul>
			<p>Рекомендуется глобально регистрировать только те компоненты, которые обеспечивают общую функциональность, и избегать тех, которые являются неотъемлемой частью рабочего процесса или специфического контекста.</p>
			<h3>Статический, асинхронный и динамический импорт</h3>
			<p>До сих пор все компоненты, которые мы импортировали, были определены <i>статически</i> с помощью синтаксиса <b>import XYZ from "filename"</b>. Такие бандлеры, как <b>Vite</b>, включают их в один JavaScript-файл. Это увеличивает размер пакета и может привести к задержкам при запуске нашего приложения, поскольку браузеру необходимо загрузить, разобрать и выполнить пакет и все его зависимости, прежде чем произойдет взаимодействие с пользователем. Этот код может содержать функции, которые редко используются или к которым редко обращаются. Альтернативой этому может быть разбиение файла пакета на несколько небольших файлов и загрузка их по мере необходимости. В данном случае у нас есть два подхода - один, предусмотренный Vue 3, и другой, предусмотренный новейшим синтаксисом JavaScript для динамического импорта.</p> <p> Vue 3 предоставляет возможность динамического импорта.
			<p>В Vue 3 предусмотрена функция <b>defineAsyncComponent</b>. Эта функция принимает в качестве параметра другую функцию, которая возвращает динамический импорт. Вот пример:</p>
			<pre class="console">import {<b>defineAsyncComponent</b>} from "vue"
const MyComponent = <b>defineAsyncComponent</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()=&gt;import("MyComponent.vue")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</pre>
			<p>Использование этой функции делает ее безопасной для применения в большинстве бандлеров. Альтернативой этому синтаксису является Vue Router, который мы рассмотрим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>главе 5</i></span></a>, <i>Одностраничные приложения</i>: динамическое объявление <b>import()</b>, предоставляемое JavaScript (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import</a>), Оно имеет очень <span class="No-Break">похожий синтаксис:</p>
			<pre class="source-code">const MyComponent = () =&gt; import('./MyComponent.vue')</pre>
			<p>Как видите, этот синтаксис более лаконичен. Однако его можно использовать только при определении маршрутов с помощью Vue Router, так как внутри Vue 3 и Vue Router по-разному обрабатывают ленивую загрузку компонентов. В конечном итоге оба подхода позволят разделить основной файл пакета на несколько файлов меньшего размера, которые будут автоматически загружаться при необходимости в нашем приложении.</p>
			<p> Однако <b>defineAsyncComponent</b> имеет ряд преимуществ. Мы можем передать любую функцию, возвращающую обещание, которое разрешается в компонент. Это позволяет нам реализовать логику динамического управления процессом во время выполнения. Приведем пример, в котором мы решили загрузить один компонент на основе значения входного параметра:</p>
			<pre class="source-code">const ExampleComponent=defineAsyncComponent(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(some_input_value_is_true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import OneComponent from "OneComponent.vue"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(OneComponent)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import AnotherComponent from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AnotherComponent.vue"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(AnotherComponent)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
})</pre>
			<p>Третий синтаксис для <b>defineAsyncComponent</b>, пожалуй, самый полезный. В качестве аргумента мы можем передать объект с атрибутами, что обеспечивает больший контроль над операцией загрузки.
Он имеет такие атрибуты:</p>
			<ul>
				<li><b>загрузчик</b> (обязательно): Он должен предоставлять функцию, возвращающую обещание, которое загружает компонент</li>.
				<li><b>loadingComponent</b>: компонент, который будет отображаться во время загрузки асинхронного компонента</li>.
				<li><b>delay</b>: количество миллисекунд, которое нужно подождать перед отображением </span><span class="No-Break"><b>loadingComponent</b></li>.
				<li><b>errorComponent</b>: Компонент, который будет отображаться, если обещание будет отклонено или если загрузка не удастся по какой-либо причине</li>.
				<li><b>timeout</b>: время в миллисекундах до признания операции неудачной и отображения </span><span class="No-Break"><b>errorComponent</b></li>.
			</ul>
			<p>Приведем пример, в котором используются все эти атрибуты:</p>
			<pre class="console">const HeavyComponent = defineAsyncComponent(<b>{</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>загрузчик</b>: ()=&gt; import("./HeavyComponent"),
&nbsp;&nbsp;&nbsp;&nbsp;<b>загрузочный компонент</b>: SpinnerComponent,
&nbsp;&nbsp;&nbsp;&nbsp;<b>задержка</b>: 200,
&nbsp;&nbsp;&nbsp;&nbsp;<b>errorComponent</b>: LoadingError,
&nbsp;&nbsp;&nbsp;&nbsp;<b>timeout</b>: 60000
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>)</pre>.
			<Пока браузер извлекает компонент из атрибута <b>loader</b>, мы отображаем <b>SpinnerComponent</b>, чтобы сообщить пользователю, что операция выполняется. По истечении 1 минуты ожидания, определяемой параметром <b>timeout</b>, автоматически отображается компонент <b>LoadingError</b>.</p>
			<p>При таком подходе наш код лучше оптимизирован. Теперь давайте узнаем, как получать данные и уведомлять другие компоненты с помощью событий.</p> <p>
			<h3>Пропки, события и директива v-model</h3>.
			<p>Мы рассмотрели основные возможности использования props и events как средств передачи данных от компонента к его родителю. Однако с помощью различных синтаксисов возможны и более мощные определения. Реквизиты могут быть определены в синтаксисе <b>настройки скрипта</b> с помощью команды <b>defineProps</b> и любого из следующих форматов аргументов:</p>
			<ul>
				<li>В виде массива строк - например:</li>
			</ul>
			<p><b>const $props=defineProps(</b><b>['name', 'last_name']</b><b>)</b></p>
			<ul>
				<li>В виде объекта, атрибуты которого используются в качестве имени, а значение имеет тип данных - например, </li>
			</ul>
			<p><b>const $props=defineProps(</b><b>{name: String, age: Number}</b><b>)</b></p> <p>Как объект, в качестве атрибутов которого используется имя, а в качестве значения - тип данных, например
			<p>В качестве объекта, атрибуты которого определяют объект с типом и значением по умолчанию - например, </p>
			<p><b>const $props=defineProps(</b><b>{</b></p>
			<p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: { type: String, default: "John"},</b></p> <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: { type: "Имя", { type: "Тип", по умолчанию: "John"}.
			<p><b>&nbsp;&nbsp;&nbsp;&nbsp;last_name: {type: String, default: "Doe"}</b></p> <p><b>.
			<p><b> }</b><b>)</b></p> <p><b>&nbsp;</b></b>.
			<p>Необходимо помнить, что примитивные значения передаются в компонент по <b>значению</b><b> </b> (это означает, что изменение их значения в дочернем компоненте не повлияет на их значение в родительском). Однако сложные типы данных, такие как объекты и массивы, передаются как <b>ссылки</b>, поэтому изменения их внутренних ключей/значений отразятся в родительском компоненте.</p>
			<h6>Примечание о сложных типах</h6>
			<p class="callout">При определении реквизитов типа <b>Object</b> или <b>Array</b> со значениями по умолчанию, атрибут default должен быть функцией, возвращающей указанный объект или массив. В противном случае ссылка на объект/массив будет общей для всех экземпляров компонента.</p> <p><i>События</i>.
			<p><i>События</i> - это сигналы, которые дочерний компонент подает родительскому. Вот пример определения событий для компонента в синтаксисе <b>script </b><b>setup</b></span><span class="No-Break">:</p>
			<pre class="console">const $emit=<b>defineEmits(</b>['eventName']<b>)</b></pre>
			<p>В отличие от реквизитов, эмиты принимают только массив строк объявления. События также могут передавать приемнику значение. Вот пример вызова из вышеупомянутого определения:</p>
			<pre class="source-code">$emit('eventName', some_value)</pre>.
			<p>Как видите, <b>defineEmits</b> возвращает функцию, принимающую в качестве первого аргумента одно из имен, указанных в массиве определений. Второй аргумент, <b>some_value</b>, является необязательным.</p>
			<h3>Настраиваемые контроллеры ввода</h3>
			<p>Одним из особых применений совместного действия реквизитов и событий является создание пользовательских контроллеров ввода. В предыдущих примерах мы использовали директиву Vue <b>v-model</b> для базовых элементов ввода HTML, чтобы перехватить их значение. Реквизиты и события, которые следуют специальному соглашению об именовании, позволяют создавать компоненты ввода, которые принимают директиву <b>v-model</b>. Рассмотрим следующий код:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Шаблон родительского компонента</p>
			<pre class="source-code">&lt;MyComponent <b>v-model</b>="parent_variable"&gt;&lt;/MyComponent&gt;</pre>.
			<p>Теперь, когда у нас есть <b>MyComponent</b>, используемый внутри родительского компонента, давайте посмотрим, как мы создаем привязку:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Настройка скрипта MyComponent</p>
			<pre class="source-code">const $props=defineProps(['<b>modelValue'</b>]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$emit=defineEmits(['<b>update:modelValue'</b>])</pre>.
			<p>Для краткости мы используем определение массива <b>Props</b>. Обратите внимание, что имя реквизита - <b>modelValue</b>, а событие - <b>update:modelValue</b>. Такой синтаксис является ожидаемым. Когда родитель присваивает переменной <b>v-model</b>, ее значение будет скопировано в <b>modelValue</b>. Когда дочерняя переменная выдает событие <b>update:modelValue</b>, значение родительской переменной будет обновлено. Таким образом, можно создавать мощные элементы управления вводом. Но это еще не все - можно иметь несколько</span><span class="No-Break"><b> v-моделей!</b></p>
			<p>Считаем, что <b>modelValue</b> является значением по умолчанию при использовании <b>v-модели</b>. В Vue 3 появился новый синтаксис для этой директивы, благодаря чему мы можем иметь несколько моделей. Объявление очень простое. Рассмотрим объявление следующего дочернего компонента:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"> Реквизиты и события дочернего компонента</p>
			<pre class="source-code">const
&nbsp;&nbsp;$props=defineProps(['modelValue', <b>'title'</b>]),
&nbsp;&nbsp;$emit=defineEmits(['update:modelValue',<b>'update:title'</b>])</pre>.
			<p>После определения props и emits мы можем ссылаться на них из родительского компонента, как показано в следующем примере:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Шаблон родительского компонента</p>
			<pre class="source-code">&lt;ChildComponent <b>v-model</b>="varA" <b>v-model:title</b>="varB"&gt;&lt;/ChildComponent&gt;</pre>.
			<p>Как мы видим, к директиве <b>v-model:name_of_prop</b> можно присоединить модификатор. Теперь в компоненте <b>Child</b> имя события должно включать префикс <b>update:</b></span><span class="No-Break">.</p>.
			<p>Использование реквизитов и событий позволяет осуществлять прямой обмен данными между родительскими и дочерними компонентами. Это означает, что если данные должны быть доступны нескольким дочерним компонентам, то управление ими должно осуществляться на уровне родительского компонента. Проблема с этим ограничением возникает в том случае, когда родитель должен передать данные не дочернему, а внучатому или другому глубоко вложенному компоненту в дереве иерархии. Именно в этом случае на помощь приходит паттерн <i>инъекции зависимостей</i>. Vue реализует его естественным образом с помощью функций <b>Provide</b> и <b>Inject</b>, которые мы более подробно рассмотрим в следующем разделе.</p>
			<h3>Инъекция зависимости с помощью Provide и Inject</h3>
			<p>Когда данные в родительском компоненте должны быть доступны в глубоко вложенном дочернем, используя только props, нам придется "передавать" данные между компонентами, даже если они не нуждаются в них или не используют их. Эта проблема называется <i>props drilling</i>. То же самое происходит и с событиями, идущими в обратном направлении, - им приходится "пузыриться" вверх. Для решения этой проблемы Vue предлагает реализацию паттерна инъекции зависимостей с помощью двух функций <b>Provide</b> и <b>Inject</b>. С их помощью родительский или корневой компонент <i>предоставляет</i> данные (в виде значения или ссылки, например, объекта), которые могут быть <i>инжектированы</i> в любой из его дочерних компонентов, расположенных ниже по иерархическому дереву. Визуально мы можем представить эту ситуацию следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_4.04_B18602.jpg" alt="Рисунок 4.4 - Представление Provide/Inject" width="481" height="157">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 4.4 - Представление Provide/Inject</p>
			<p>Как видите, процесс очень прост, как и синтаксис для реализации паттерна:</p>
			<ol>
				<li>В родительском (корневом) компоненте мы импортируем функцию <b>provide</b> из Vue и создаем provision с ключом (именем) и данными для передачи:<pre class="console">import {provide} from "vue"
provide("provision_key_name", data)</pre></li>
				<li>В компоненте-получателе мы импортируем функцию <b>inject</b> и получаем данные по ключу (имени):<pre class="console"><b>import {</b><b>inject</b><b>} from "vue"</b>.
<b>const $received_data = </b><b>inject</b><b>("</b><b>provision_key_name"</b><b>)</b></pre></li>.
			</ol>
			<p>Мы также можем предоставить ресурс на уровне приложения следующим образом:</p>
			<pre class="source-code">const app = createApp({})
<b>app.provide(</b>'provision_key_name', data_or_value<b>)</b></pre>
			<p>Таким образом, провизия может быть внедрена в любой компонент нашего приложения. Стоит отметить, что мы можем предоставлять и сложные типы данных, такие как массивы, объекты и реактивные переменные. В следующем примере мы предоставляем объект с функциями и ссылками на родительские методы:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">В родительском/корневом компоненте</p>
			<pre class="source-code">import {provide} from "vue"
function logMessage(){console.log("Hi")}
const _provision_data={<b>runLog</b>: logMessage}
provide("имя_сервиса", _provision_data)</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">В дочернем компоненте</p>
			<pre class="source-code">import {inject} from "vue"
const $service = inject("имя_сервиса")
$service.<b>runLog</b>()</pre>
			<p>В данном примере мы фактически предоставили <b>интерфейс прикладного программирования</b> (<b>API</b>) через объект в рамках всей системы. Хорошей практикой при именовании "ключа предоставления" (имени сервиса) является соблюдение соглашения, которое будет понятно всей команде и позволит определить функциональность, контекст и, возможно, источник предоставляемого сервиса, а также избежать возможных коллизий. Например, инжектируемый сервис с именем <b>Admin.Users.Individual.Profile</b> является более описательным, чем <b>user_data</b>. Определять соглашение об именовании должна команда и разработчик (именование типа "путь" является лишь предложением, а не стандартом). Как уже упоминалось в этой книге, после того как вы определились с соглашением, главное, чтобы оно было последовательным во всем исходном коде. Позже в этой главе мы используем этот метод для создания плагина для отображения модальных диалогов, но перед этим нам необходимо ознакомиться с еще несколькими понятиями, касающимися специальных компонентов и шаблонов.</p> <h>Специальные компоненты</h>.
			<h2>Специальные компоненты</h2>
			<p>Иерархия компонентов очень мощная, но имеет свои ограничения. Мы видели, как можно применить паттерн инъекции зависимостей для решения одной из них, но есть и другие случаи, когда нам требуется немного больше гибкости, возможности повторного использования или мощности для совместного использования кода или шаблонов, или даже перемещения компонента, который рендерится вне иерархии.</p> <h>Специальные компоненты
			<h3>Слоты, слоты и еще раз слоты...</h3>
			<p>Используя реквизиты, наш компонент может получать данные JavaScript. С помощью аналогов можно также передавать фрагменты шаблона (HTML, JSX и т.д.) в определенные части шаблона компонента, используя для этого заполнители, называемые <b>слотами</b>. Как и реквизиты, они принимают несколько типов синтаксиса. Начнем с самого простого: слот <i>default</i></span><span class="No-Break">.</p> <p>Предположим, что в шаблоне компонента используется <b>слот</b>.
			<p>Допустим, у нас есть компонент с именем <b>MyMenuBar</b>, который выступает в качестве заполнителя верхнего меню. Мы хотим, чтобы родительский компонент заполнял опции так же, как мы используем обычные HTML-теги, такие как <b>header</b> или <b>div</b>, например так:</p>.
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Родительский компонент</p>
			<pre class="source-code">&lt;MyMenuBar&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<b>&lt;button&gt;Option 1&lt;/button&gt;</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>&lt;button&gt;Option 2&lt;/button&gt;</b>
&lt;/MyMenuBar&gt;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Компонент MyMenuBar</p>.
			<pre class="source-code">&lt;template&gt;
&lt;div class="..."&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<b>&lt;slot&gt;&lt;/slot&gt;</b>
&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>При условии, что мы применили необходимые стили и классы в <b>MyMenuBar</b>, конечный рендер шаблона может выглядеть примерно так:</p>
			<div>
				<div>
					<img src="images/Figure_4.05_B18602.jpg" alt="Рисунок 4.5 - Строка меню с использованием слотов" width="209" height="43">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 4.5 - Строка меню с использованием слотов</p>.
			<p>Применяемая логика достаточно проста. Заполнитель <b>&lt;slot&gt;&lt;/slot&gt;</b> во время выполнения программы будет заменен на содержимое, предоставленное родительским компонентом внутри дочерних тегов. В предыдущем примере, если проанализировать конечный HTML, можно обнаружить примерно следующее (учитывая, что мы используем классы <b>W3.css</b></span><span class="No-Break">):</p>
			<pre class="source-code">&lt;div class="w3-bar w3-border w3-light-grey"&gt;
&nbsp;&nbsp;&lt;button&gt;Вариант 1&lt;/button&gt;
&nbsp;&nbsp;&lt;button&gt;Вариант 2&lt;/button&gt;
&lt;/div&gt;</pre>
			<p>Это фундаментальная концепция проектирования пользовательского интерфейса. А что, если нам нужно несколько "слотов" - например, для создания компонента макета? Здесь на помощь приходит альтернативный синтаксис, называемый <i>именованные слоты</i>. Рассмотрим следующий пример:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Мой компонент макета</p>
			<pre class="source-code">&lt;div class="layout-wrapper"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;section&gt;&lt;slot <b>name="sidebar"</b>&gt;&lt;/slot&gt;&lt;/section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;header&gt;&lt;slot <b>name="header"</b>&gt;&lt;/slot&gt;&lt;/header&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;main&gt;&lt;slot <b>name="content"</b>&gt;&lt;/slot&gt;&lt;/main&gt;
&lt;/div&gt;</pre>
			<p>Как видите, мы присвоили имя каждому слоту с помощью атрибута <i>name</i>. Теперь в родительском компоненте мы должны использовать элемент <b>template</b> с директивой <b>v-slot</b> для доступа к каждому из них. Вот как родительский компонент будет использовать </span><span class="No-Break"><b>MyLayout</b></span><span class="No-Break">:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Родительский компонент</p>
			<pre class="source-code">&lt;MyLayout&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;template <b>v-slot="sidebar"</b>&gt; ... &lt;/template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;template <b>v-slot="header"</b>&gt; ... &lt;/template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;template <b>v-slot="content"</b>&gt; ... &lt;/template&gt;
&lt;/MyLayout&gt;</pre>
			<p>Директива <b>v-slot</b> принимает один аргумент, соответствующий имени слота, с такими замечаниями:</p>
			<ul>
				<li>Если имя не совпадает ни с одним доступным слотом, содержимое не выводится.</li>
				<li>Если имя не указано или используется имя <b>default</b>, то содержимое отображается в безымянном слоте по умолчанию.</li>
				<li>Если для шаблона не указано содержимое, то будут показаны элементы по умолчанию внутри определения слота. Содержимое по умолчанию помещается между тегами слотов: <b>&lt;slot&gt;...default </b><b>содержимое здесь...&lt;/slot&gt;</b></span><span class="No-Break">.</li>.
			</ul>
			<p>Для директивы <b>v-slot</b> также существует сокращенное обозначение. Мы просто префиксируем имя слота цифровым знаком (<b>#</b>). Например, шаблоны в предыдущем родительском компоненте можно упростить следующим образом:</p>
			<pre class="source-code">&lt;template <b>#sidebar</b>&gt; ... &lt;/template&gt;
&lt;template <b>#header</b>&gt; ... &lt;/template&gt;
&lt;template <b>#content</b>&gt; ... &lt;/template&gt;</pre>
			<p>Слоты в Vue 3 очень мощные, вплоть до того, что в них даже предусмотрен способ передачи реквизитов родителю, если это необходимо. Синтаксис различается в зависимости от того, используем ли мы <i>слот по умолчанию</i> или <i>именованные слоты</i></span><span class="No-Break">.
Например, рассмотрим следующее определение шаблона компонента:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Компонент PassingPropsUpward</p>
			<pre class="source-code">&lt;div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot <b>:data="some_text"</b>&gt;&lt;/data&gt;
&lt;/div&gt;</pre>
			<p>Здесь слот передает родительскому компоненту реквизит с именем <b>data</b>. Родительский компонент может получить к нему доступ с помощью следующего синтаксиса:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Родительский компонент получает реквизит от слота</p>
			<pre class="source-code">&lt;PassingPropsUpward <b>v-slot="upwardProp"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<b>{{upwardProp.data}} </b>/Рендеринг содержимого some_text
&lt;/PassingPropsUpward&gt;</pre>
			<p>В родительском компоненте мы используем директиву <b>v-slot</b> и присваиваем локальное имя реквизиту, передаваемому слотом, - в данном случае <b>upwardProp</b>. В эту переменную будет передан объект, аналогичный по функциям объекту props, но привязанный к элементу. Из-за этого такие слоты называются <i>именованными слотами</i>, и синтаксис их аналогичен. Посмотрите на этот пример:</p>
			<pre class="source-code">&lt;template <b>#header="upwardProp"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{{<b>upwardProp</b>.data}}
&lt;/template&gt;</pre>
			<p>Существуют и другие расширенные возможности использования слотов, которые охватывают крайние случаи, но мы не будем рассматривать их в этой книге. Вместо этого я рекомендую вам более подробно изучить эту тему в официальной документации по адресу </span><a href="https://vuejs.org/guide/components/slots.html"><span class="No-Break">https://vuejs.org/guide/components/slots.html</span></a><span class="No-Break">.</p> <p>
			<p>Еще одно понятие, связанное с этой темой, мы рассмотрим позже в этой книге, в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>главе 7</i></span></a>, <i>Управление потоками данных</i>, которое относится к реактивному централизованному управлению состоянием. Теперь давайте рассмотрим некоторые специальные компоненты, которые ведут себя несколько необычно.</p
			<h3>Компоненты и миксины</h3>
			<p>В Vue 2 специальный компонент <b>mixin</b> позволял обмениваться кодом между компонентами, избегая повторения кода. Такой подход порождал ряд проблем и неприятных побочных эффектов, решение которых привело к созданию API Composition в Vue 3. Использование миксинов по-прежнему поддерживается для обеспечения обратной совместимости, но категорически не рекомендуется. В этой книге мы не будем рассматривать миксины; вместо этого мы сосредоточимся на технологии, которая пришла им на смену и превзошла их: </span><span class="No-Break"><b>composables</b></span><span class="No-Break">.</p>
			<p>Компонуемая</b> функция - это функция, использующая Composition API для инкапсуляции и повторного использования <i>государственной логики</i> между компонентами. Важно отличать композиты от сервисных классов или других инкапсуляций <i>бизнес-логики</i>. Основное назначение композита - совместное использование <i>пользовательского интерфейса или логики взаимодействия с пользователем</i>. В общем случае каждый компонент выполняет следующие действия:</p>
			<ul>
				<li>Открывает функцию, которая возвращает <i>реактивные</i></span><span class="No-Break"> переменные.</li>
				<li>Следует соглашению об именовании с префиксом <b>use</b> в формате <i>camelCase</i> - например, <b>useStore()</b>, <b>useAdmin()</b>, <b>useWindowsEvents()</b>, и так далее.</li>
				<li>Это самостоятельный модуль.</li>
				<li>Обрабатывает <i>государственную логику</i>. Это означает, что она управляет данными, которые сохраняются и изменяются с течением времени.</li>
			</ul>
			<p>Классический пример composable привязывается к событиям окружающей среды (изменение размеров окна, движение мыши, датчики, анимация и т.д.). Реализуем простой композит, который считывает вертикальный скролл документа:</p> <p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">DocumentScroll.js</p>
			<pre class="source-code">import {<b>ref, onMounted, onUnmounted}</b> из "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
function <b>useDocumentScroll</b>(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const y=ref(window.scrollY)</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function update(){<b>y.value=window.scrollY</b>}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onMounted(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener('scroll', update)})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&nbsp;onUnmounted (()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.removeEventListener('scroll', update)})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {y}</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
}
export <b>{useDocumentScroll}</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6</pre>
			<p>В этом небольшом композите мы начинаем с импорта событий жизненного цикла компонента и реактивного конструктора из Vue (<b>//1</b>). Наша главная функция, <b>useDocumentScroll</b>, содержит весь код, которым мы будем делиться и экспортировать позже (<b>//6</b>). В <b>//2</b> мы создаем реактивную константу и инициализируем ее текущим значением вертикальной прокрутки окна. Затем мы создаем внутреннюю функцию <b>update</b>, которая обновляет значение <b>y</b>. Мы добавляем эту функцию в качестве слушателя события прокрутки документа в <b>//3</b>, а затем удаляем ее в <b>//4 </b> (принцип <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>глава 2</i></span></a>, <i>Принципы и паттерны проектирования программного обеспечения</i>, "Clean after yourself"). Наконец, в <b>//5</b> мы возвращаем нашу реактивную константу, обернутую в объект. Затем в компоненте мы используем эту композицию <span class="No-Break">таким образом:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">SomeComponent.js - настройка скрипта</p>
			<pre class="source-code">import {useDocumentScroll} from "./DocumentScroll.js"
const {y}=useDocumentScroll()
...</pre>
			<p>Импортировав реактивную переменную, мы можем использовать ее в коде и шаблоне как обычно. Если нам нужно использовать этот фрагмент логики в нескольких компонентах, достаточно импортировать составной (принцип <b>DRY</b></span><span class="No-Break">).</p>
			<p>Наконец, на сайте <a href="https://vueuse.org/">https://vueuse.org/</a> собрана внушительная коллекция composables для наших проектов.
С ней стоит ознакомиться.</p> <p>
			<h3>Динамические компоненты с помощью "component:is"</h3>
			<p>Фреймворк Vue 3 предоставляет специальный компонент под названием <b>&lt;component&gt;</b>, задача которого заключается в том, чтобы быть держателем для динамического отображения других компонентов. Он работает со специальным атрибутом <b>:is</b>, который может принимать либо <b>строку</b> с именем компонента, либо переменную с определением компонента. Он также принимает некоторые базовые выражения (строка кода, которая преобразуется в значение). Вот простой пример с использованием выражения:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Компонент CoinFlip</p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import <b>Heads </b>from "./heads.vue"
&nbsp;&nbsp;&nbsp;&nbsp;import <b>Tails </b>from "./tails.vue"
&nbsp;&nbsp;&nbsp;&nbsp;function <b>flipCoin</b>(){return Math.random() &gt; 0.5}
&lt;/script&gt;
&lt;Шаблон&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;компонент <b>:is="flipCoin()?Heads:Tails"</b>&gt;&lt;/component&gt;
&lt;/template</pre>
			<p>При выводе этого компонента мы увидим либо компонент <b>Heads</b>, либо компонент <b>Tails</b> в зависимости от результата выполнения функции <b>flipCoin()</b></span><span class="No-Break">.</p>.
			<p>На этом этапе у вас может возникнуть вопрос, почему бы не использовать простой <b>v-show/v-if</b>? Сила этого компонента становится очевидной, когда управление компонентами происходит динамически и мы не знаем, какие из них доступны на момент создания шаблона. Официальный Vue Router, который мы рассмотрим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>главе 5</i></span></a>, <i>Одностраничные приложения</i>, использует этот специальный компонент для имитации <span class="No-Break">страничной навигации.</p>.
			<p>Однако есть один крайний случай, о котором следует знать. Хотя большинство атрибутов шаблона будут передаваться динамическому компоненту, использование некоторых директив, таких как <b>v-model</b>, не будет работать на <i>нативных элементах ввода</i>. Эта ситуация настолько редкая, что мы не будем обсуждать ее подробно, но ее можно найти в официальной документации по адресу </span><a href="https://vuejs.org/api/built-in-special-elements.html#component"><span class="No-Break">https://vuejs.org/api/built-in-special-elements.html#component</span></a><span class="No-Break">.
			<p>Теперь, когда мы получили более глубокое представление о компонентах, давайте применим эти новые знания в двух проектах: плагине и новой версии нашего приложения To-Do.</p> <h>В реальном мире</h>.
			<h2>Реальный пример - плагин модалов</h2>.
			<p>Мы рассмотрели множество подходов к совместному использованию данных и функциональности <i>в рамках</i> проекта. Плагины - это паттерн проектирования, позволяющий обмениваться функциональностью между проектами и одновременно расширять возможности системы. Vue 3 предоставляет очень простой интерфейс для создания плагинов и их подключения к нашему экземпляру приложения. Плагином может стать любой объект, раскрывающий метод <b>install()</b> или функцию, принимающую те же параметры. Подключаемый модуль может выполнять следующие действия:</p>
			<ul>
				<li>Регистрировать глобальные компоненты и директивы</li>
				<li>Регистрация инжектируемого ресурса на уровне приложения</li>
				<li>Создавать и присоединять к приложению новые свойства или методы</li>.
			</ul>
			<p>В этом разделе мы создадим плагин, реализующий модальные диалоги в виде глобальных компонентов. Мы будем использовать инъекцию зависимостей для предоставления их в качестве ресурсов и реактивность Vue для управления ими с помощью обещаний.</p> <p>
			<h3>Настройка нашего проекта</h3>
			<p>Следуйте инструкциям, приведенным в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>главе 3</i></span></a>, <i>Установка рабочего проекта</i>, чтобы у вас была отправная точка. В каталоге <b>src/</b> создайте новую папку <b>plugins/</b> с подпапкой <b>modals/</b>. Это стандартный подход - размещать наши плагины в отдельных каталогах внутри папки <span class="No-Break"><b>plugins/</b></span><span class="No-Break">.</p>
			<h3>Конструкция</h3>
			<p>Наш плагин будет устанавливать компонент глобально и поддерживать внутреннее реактивное состояние для отслеживания текущего состояния модального диалога. Он также предоставит API, который будет инжектироваться как зависимость в те компоненты, которым необходимо открыть модальный диалог. Это взаимодействие можно представить следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_4.06_B18602.jpg" alt="Рисунок 4.6 - Представление модального плагина" width="480" height="177">.
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 4.6 - Представление модального плагина</p>
			<p>Компоненты будут реализовывать модальный элемент, а открывать диалог мы будем с помощью кода. При открытии модального диалога он будет возвращать обещание по шаблону async. Когда пользователь принимает модальное окно, обещание разрешается, а при отмене происходит отказ. Содержимое модального окна будет предоставляться родительским компонентом с помощью слотов.</p> <h3>Реализация.
			<h3>Реализация</h3>
			<p>Для этого плагина нам понадобится всего два файла - один для логики плагина и один для нашего компонента. Создайте файлы <b>index.js</b> и <b>Modal.vue</b> в папке <b>src/plugins/modal</b>. На данный момент достаточно просто набросать компонент с настройкой скрипта, шаблона и стиля раздела. К его завершению мы вернемся позже. С этими файлами давайте начнем пошагово с файла <b>index.js</b></span><span class="No-Break">:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/plugins/modals/index.js</p>
			<pre class="source-code">import { reactive } from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
import Modal from "./Modal.vue"
const
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current = reactive({}),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;api = {},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&nbsp;<b>plugin = {</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;install(App, options) {</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;App.component("Modal", Modal)</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;App.provide("$modals", api)</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>
export default <b>plugin</b></pre>
			<p>В строке <b>//1</b> мы начинаем с импорта конструктора <b>reactive</b> из Vue и компонента <b>Modal </b>, файл которого мы еще не создали. Затем, в строке <b>//2</b>, мы создаем внутреннее свойство состояния <b>_current</b>, а в <b>//3</b> - объект, который будет нашим API. Пока что это лишь условные обозначения. Важный раздел находится в строке <b>//4</b>, где мы определяем функцию <b>install()</b>. Эта функция получает два параметра в следующем порядке:</p>
			<ol>
				<li>Экземпляр приложения (</span><span class="No-Break"><b>App</b></span><span class="No-Break">).</li>
				<li>Объект с опциями, если таковые были переданы в процессе установки.</li>
			</ol>
			<p>В экземпляре приложения мы регистрируем <b>Modal</b> как глобальный компонент и предоставляем API как инжектируемый ресурс под именем <b>$modals,</b> и то и другое на уровне приложения. Чтобы использовать плагин в нашем приложении, мы должны импортировать его в <b>main.js</b> и зарегистрировать с помощью метода <b>use</b>. Код выглядит следующим образом:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/Main.js</p>
			<pre class="source-code">import { createApp } from 'vue'
import App from './App.vue'
<b>import Modals from "./plugins/modals"</b>.
createApp(App)<b>.use(Modals)</b>.mount('#app')</pre>
			<p>Как видите, создать и использовать плагин довольно просто. Однако пока что наш плагин делает не так уж много. Давайте вернемся к коду нашего плагина и доработаем API. Нам нужно следующее:</p>
			<ul>
				<li>Метод <b>show()</b>, который принимает имя, идентифицирующее реализацию модального диалога, и возвращает обещание. Затем мы сохраним это имя и ссылки на функции <b>resolve()</b> и <b>reject()</b> в нашем реактивном состоянии.</li> <li>Метод <b>show()</b>.
				<li>Методы <b>accept()</b> и <b>cancel()</b> для разрешения и отклонения обещания, соответственно.</li>
				<li>Метод <b>active()</b> для получения имени текущего модала.</li>
			</ul>
			<p>Следуя этим рекомендациям, мы можем завершить код так, чтобы наш файл <b>index.js</b> выглядел следующим образом:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/plugins/modals/index.js</p>
			<pre class="source-code">import { reactive } from "vue"
import Modal from "./Modal.vue"
const
_current = reactive({<b>name:"",resolve:null,reject:null</b>}),
api = {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active()</b> {return _current.name;}
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show(name)</b> {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current.name = name;</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Promise(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(resolve = () =&gt; { }, reject = () =&gt; { }) =&gt; {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current.resolve = resolve;</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current.reject = reject;</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>},
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accept()</b> {<b>_current.resolve();_current.name = "" </b>},
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancel()</b> {<b>_current.reject();_current.name = "" </b>}
},
plugin = {...} // Опущено для краткости
export default plugin;</pre>
			<p>Наше внутреннее состояние хранится в переменной <b>reactive</b> и доступно только через наш API. В целом, это хороший дизайн для любого API. Теперь настало время совершить волшебство в нашем компоненте <b>Modal.vue</b>, чтобы завершить рабочий процесс. Для краткости я опускаю классы и стили, но полный код можно найти в репозитории GitHub этой книги по адресу </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></a><span class="No-Break">.</p> <p> <p>Наш модальный компонент - это модальный компонент.
			<p>Наш модальный компонент должен будет выполнять следующие действия:</p>
			<ul>
				<li>Прикрыть всю область просмотра полупрозрачным элементом, чтобы заблокировать взаимодействие с остальной частью приложения</li>.
				<li>Определить отображаемый диалог:</span><ul><li>А <i>prop</i> для регистрации имени компонента, предоставленного <span class="No-Break">родителем.</span></li><li>А <i>header</i> для отображения заголовка. Заголовок также будет <span class="No-Break">реквизитом.</span></span></li><li>Область для заполнения родительского компонента <span class="No-Break">настраиваемым содержимым.</span></span></li><li>Нижний колонтитул с кнопками <i>принять</i> и <span class="No-Break"><i>отменить</i></span><span class="No-Break">.</span></span></li><li>Реактивное свойство, которое срабатывает, когда компонент <span class="No-Break">должен появиться.</li></ul></li>.
			</ul>
			<p>После того как мы определились с определением, давайте поработаем над шаблоном:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/plugins/modals/Modal.vue</p>
			<pre class="source-code">&lt;template&gt;
&lt;div class="viewport-wrapper" <b>v-if="_show"</b>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
&nbsp;&nbsp;&lt;div class="dialog-wrapper"&gt;
&nbsp;&nbsp;&nbsp;&lt;header&gt;<b>{{$props.title}}</b>&lt;/header&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&lt;main&gt;<b>&lt;slot&gt;&lt;/slot&gt;</b>&lt;/main&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&lt;footer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;кнопка <b>@click="closeModal(true)"</b>&gt;Accept&lt;/button&gt;&nbsp;&nbsp;&nbsp;//4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;кнопка <b>@click="closeModal(false)</b>"&gt;Cancel&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;/footer&gt;
&nbsp;&nbsp;&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>В строке <b>//1</b> реактивная переменная <b>_show</b> управляет видимостью модального диалога. В строке <b>//2</b> мы отображаем реквизит <b>title</b>, а в строке <b>//3</b> резервируем слот. Кнопки в строке <b>//4</b> будут закрывать модальный диалог по событию click, каждая из которых имеет представительное булево значение.</p>
			<p>Ну вот и пришло время написать логику работы компонента. В нашем скрипте нам необходимо сделать следующее:</p>
			<ul>
				<li>Определить два реквизита: <b>title</b> (для отображения) и <b>name</b> (для идентификации)</li>.
				<li>Инжектируйте ресурс <b>$modals</b>, чтобы мы могли взаимодействовать с API и выполнять следующие действия:</span><ul><li>Проверка соответствия имени модала текущему компоненту (это "открывает" <span class="No-Break">модальный диалог)</span></li><li>Закрытие модала путем разрешения или отклонения <span class="No-Break">обещания</li></ul></li>.
			</ul>
			<p>Следуя этим указаниям, мы можем завершить настройку <b>скрипта</b></p>.
			<pre class="source-code">&lt;Настройка скрипта&gt;
&nbsp;&nbsp;import { <b>inject</b>, computed } из "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
&nbsp;&nbsp;const
&nbsp;&nbsp;$props = defineProps({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: { type: String, default: "" },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title: { type: String, по умолчанию: "Модальный диалог" }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),
&nbsp;&nbsp;<b>$modals = inject("$modals")</b>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;_show = computed(() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <b>$modals.active() == $props.name</b>
&nbsp;&nbsp;})
&nbsp;&nbsp;function closeModal(accept = false) {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accept?$modals.accept():$modals.cancel()</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
&nbsp;&nbsp;}
&lt;/script&gt;</pre>
			<p>В строке <b>//1</b> мы начинаем с импорта функций <b>inject</b> и <b>computed</b>. В строке <b>//2</b> мы создаем реквизит с разумными значениями по умолчанию. В строке <b>//3</b> мы инжектируем ресурс <b>$modals</b> (зависимость), который мы будем использовать в свойстве computed в строке <b>//4</b> для получения текущего активного модала и сравнения его с компонентом. Наконец, в строке <b>//5</b>, основываясь на нажатии кнопок, мы запускаем разрешение или отклонение обещания.</p>
			<p>Чтобы использовать этот плагин из любого компонента в нашем приложении, необходимо выполнить следующие шаги:</p>
			<ul>
				<li>В <b>шаблоне</b> определите модальный компонент с именем, зарегистрированным в нашем плагине (<b>Modal</b>). Обратите внимание на использование атрибутов props:<pre class="console">&lt;Modal name=<b>"myModal"</b> title="Пример модального компонента"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Здесь есть важное содержание
&lt;/Modal&gt;</pre></li>
				<li>В настройках нашего скрипта инжектируем зависимость следующим кодом:<pre class="console">const $modals = inject("$modals")</pre></li>
				<li>Отобразим модальный компонент по заданному имени с помощью следующего кода:<pre class="console">$modals.show(<b>"myModal"</b>).then(() =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Модал принят.
}, () =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Модал отменен.
})</pre></li>
			</ul>
			<p>На этом мы закончили работу над нашим первым плагином на Vue 3. Давайте применим его в нашем новом приложении "Список дел".</p> <h2>Выполнение плагина в Vue 3.
			<h2>Реализация нашего нового приложения To-Do</h2>.
			<p>В начале этой главы мы рассмотрели дизайн нашего нового приложения "Список дел" и разрезали его на иерархические компоненты (см. <i>Рисунок 4</i></span><i>.1</i>). Для продолжения работы над этим разделом вам понадобится копия исходного кода из репозитория GitHub этой книги (<a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</a>). Поскольку наша кодовая база растет, невозможно подробно рассмотреть каждый фрагмент реализации, поэтому мы сосредоточимся на основных изменениях и конкретных фрагментах кода. В связи с этим рассмотрим изменения по сравнению с предыдущей реализацией, примерно в порядке выполнения файлов. Для начала мы добавили две новые директории в <span class="No-Break">наш проект:</p>
			<ul>
				<li><b>/src/plugins</b>, куда мы поместили наш <b>Modals</b></span><span class="No-Break">плагин.</li>
				<li><b>/src/services</b>, где мы размещаем модули с нашей бизнес-логикой или логикой промежуточного ПО. Здесь мы создали объект сервиса для обработки бизнес-логики нашего списка дел: файл <b>todo.js</b></span><span class="No-Break">.</li>.
			</ul>
			<p>В файле <b>main.js</b> мы импортируем и добавляем наш плагин в объект приложения, используя метод <b>.use(Modals)</b> для регистрации нашего плагина.</p>
			<p>Файл <b>App.vue</b> стал в первую очередь компонентом верстки, без какой-либо другой логики приложения. Мы импортируем и используем заголовок <b>(MainHeader.vue)</b> и родительский компонент для управления списком дел и пользовательским интерфейсом (<b>ToDoProject.vue)</b>, как и в дизайне, показанном на <i>рисунке 4</i></span><span class="No-Break"><i>.2</i></span><span class="No-Break">.</p> <p>Компонент <b>ToDoProject.vue</b> - это родительский компонент для управления списком дел.
			<p>Компонент <b>ToDoProject</b> содержит состояние списка через реактивные переменные, где мы имеем следующее:</p>
			<ul>
				<li><b>_items</b> - массив, содержащий наши пункты To-Do</li>.
				<li><b>_item</b> - это вспомогательная реактивная переменная, которую мы используем для создания новых элементов или редактирования дубликата элемента</li>.
				<li><b>_filter</b> - еще одна вспомогательная реактивная переменная, которая используется для ввода строки для фильтрации нашего списка</li>.
			</ul>
			<p>Следует отметить, что мы также объявляем константу <b>$modals</b>, которая принимает инжектированный API объекта <b>Modals</b>. Обратите внимание, как функция <b>showModal()</b> открывает и управляет результатом диалога для новых и редактируемых элементов с помощью этого объекта. После этого в шаблоне появляется соответствующий модал, по окончании помеченный комментарием. Обычно все модальные шаблоны располагаются в конце компонента, а не разбросаны по всему шаблону.</p>
			<p>Компонент <b>ToDoProject</b> делегирует данные о состоянии через реквизиты дочерним компонентам для отображения элементов сводки и списка. Он также получает от них события с инструкциями по работе со списком. Этот компонент можно рассматривать как <i>корень</i> функциональности. В нашем приложении он всего один, но это уже намекает на то, как веб-приложение начинает организовываться по функциональному признаку.</p> <p>Теперь мы можем говорить о том, что в веб-приложении есть корень.
			<p>Еще один момент, о котором стоит упомянуть, - это использование <i>сервисных объектов и классов</i>. В нашем приложении есть <b>todo.js</b>, который мы импортируем как <b>todoService</b> там, где это необходимо. В данном случае это <i>синглтон</i>, но это может быть и конструктор класса. <i>Обратите внимание, что он не содержит никакой интерфейсной логики, только прикладную или бизнес-логику</i>. Это является определяющим фактором, отличающим его от <i>компонентов</i>, с которыми мы уже сталкивались ранее.</p> <p>Другое изменение: <i>Конструктор класса</i>.
			<p>Еще одно изменение заключается в том, что теперь пункты To-Do имеют несколько состояний, и мы можем переходить от одного состояния к другому одним щелчком мыши. Мы реализовали эту логику в функции <b>toggleStatus()</b> сервиса, <i>не в компоненте</i>. Переход между состояниями можно представить следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_4.07_B18602.jpg" alt="Рисунок 4.7 - Циклический конечный автомат состояний" width="480" height="205">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 4.7 - Круговой конечный автомат</p>.
			<p>Вы можете узнать эту конструкцию, поскольку она представляет собой <b>круговой конечный автомат состояния</b>. <i>Конечные автоматы состояний</i> очень удобны для представления возможных состояний элемента и условий, вызывающих каждое изменение (в нашем случае - щелчок пользователя). Существует множество способов реализации машины состояний, но одним из самых простых является оператор <b>switch</b>, как в нашем примере:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Todo.js</p>
			<pre class="source-code">[function] toggleStatus(status){
&nbsp;&nbsp;&nbsp;&nbsp;switch(status){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "not_started":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "in_progress"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "in_progress":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "completed"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "completed":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "not_started"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
			<p>Эта функция, учитывая текущий статус, вернет следующий. Вызывая эту функцию при каждом щелчке мыши, мы можем обновлять состояние каждого элемента в чистом виде.</p> <p>
			<p>Последним моментом, который следует отметить в этой новой реализации, является использование вычисляемых свойств в компоненте <b>ToDoSummary</b>. С их помощью мы выводим на экран сводные карточки с различными состояниями наших элементов. Обратите внимание, как хорошо работает реактивность - как только мы изменяем состояние элемента в списке, сводка немедленно обновляется!</p> <p>
			<p>После того как новая реализация приведена в порядок, пришло время сделать шаг назад и взглянуть на нашу работу с критическим умом.</p>
			<h2>Небольшая критика нашего нового приложения To-Do</h2>
			<p>Новая версия приложения To-Do - это явное улучшение по сравнению с нашим первым подходом, но ее можно усовершенствовать:</p>
			<ul>
				<li>У нас по-прежнему только один список задач.</li>
				<li>Все по-прежнему происходит на одной странице.</li>
				<li>Наши элементы эфемерны. Они исчезают, когда мы закрываем или обновляем браузер.</li>
				<li>Нет никакой безопасности, нет возможности иметь несколько пользователей и т.д.</li>
				<li>Мы можем добавлять только обычный текст. А как насчет изображений или насыщенного текста?
				<li>После некоторой работы мы могли бы расширить наше приложение, чтобы оно управляло несколькими проектами, дополнительным контентом, заданиями и т.д.</li>.
				<li>Мы добились хороших результатов, но нам еще многое предстоит сделать.</li>
			</ul>
			<h2>Обзор</h2>
			<p>В этой главе мы подробно рассмотрели компоненты и узнали, как они могут взаимодействовать, разделять функциональность и реализовывать паттерны проектирования в рамках фреймворка. Мы также рассмотрели подход к преобразованию грубого эскиза или детального проекта в компоненты. Затем мы узнали о специальных компонентах, создали плагин для модальных диалогов с использованием инъекции зависимостей фреймворка и применили другие паттерны, чтобы сделать наше кодирование более простым и конгруэнтным. Кроме того, мы провели рефакторинг нашего приложения и расширили его возможности, взглянув на более эффективное управление состояниями, независимое от HTML-элемента, который мы использовали ранее. Мы добились значительного прогресса, но нам еще есть над чем работать.</p> <p> В следующей главе мы расскажем о том, как мы работаем с приложениями.
			<p>В следующей главе мы создадим <b>одностраничное приложение</b> (<b>SPA</b>) с использованием того, чему мы научились за это время.</p>
			<h2>Вопросы для обзора</h2>
			<p>Ответьте на следующие вопросы, чтобы проверить свои знания по этой главе:</p>
			<ul>
				<li>Как мы можем начать с визуального дизайна или прототипа и спланировать реализацию с помощью компонентов?</li>
				<li>Какими способами компоненты могут взаимодействовать друг с другом?</li>
				<li>Как мы можем повторно использовать код в нескольких компонентах? Есть ли другой способ? </li>
				<li>Что такое плагин и как его создать?</li>
				<li>Какие паттерны мы применили к новому приложению To-Do?</li>
				<li>Что бы вы изменили в реализации? </li>
			</ul>
		</div>
	</div></div>