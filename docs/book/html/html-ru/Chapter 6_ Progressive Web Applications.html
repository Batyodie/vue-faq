			<h1>Прогрессивные веб-приложения</h>
			<p>В этой главе мы познакомимся со следующим шагом эволюции веб-приложений: <b>прогрессивные веб-приложения</b> (<b>PWA</b>). Этот термин может показаться недостаточно описательным, но он относится к группе технологий, которые создают общую концепцию и могут быть реализованы постепенно или частично. Основная идея заключается в том, чтобы вывести веб-приложение из контекста браузера и реализовать его на любом типе устройства, чтобы оно действовало и вело себя максимально похоже на нативное приложение. Это достигается за счет внедрения новых API в браузерные движки, а также интеграции с наиболее популярными операционными системами для настольных и мобильных устройств. Отправной точкой для PWA, конечно же, является <b>одностраничное </b><b>приложение</b></span><span class="No-Break"> (</span><span class="No-Break"><b>SPA</b></span><span class="No-Break">).</p> <p>В конце статьи мы рассмотрим, что такое PWA.
			<p>К концу этой главы мы узнаем следующее:</p>
			<ul>
				<li>Что превращает SPA в PWA, и какие технологии при этом используются</li>.
				<li>Как вручную реализовать отзывчивый SPA, файл манифеста, рабочие службы, автономное хранилище и так далее</li>
				<li>Что такое <i>работники сервисов </i><i> </i></span><span class="No-Break">и какие они бывают</li>.
				<li>Как использовать плагины Vite для автоматизации создания PWA</li>
				<li>Как проверить готовность приложения с помощью <i>Google Lighthouse</i></li>.
			</ul>
			<p>Из предыдущего списка мы сосредоточимся на изучении "строительных лесов" для нескольких технологий, закладывающих основу для их последующего использования, подробно реализованного в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>главе 7</i></span></a>, <i>Управление потоками данных</i>, и <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><i>главе 8</i></span></a>, <i>Многопоточность с Web Workers</i>. К концу этих глав вы будете знать, как создавать PWA, которые эффективно используют современные вычислительные мощности, делая их отзывчивыми, надежными, <span class="No-Break">и производительными.</p
			<h2>Технические требования</h2>
			<p>Для работы с этой главой вам понадобятся примеры кода, расположенные в репозитории по адресу <a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06</a>. Текстовых примеров кода в этом разделе может быть недостаточно для создания работающего примера без дополнительного кода из репозитория.</p> <p>
			<p>Посмотрите следующее видео, чтобы увидеть код в действии: </span><a href="https://packt.link/SBZys"><span class="No-Break">https://packt.link/SBZys</a></p>.
			<h2>PWA или устанавливаемые SPA</h2>
			<p>PWA - это не отдельная настройка или технология, а систематическое усовершенствование веб-приложения для соблюдения определенных условий, будь то <b>многостраничное приложение</b> (<b>MPA</b>) или SPA. Однако по-настоящему они проявляются и оживают, когда эти технологии применяются к SPA, давая нам мощные приложения, которые стирают грань между онлайном и оффлайном, настольными и веб-приложениями. Термин <b>прогрессивный</b>, используемый здесь, имеет тот же оттенок, который мы обсуждали ранее применительно к фреймворку Vue, - постепенное применение веб-технологий.</p> <p>PWA - это то, что нужно для создания новых приложений.
			<p>PWA как-то по-особому воспринимаются браузерами и операционными системами. Они могут устанавливаться рядом с "родными" или настольными приложениями и управлять сетевыми коммуникациями (отправлять, получать, кэшировать файлы и даже получать push-уведомления с сервера). Здесь важно отметить, что речь идет уже не только о настольных компьютерах, но и о мобильных устройствах, таких как планшеты и телефоны, а также о различных операционных системах. Именно в связи с такой многоплатформенностью, если предполагается охватить базу пользователей на различных устройствах, необходимо уделить особое внимание использованию специальных правил CSS для адаптации пользовательского интерфейса к различным размерам (так называемые <b>резонансные приложения</b>), различных иконок и цветов для согласования с локальными настройками пользователя на уровне операционной системы (например, светлый и темный режимы) и т.д. Кроме того, PWA имеют возможность (как и SPA) хранить контент для автономного использования и, надеюсь, должны предоставлять определенную функциональность для автономного использования. Для выполнения всего этого, как минимум, PWA должен соответствовать следующим требованиям:</p>
			<ul>
				<li>Веб-приложение должно обслуживаться через защищенное соединение (HTTPS).</li>
				<li>Приложение должно предоставлять файл манифеста.</li>
				<li>Приложение должно предоставить и установить рабочий сервис.</li>
			</ul>
			<p>При выполнении всех этих условий браузер или операционная система могут предложить пользователю "установить" приложение. Если пользователь соглашается, то с помощью файла манифеста настраивается внешний вид приложения в соответствии с локальной операционной системой (значки, названия, цвета и т.д.), и оно появляется рядом с другими приложениями в системе. При запуске оно будет открываться в собственном окне (если оно выбрано) вне рамок веб-браузера, как и обычное "родное" приложение. Внутри приложение по-прежнему будет работать на движке браузера с использованием веб-технологий, но предполагается, что это будет прозрачно для пользователя, обеспечивая лучшее из двух миров. Есть вероятность того, что пользователь, сам того не зная, использует PWA вместо обычных приложений. Успешными примерами такого подхода являются Starbucks, Trivago и Tinder (</span><a href="https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0"><span class="No-Break">https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0</span></a><span class="No-Break">)</p>.
			<p>Это создает целый ряд преимуществ, которые перекрывают сложности создания веб-приложения под различные сценарии установки:</p>
			<ul>
				<li>Единая кодовая база для установки приложения на различные устройства (настольные, мобильные, ...) и операционные системы (Windows, Linux, macOS, Android, iOS и так далее)</li>
				<li>Поддерживают push-уведомления с сервера, ручную обработку кэширования, автономное использование и так далее</li>.
				<li>Они интегрируются с локальной операционной системой</li>
				<li>Обновления прозрачны для пользователя и происходят гораздо быстрее, чем в традиционном приложении
(в большинстве случаев)</li>
				<li>Разработка PWA требует гораздо меньших затрат, чем создание аналогичных целевых индивидуальных приложений для каждой платформы</li>.
				<li>Вы можете использовать все доступные веб-технологии, фреймворки и библиотеки</li>
				<li>Могут индексироваться поисковыми системами, а их распространение и установка не зависят от проприетарных магазинов приложений</li> <li>Отзывчивые приложения</li>.
				<li>Отзывчивые, безопасные и быстрые, ими можно поделиться с помощью одной лишь ссылки</li>
				<li>Вы можете обращаться к локальным устройствам с помощью стандартных веб-интерфейсов API, например к локальной файловой системе и USB-устройствам, использовать аппаратное ускорение графики и т.д.</li> <li>Вы можете работать с локальными устройствами с помощью стандартных веб-интерфейсов API.
				<li>Некоторые фирменные магазины приложений позволяют переупаковывать PWA и распространять его как обычное приложение (Microsoft Store, Amazon Store, Android Store и др.)</li>
			</ul>
			<p>Есть и другие преимущества, но этих, пожалуй, достаточно, чтобы привести их в качестве аргумента. Кроме того, в SPA проще добавить необходимые элементы, чтобы превратить его в PWA. В результате PWA могут показаться "серебряной пулей" среди приложений, однако следует учитывать и некоторые недостатки:</p> <p>.
			<ul>
				<li>Производительность PWA хороша, но в некоторых конкретных сценариях она всегда будет отставать от "родного" приложения. То же самое может произойти и на устаревшем оборудовании - они будут работать, но производительность может пострадать.</li>
				<li>Устройства Apple немного отстают в освоении некоторых веб-технологий или специально ограничивают их применение для PWA (например, серверные push-уведомления).</li>
				<li>Необходимо приложить немного больше усилий, чтобы охватить различные сценарии работы пользователей на разных устройствах (но немного больше, чем для обычного отзывчивого веб-приложения).</li>
				<li>Некоторые магазины приложений не допускают PWA (в частности, на момент написания статьи это Apple App Store). Кроме того, приложение не получит выгоды от экспозиции и <i>пешеходного трафика</i> из магазина приложений.</li> <li> </li>
			</ul>
			<p>В целом, преимущества значительно перевешивают недостатки. По мере развития веб-технологий PWA будут получать все больше преимуществ и становиться все более распространенными. Теперь, имея более полное представление о том, что такое PWA и что он может делать, давайте модернизируем наши SPA в PWA.</p
			<h2>Увеличение SPA до уровня PWA</h2>.
			<p>Первое требование, о котором уже говорилось, - это обслуживание приложения по защищенному соединению. Как это сделать, установив на сервере бесплатный SSL-сертификат с помощью <b>Let's Encrypt</b>, мы рассмотрим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_10.xhtml#_idTextAnchor224"><i>главе 10</i></span></a>, <i>Развертывание приложения</i>. Учитывая это, давайте посмотрим, как выполнить <span class="No-Break">другие требования.</p>
			<h3>Файл манифеста</h3>
			<p>Добавление файла манифеста - это отправная точка для превращения нашего приложения в PWA. Это не что иное, как J<a id="_idTextAnchor155"></a>SON-файл с известными полями, которые указывают браузеру или операционной системе, как приложение должно быть установлено на настольном или мобильном устройстве. Этот файл должен быть связан в секции <b>head</b> нашего файла <b>index.html</b>, и хотя он может иметь произвольное название, принято использовать имя <b>manifest.json</b> или <b>app.webmanifest</b>. Официальная спецификация предлагает расширение <b>.webmanifest</b>, но при этом уточняет, что имя не имеет особого значения, если файл принимается правильно с типом <b>application/manifest+json - </b><b>Multipurpose Internet Mail Extensions</b> (<b>MIME</b>) (см. <a href="https://www.w3.org/TR/appmanifest/">https://www.w3.org/TR/appmanifest/</a>, раздел <i>§1.1.2</i>).  В наших примерах кода мы будем использовать имя <b>manifest.json</b> для простоты:</p>
			<pre class="source-code">&lt;link rel="<b>manifest</b>" href="<b>/manifest.json"</b>&gt;</pre>.
			<p>Заметим из предыдущего кода, что файл размещается в корне нашего приложения, а атрибут <b>rel</b> должен быть <b>manifest</b>. Атрибуты полей в нашем файле манифеста могут располагаться в любом порядке, и все они считаются <i>o<a id="_idTextAnchor156"></a> опциональными</i> согласно вышеупомянутой спецификации. Однако некоторые платформы все же предполагают минимальный набор атрибутов, который мы будем считать <i>необходимым</i>. Обычная практика также требует наличия других атрибутов<a id="_idTextAnchor157"></a>, которые мы будем относить к <i>рекомендуемым</i>, и, наконец, некоторые атрибуты в спецификации часто используются в магазинах приложений, социальных сетях и т.д. для представления или описания приложения, поэтому мы будем относить их к <i>описательным</i> полям. Эта классификация не является частью спецификации, но может быть полезна при реализации. Вот список наиболее распространенных и полезных атрибутов:</p>
			<table id="table001-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Классификация</p>
						</td>
						<td class="No-Table-Style">
							<p>Атрибут</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="2">
							<p>Необходимо</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>короткое_имя</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Короткое имя, используемое в тех случаях, когда не хватает места для отображения полного имени приложения. В мобильных устройствах часто используется для названия значка.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>имя</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Полное имя приложения.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>иконки</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Массив объектов, каждый из которых представляет собой отдельную иконку, используемую в различных контекстах. Каждый объект имеет как минимум два атрибута:</p>
							<ul>
								<li><b>src</b>: путь к изображению</li>.
								<li><b>sizes</b>: Строка с размерами изображения</li>.
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>start_url</b></p>
						</td>
						<td class="No-Table-Style">
							<p> URL-адрес, с которого должно стартовать приложение, заданный разработчиком.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>дисплей</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Строка, представляющая способ представления приложения:</p>
							<ul>
								<li><b>fullscreen</b>: В полноэкранном режиме, но с отображением пользовательского интерфейса браузера.</li>
								<li><b>standalone</b>: Аналогично <b>fullscreen</b>, но без элементов управления браузера. На рабочем столе элементы управления windows все равно будут отображаться.</li>
								<li><b>minimal-ui</b>: Как <b>standalone</b>, но с базовой навигацией для перемещения вперед и назад, печати, обмена и т.д.</li>.
								<li><b>browser</b>: Приложение открыто в браузере по умолчанию.</li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="2">
							<p>Рекомендуется</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>цвет_темы</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Строка, представляющая собой цвет CSS для приложения. ОС сама решает, как использовать это значение (обычно оно применяется в строке заголовка окна).</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>цвет_фона</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Строка, представляющая цвет фона приложения при его запуске и до применения стилей приложения.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>ориентация</b></p>
						</td>
						<td class="No-Table-Style">
							<p>В основном используется в мобильных устройствах и определяет ориентацию, которую должно использовать приложение - например, <b>ландшафтная, портретная, любая</b> и т.д.</p>.
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>lang</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Строка, определяющая основной язык приложения.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="2">
							<p>Описательный</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>короткие пути</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Это массив объектов, определяющих пункты прямого меню для тесной интеграции с операционной системой. Обычно они появляются в контекстном меню, например, когда пользователь щелкает правой кнопкой мыши на значке приложения. Каждый объект ярлыка должен содержать как минимум <b>имя</b> и <b>URL</b>, а также - опционально - <b>описание</b> и массив <b>иконок</b></span><span class="No-Break">.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>описание</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Строка с кратким описанием приложения.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>скриншоты</b></p>.
						</td>
						<td class="No-Table-Style">
							<p>Массив объектов, содержащий следующие поля:</p>
							<ul>
								<li><b>src</b>: URL-адрес изображения</li>
								<li><b>type</b>: MIME-тип изображения</li>
								<li><b>sizes</b>: Строка с размерами изображения</li>.
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Таблица 6.1 - Поля манифеста</p>.
			<p>На практике я бы рекомендовал заполнять необходимые и рекомендуемые поля для каждого PWA, а описательные поля использовать по мере необходимости, исходя из контекста приложения. Кроме того, следует изучить целевые платформы на предмет наличия дополнительных поддерживаемых полей, которые не входят в стандартную спецификацию.</p> <p>
			<p>Следуя предыдущей таблице, приведем пример файла <b>manifest.json</b></span><span class="No-Break">:</p>
			<pre class="source-code">{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "short_name": "Пример PWA",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "name": "Глава 6: Пример прогрессивного веб-приложения",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "start_url":"/",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "display": "standalone",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "theme_color": "#2979FF",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "background_color": "#000",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "orientation": "portrait"
}</pre>
			<p>Как видите, создание файла манифеста не требует особых дополнительных усилий и является простым дополнением к нашему SPA.</p>
			<h3>Тестирование манифеста</h3>
			<p>После того как вы создали файл манифеста и связали его с файлом <b>index.html</b>, вы можете использовать инструменты разработчика в браузере, чтобы проверить, правильно ли он загрузился. Например, в браузере Google Chrome в меню <b>Application</b> мы видим, что файл примера загрузился правильно:</p> <div> <div> <div>"Манифест"</b>.
			<div>
				<div>
					<img src="images/Figure_6.01_B18602.jpg" alt="Рисунок 6.1 - Инструменты разработчика в Google Chrome, показывающий файл манифеста" width="1098" height="488">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.1 - Инструменты разработчика в Google Chrome, показывающие файл манифеста</p>.
			<p>Но есть еще одна тема, связанная с установкой приложения, которую мы должны рассмотреть: когда и как пользователь узнает, что веб-приложение может быть установлено? Здесь на помощь приходит <i>Install prompt</i>, который мы рассмотрим далее.</p>
			<h3>Подсказка к установке</h3>
			<p>Каждая платформа (мобильная или настольная) имеет свой собственный метод определения того, когда PWA, удовлетворяющее критериям установки, может быть установлено. Он может включать уведомление о том, что пользователь должен согласиться на установку через определенное время, или предоставлять только пользовательский интерфейс для этого. На мобильных устройствах установленный PWA будет размещен на главном экране рядом с другими собственными приложениями, а на настольных компьютерах он может быть размещен внутри браузера и/или в главном меню. Кроме того, в мобильных операционных системах, таких как Android, автоматически создается заставка с указанными в манифесте темой, цветами фона и иконкой приложения. Независимо от того, как и когда PWA может быть установлено, важно знать, что это может быть сделано только с согласия и по инициативе пользователя. Мы не можем запустить установку автоматически из кода без согласия пользователя.</p> <p>Основной поток установки PWA - это установка из кода.
			<p>Основной процесс установки выглядит следующим образом:</p>
			<ol>
				<li>Когда платформа обнаруживает, что наше приложение может быть установлено, она запускает событие в объекте окна под названием <b>beforeinstallprompt</b>. Мы можем кэшировать это событие, чтобы позже вызвать подсказку из нашего приложения.</li> <li>Пользователь инициирует установку.
				<li>Пользователь инициирует установку либо через пользовательский интерфейс платформы, либо через наш метод, предоставляемый PWA (например, кнопку).</li>
				<li>Платформа предложит пользователю принять или отклонить установку.</li>
				<li>Если пользователь соглашается, он устанавливает PWA и запускает другое событие с именем </span><span class="No-Break"><b>appinstalled</b></span><span class="No-Break">.</li>
			</ol>
			<p>Это достаточно простой рабочий процесс. Однако событие <b>beforeinstallprompt</b> срабатывает только один раз, поэтому, если пользователь отказывается от установки, нам необходимо дождаться повторного срабатывания этого события в браузере.</p> <p> Теперь
			<p>Теперь<a id="_idTextAnchor162"></a>, когда мы поняли, как все будет работать, пришло время посмотреть на это в коде. Рассмотрим, что в шаблоне нашего компонента Vue 3 есть следующие элементы:</p> <p>
			<pre class="source-code">&lt;p v-show="<b>_install_ready &amp;&amp; !_app_installed"</b>&gt;
&nbsp;&nbsp;&nbsp;Установите это приложение
&nbsp;&nbsp;&nbsp;&lt;button @click="<b>installPWA()</b>"&gt;Install&lt;/button&gt;
&lt;/p&gt;
&lt;p v-show="<b>_app_installed"</b>&gt;
&nbsp;&nbsp;&nbsp;Прогрессивное веб-приложение установлено
&lt;/p&gt;</pre>
			<p>Как видите, у нас есть два параграфа, которые будут отображаться в зависимости от значения реактивных переменных <b>_install_ready </b> и <b>_app_installed</b>, обе они булевские. Первая появится, когда PWA будет готов к установке, и предоставит кнопку для запуска установки с помощью функции <b>installPWA()</b>. Второй будет отображаться после ее выполнения.</p>
			<p>Наш код в секции скриптов также достаточно прост:</p>
			<pre class="source-code">import { onMounted, ref, onBeforeUnmount } from 'vue'
const
&nbsp;&nbsp;&nbsp;&nbsp;_install_ready=ref(false),
&nbsp;&nbsp;&nbsp;&nbsp;_install_prompt=ref(null),
&nbsp;&nbsp;&nbsp;&nbsp;_app_installed=ref(false)
// Определяем возможность установки PWA
onMounted(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.addEventListener("<b>beforeinstallprompt</b>",savePrompt)
&nbsp;&nbsp;&nbsp;&nbsp;window.addEventListener("<b>appinstalled</b>",handleAppInstalled)})
function savePrompt(event){
&nbsp;&nbsp;&nbsp;&nbsp;event.preventDefault(); // Предотвращает мобильную подсказку
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем ссылку на событие, чтобы активировать его позже
&nbsp;&nbsp;&nbsp;&nbsp;<b>_install_prompt.value=event</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Уведомить пользовательский интерфейс о том, что приложение может быть установлено
&nbsp;&nbsp;&nbsp;&nbsp;_install_ready.value=true;
}
function installPWA(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Запуск приглашения к установке
&nbsp;&nbsp;&nbsp;&nbsp;if(_install_prompt.value){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>_install_prompt.value.prompt()</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}
function handleAppInstalled(){
&nbsp;&nbsp;&nbsp;&nbsp;_install_prompt.value=null;
&nbsp;&nbsp;&nbsp;&nbsp;_app_installed.value=true;
}</pre>
			<p>В предыдущем коде мы регистрируем два слушателя при установке нашего компонента на страницу: один для управления и кэширования запроса на установку, а другой - для определения того, когда приложение было установлено. Некоторые части были опущены для упрощения кода, но полный вариант компонента со стилями можно найти в репозитории GitHub.</p> <p> Хотя в предыдущем коде мы регистрируем два слушателя при установке компонента на страницу, один из них управляет кэшированием подсказки об установке, а другой определяет момент установки приложения.
			<p>Хотя предыдущий пример является довольно упрощенным, существует несколько известных шаблонов для продвижения или представления возможности установки конечному пользователю. Все они основаны на одной и той же логике - перехвате события и последующем pr<a id="_idTextAnchor165"></a>омптировании его при показе триггерного элемента. Реализация тривиальна и имеет больше отношения к дизайну, чем к шаблону кодирования, поэтому мы <a id="_idTextAnchor166"></a> рассмотрим здесь только макеты:</p>.
			<ul>
				<li>Простая кнопка <b>Установить</b> (как в нашем примере приложения):</li>.
			</ul>
			<div>
				<div>
					<img src="images/Figure_6.02_B18602.jpg" alt="Рисунок 6.2 - Простая кнопка установки" width="480" height="106">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.2 - Простая кнопка установки</p>
			<ul>
				<li>Кнопка меню <b>Install</b> размещается в основной навигации:</li>.
			</ul>
			<div>
				<div>
					<img src="images/Figure_6.03_B18602.jpg" alt="Рисунок 6.3 - Кнопка установки главного меню" width="480" height="137">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.3 - Кнопка установки главного меню</p>
			<ul>
				<li>Накладное уведомление:</li>
			</ul>
			<div>
				<div>
					<img src="images/Figure_6.04_B18602.jpg" alt="Рисунок 6.4 - Накладное уведомление" width="480" height="137">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.4 - Накладное уведомление</p>
			<ul>
				<li>Наложенный сверху элемент, например, баннер установки (либо перед заголовком, либо в нижней части области просмотра):</li>
			</ul>
			<div>
				<div>
					<img src="images/Figure_6.05_B18602.jpg" alt="Рисунок 6.5 - Баннер подсказки по установке" width="480" height="137">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.5 - Баннер приглашения к установке</p>
			<p>После того как приложение будет установлено, мы хотим предотвратить постоянный запрос пользователя на установку. В этом случае рекомендуется сохранить флаг автономности в <b>localStorage</b>, cookie на <b>indexeDB,</b> или обозначить стартовый URL нашего приложения в определенном месте. Варианты автономного постоянного хранилища мы <a id="_idTextAnchor167"></a> рассмотрим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>главе 7</i></span></a>, <i>Управление потоками данных</i>. Теперь настало время рассмотреть последний элемент, позволяющий превратить наш SPA в настоящий PWA: <span class="No-Break">рабочие службы.</p>
			<h2>Рабочие службы</h2>
			<p>Рабочий сервис - это JavaScript-сценарий, который выполняется в отдельном потоке, как фоновый процесс для вашего приложения. Он действует как прокси для сети, перехватывая все вызовы и действуя в соответствии с запрограммированной стратегией обслуживания страниц и данных.</p>
			<p>Мы можем иметь несколько рабочих служб, поскольку каждая из них отвечает за свою область видимости. Область видимости определяется как каталог (URL-путь), в котором находится исходный файл для сервисного работника. Таким образом, сервис-рабочий, размещенный в корне приложения, будет работать со всем SPA/PWA.</p> <p>
			<p>Сервисные рабочие устанавливаются без вмешательства пользователя, поэтому их можно использовать, даже если пользователь не установил PWA. Они имеют четко определенный жизненный цикл (см. https://web.dev/service-worker-lifecycle/), инициируя события для каждого завершенного состояния. Для начала сервис-рабочий должен быть сначала <i>зарегистрирован</i>, затем он становится <i>активированным</i>, и, в конце концов, мы можем также <i>снять с регистрации</i> его. После активации сервисного работника он не будет брать на себя управление взаимодействием с приложением до следующего обращения к сайту.</p>
			<p>Самыми распространенными стратегиями программирования сервисного работника являются следующие:</p>
			<ul>
				<li>Обслуживать только кэш</li>
				<li>Обслуживать только сеть</li>
				<li>Попытаться сначала обслужить кэш, а затем вернуться к сети</li>
				<li>Попробуйте сначала обслужить сеть, а затем вернуться к кэшу</li>
				<li>Сначала обслуживать кэш, затем обновлять кэш</li>.
			</ul>
			<p>При рассмотрении стратегий кэширования и автономной работы нам необходимо учитывать, какие файлы и активы, необходимые нашему приложению для работы, будут изменяться мало или вообще не будут изменяться, чтобы кэшировать их. Также необходимо определить маршруты, которые никогда не следует кэшировать.</p>
			<p>Чтобы использовать сервис-рабочий, мы регистрируем его в нашем файле <b>main.js</b> следующими строками:</p>
			<pre class="source-code">if(navigator.serviceWorker){
&nbsp;&nbsp;&nbsp;navigator.serviceWorker.register("/service_worker.js")
}</pre>
			<p>В этих строках мы сначала проверяем, есть ли в текущем браузере возможность использовать сервис-воркеры, и если есть, то регистрируем его. Как мы видим, мы поместили рабочий в корень. Для данного примера мы будем использовать стратегию "кэш - первый, сеть - обратный ход" вручную для всех сетевых вызовов:</p>
			<pre class="source-code"><b>// Устанавливаем стратегию, сначала кэш, потом сеть</b>.
const CACHE_NAME="MyCache"
self.addEventListener("fetch", event=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Перехватывает событие для реагирования</b>
&nbsp;&nbsp;&nbsp;&nbsp;event.respondWith((async ()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Пытается найти запрос в кэше</b>
&nbsp;&nbsp;&nbsp;&nbsp;const found=await caches.match(event.request);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(found){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return found;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Не кэшированный фонт, возвращаемся к сети</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response=await fetch(event.request);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Открываем кэш</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const cache=await caches.open(CACHE_NAME);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Поместить ответ сети в кэш</b>.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.put(event.request, response.clone());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Возврат ответа</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;})())
})</pre>
			<p>Предыдущий код почти дословно основан на примере, приведенном в документации <b>Mozilla Developer Network</b> по адресу <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers">https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers</a>. Комментарии в коде помогут понять логику реализации стратегии. Однако использование базовых API, доступных работнику сервиса, может оказаться громоздким, а то и многословным. Вместо этого удобнее использовать фреймворк или библиотеку для работы с ними и реализации более сложных стратегий. Стандартом сегодня является использование <b>Workbox</b>, созданного <b>Google</b> (https://developer.chrome.com/docs/workbox/). Мы будем использовать его не напрямую, а через плагин для Vite, который мы рассмотрим в следующем разделе.</p> <p>
			<p>После того как мы рассмотрели весь код, наш PWA готов к работе и установке. Если мы запустим пример приложения на сервере разработки, то увидим, что его можно установить. Используя пользовательский интерфейс браузера или нашу кнопку <b>Install</b>, мы получим следующее сообщение:</p>
			<div>
				<div>
					<img src="images/Figure_6.06_B18602.jpg" alt="Рисунок 6.6 - Запрос на установку PWA с localhost" width="758" height="200">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.6 - приглашение к установке PWA с localhost</p>
			<p>Ручная адаптация нашего SPA для превращения его в PWA не является сложной, но требует некоторой ручной работы. Однако с тем выбором инструментов, который у нас есть, мы можем сделать это лучше. Существует более простой способ сгенерировать и внедрить файл манифеста и рабочий сервис в рамках рабочего процесса непосредственно в наш SPA: с помощью плагина Vite.</p> <h>Vite-PWA
			<h2>Плагин Vite-PWA</h2>
			<p>В экосистеме плагинов Vite есть отличный плагин Vite-PWA с нулевой конфигурацией (<a href="https://vite-pwa-org.netlify.app/">https://vite-pwa-org.netlify.app/</a>). Уже из коробки он предоставляет нам отличную функциональность без особых усилий. Мы устанавливаем плагин как зависимость разработчика с помощью следующей команды в терминале:</p>
			<pre class="console">$ npm install --save-dev vite-plugin-pwa</pre>.
			<p>После установки необходимо зарегистрировать его в конфигурации Vite. Измените </span><span class="No-Break"><b>vite.config.js</b>
файл следующим образом:</p>
			<pre class="source-code">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { <b>VitePWA </b>} from 'vite-plugin-pwa'
export default defineConfig({
plugins: [
vue(),
<b>VitePWA</b>({ {
&nbsp;&nbsp;&nbsp;&nbsp;<b>registerType</b>: "autoUpdate",
&nbsp;&nbsp;&nbsp;&nbsp;<b>injectRegister</b>: 'auto',
&nbsp;&nbsp;&nbsp;&nbsp;<b>devOptions</b>: { enabled:true },
&nbsp;&nbsp;&nbsp;&nbsp;<b>рабочий блок</b>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globPatterns: ['**/*.{js,css,html,ico,png,svg}']
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<b>includeAssets</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;['fonts/*.ttf','images/*.png','css/*.css'],
&nbsp;&nbsp;&nbsp;&nbsp;<b>manifest</b>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "short_name": "Пример PWA",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "name": "Глава 6 - Пример прогрессивного веб-приложения",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "start_url": "/",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "display": "standalone",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "theme_color": "#333333",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "background_color": "#000000",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "orientation": "портрет",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "icons": [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "src": "/images/chapter_6_icon_192x192.png",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sizes": "192x192",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "type": "image/png"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "src": "/images/chapter_6_icon.png",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sizes": "512x512",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "type": "image/png"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "src": "/images/chapter_6_icon.png",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sizes": "512x512",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "type": "image/png",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "назначение": "маскируемый"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "prefer_related_applications": false
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;})]
})</pre>
			<p>Используя этот плагин, мы снимаем с бандлера бремя генерации рабочего сервиса и веб-манифеста. Это необходимо, поскольку при каждой промышленной сборке Vite будет генерировать разные имена файлов для каждого скрипта в соответствии с нашей стратегией "ленивой" загрузки компонентов, о которой мы говорили в предыдущей главе.</p> <p> В приведенном примере мы видим, что в результате сборки скриптов Vite будет генерировать разные имена файлов для каждого скрипта.
			<p>В предыдущем примере мы передаем в плагин <b>VitePWA()</b> объект с некоторыми разумными опциями для автоматического создания и внедрения манифеста и рабочего скрипта. Если нам нужен более тонкий контроль над создаваемой стратегией рабочего сервиса, а также над веб-манифестом, то можно использовать плагин в "режиме инъекции" и предоставить базовый файл для нашего рабочего сервиса. В этом случае в скрипт будут инжектироваться сгенерированные в процессе сборки файлы. Внизу плагин использует <b>Workbox</b>, инструмент, о котором мы уже упоминали и который мы можем настраивать непосредственно через поле <b>workbox</b>. Более подробное рассмотрение различных реализаций и стратегий выходит за рамки данной книги, но читателю следует обратиться к документации по плагину <b>Vite-PWA</b> и <b>Workbox</b> для конкретных контекстов и случаев использования.</p> <h>Тестирование</b>.
			<h2>Тестирование показателей PWA с помощью Google Lighthouse</h2>
			<p>В браузерах на основе хрома вместе с инструментами разработчика поставляется утилита Lighthouse, специально предназначенная для тестирования и оценки веб-страниц, а также готовности PWA. Чтобы получить доступ к этому инструменту, после открытия своего приложения в браузере выполните следующие действия:</p> <p> <ol>
			<ol>
				<li>Откройте инструменты разработчика (нажав <i>F12</i> в Windows/Linux, <i>Fn</i> + <i>F12</i> в Mac, или через меню браузера).</li>
				<li>Выберите меню <b>Маяк</b> в правом верхнем углу.</li>
				<li>Выберите <b>Mobile</b> или <b>Desktop</b>, а также убедитесь, что отмечена категория <b>Progressive Web App</b>.</li>
				<li>Нажмите <b>Анализировать загрузку страницы</b> в правом верхнем углу инструмента.</li>
			</ol>
			<p>Инструменты разработчика должны выглядеть примерно так:</p>
			<div>
				<div>
					<img src="images/Figure_6.07_B18602.jpg" alt="Рисунок 6.7 - Утилита "Маяк"" width="921" height="377">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.7 - Утилита "Маяк"</p>.
			<p>Утилита проведет ряд тестов, и в каждой категории будет отображаться рейтинг, а также подробный список элементов, которые прошли или не прошли тест. Если наше приложение не соответствует критериям PWA, то в пунктах, отмеченных красным цветом, будет указано, почему и как это исправить:</p> <p>.
			<div>
				<div>
					<img src="images/Figure_6.08_B18602.jpg" alt="Рисунок 6.8 - Рейтинги примера кода главы 6 в Lighthouse" width="904" height="472">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 6.8 - Оценки примера кода главы 6 в Lighthouse</p>.
			<p>Наш пример кода приложения полностью соответствует требованиям PWA и успешно проходит все тесты. Конечно, этого легче добиться с небольшими приложениями. На практике каждый рейтинг выше 90 является отличным.</p> <p>
			<h2>Обзор</h2>
			<p>В этой главе мы рассмотрели простой SPA и научились превращать его в PWA как вручную, так и с помощью плагина в Vite. Пользователи могут устанавливать PWA на свои платформы наряду с родными приложениями и взаимодействовать с ними, даже если они не подключены к Интернету. PWA обладают множеством преимуществ по сравнению с приложениями, работающими только в Интернете. Мы также рассмотрели, как с помощью Lighthouse можно измерить и оценить наше приложение в нескольких стандартных для отрасли категориях. В этой главе мы закончили рассмотрение поэтапного создания приложений с использованием веб-технологий и впредь будем уделять основное внимание паттернам и моделям для повышения внутренней производительности и эффективности.</p> <h>Вопросы к обзору
			<h2>Вопросы для обзора</h2>
			<p>Для закрепления понятий, изученных в этой главе, ответьте на следующие вопросы:</p>
			<ul>
				<li>В чем разница между SPA и PWA? </li>
				<li>Каковы преимущества PWA? </li>
				<li>Каким основным трем требованиям должно соответствовать веб-приложение, чтобы считаться PWA?</li>
				<li>Какие инструменты можно использовать для постепенной подготовки приложения к работе в качестве PWA? </li>
				<li>Что такое рабочий сервис и каковы некоторые стратегии его использования?</li>
				<li>Что такое веб-манифест и зачем он нужен?</li>
			</ul>
		</div>
	</div></div>