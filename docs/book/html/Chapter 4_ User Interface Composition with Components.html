<h1>User Interface Composition with Components</h1>
<p>In this chapter, we will take a closer look at how to compose user interfaces with components. While we could just create our entire web page with just one component, as we did with our initial <i>To-Do list</i> application in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>Chapter 3</i></span></a>, <i>Setting Up a Working Project</i>, this approach is not a good practice save for simple applications, partial migrations of functionality in existing web applications, or some edge cases when there could be no other option. Components are central to Vue’s approach to <span class="No-Break">building interfaces.</p>
<p>In this chapter, we will do the following:</p>
<ul>
	<li>Learn how to compose user interfaces with a hierarchy of components</li>
	<li>Learn different ways in which components interact and communicate with each other</li>
	<li>Look into special and custom components</li>
	<li>Create an example plugin applying design patterns</li>
	<li>Re-write our to-do application using our plugin and component composition</li>
</ul>
<p>This chapter will introduce core and advanced concepts and give you the tools for building solid web applications with reusable components. In particular, we will apply our knowledge of design patterns from <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a>, <i>Software Design Principles and Patterns</i>, in the implementation of <span class="No-Break">the code.</p>
<h6>A note about styles</h6>
<p class="callout">To avoid lengthy code listings, we will omit sample icons and styles in the code sample. The complete code, along with the styles and iconography, can be found in this book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></a><span class="No-Break">.</p>
<h2>Technical requirements</h2>
<p>The requirements to follow this chapter are the same as previously mentioned in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>Chapter 3</i></span></a>, <i>Setting Up a </i><span class="No-Break"><i>Working Project</i></span><span class="No-Break">.</p>
<p>Check out the following video to see the Code in Action: </span><a href="https://packt.link/eqm4l"><span class="No-Break">https://packt.link/eqm4l</a></p>
<p>The code files of this chapter can be found on GitHub here: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04</a></p>
<h2>Page composition with components</h2>
<p><a id="_idTextAnchor106"></a>To create a user interface, we must have a starting point, be it a crude sketch to a fancy full-fledged design. The graphic design of a web application is beyond the scope of this book, so we will consider that it has been created already. To translate the design into components, we could approach it as a process that answers the following questions:</p>
<ol>
	<li>How can we represent the layout and multiple elements with components?</li>
	<li>How will these components communicate and relate to each other?</li>
	<li>What dynamic elements will enter or leave the scene, and what events or application states will they be triggered by?</li>
	<li>What design patterns can we apply that best serve the use case, considering trade-offs?</li>
</ol>
<p>Vue 3 is specially fit to create dynamic, interactive interfaces. These questions lead us to a repeatable approach for the implementation. So, let’s define a general process with well-defined stages, step by step.</p>
<h3>Step 1 – identify layouts and user interface elements</h3>
<p>This step answers the question: <i>How can we represent the layout and multiple elements </i><i>with components?</i></p>
<p>We will take the page as a whole and consider what layout would work best, given the design. Should we use columns? Sections? Navigation menus? Islands of content? Are there dialogs or modal windows? A simple approach is to take the design image and mark the sections that may represent components with rectangles, from the outermost down to the singular unit of interaction. Iterate over this <i>slicing</i> of the page until you have a comfortable number of components. Considering the new To-Do application design, here is what this step may look like:</p>
<div>
	<div>
		<img src="images/Figure_4.01_B18602.jpg" alt=" Figure 4.1 – A slicing of the design into components with dashed boxes" width="697" height="428">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 4.1 – A slicing of the design into components with dashed boxes</p>
<p>Once we’ve identified the components, we must extract the relationships between them, creating a hierarchy from the topmost root component (usually, this will be our <b>App.vue</b>). New components may appear because of grouping components by context or functionality. This is a good time to name the components. This initial architecture will evolve as we implement design patterns. Following this example, the hierarchy may look something like this:</p>
<div>
	<div>
		<img src="images/Figure_4.02_B18602.jpg" alt="Figure 4.2 – An initial approach to the component’s hierarchy" width="527" height="220">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – An initial approach to the component’s hierarchy</p>
<p>Notice how a new component appeared, <b>ToDoProject.vue</b>, from grouping other components. The <b>App</b> component usually deals with the main layout of the application and the starting point in the hierarchy. Now, with our initial design in place, it is time to move on to the next step.</p>
<h3>Step 2 – identify relationships, the data flow, interactions, and events</h3>
<p>This step answers the question: <i>How will these components communicate and relate to </i><i>each other?</i></p>
<p>In this stage, we need to understand the user’s interaction (with a use case, user story, or something else). For each component, we decide what information it will hold (the state), what will pass down to its children, what it needs from its parent, and what events it will trigger. In Vue, components can only relate vertically to one another. Siblings ignore the existence of each other for the best part. If a sibling component needs to share data with another, that data must be hosted by a common third party who can share it with both, usually the parent who has common visibility. There are other solutions for this, such as reactive state management, which we will cover in detail in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>Chapter 7</i></span></a>, <i>Data Flow Management</i>. For this chapter, we will settle with the basic <span class="No-Break">relationship functionality.</p>
<p>There are many ways to document this information: scribbled notes in the hierarchy tree (see <i>Figure 4</i></span><i>.2</i>), descriptive formal documentation, UML diagrams (<b>UML</b> stands for <b>Universal Modeling Language</b>, an iconography representation of software components), and more. For simplicity, let’s write down only one segment of the tree in a <span class="No-Break">table format:</p>
<table id="table001-2" class="No-Table-Style">
	<colgroup>
		<col>
		<col>
		<col>
	</colgroup>
	<tbody>
		<tr class="No-Table-Style">
			<td class="No-Table-Style">
				<p><b>Component</b></p>
			</td>
			<td class="No-Table-Style">
				<p><b>Function</b></p>
			</td>
			<td class="No-Table-Style">
				<p><b>State, </b><b>I/O, events</b></p>
			</td>
		</tr>
		<tr class="No-Table-Style">
			<td class="No-Table-Style">
				<p>ToDoProject.vue</p>
			</td>
			<td class="No-Table-Style">
				<p>Hosts a list of to-do items and coordinates interaction with the user. This component will actively modify the items.</p>
			</td>
			<td class="No-Table-Style">
				<p>State: The to-do list</p>
				<p>Events: Open new, edit, and delete modals </p>
			</td>
		</tr>
		<tr class="No-Table-Style">
			<td class="No-Table-Style">
				<p>ToDoSummary.vue</p>
			</td>
			<td class="No-Table-Style">
				<p>Displays a summary count of to-do items by state.</p>
			</td>
			<td class="No-Table-Style">
				<p>Input: The list of to-do items</p>
				<p>State: Counters for each item state</p>
			</td>
		</tr>
		<tr class="No-Table-Style">
			<td class="No-Table-Style">
				<p>ToDoFilter.vue</p>
			</td>
			<td class="No-Table-Style">
				<p>Collects a string to filter the list of to-do items.</p>
			</td>
			<td class="No-Table-Style">
				<p>Output: A filter string</p>
				<p>State: An auxiliary variable</p>
			</td>
		</tr>
		<tr class="No-Table-Style">
			<td class="No-Table-Style">
				<p>ToDoList.vue</p>
			</td>
			<td class="No-Table-Style">
				<p>Displays the list of to-do items, and the signal operations for each one.</p>
			</td>
			<td class="No-Table-Style">
				<p>Input: The to-do list, a filter string</p>
				<p>Events: Toggle item state, edit and delete item</p>
			</td>
		</tr>
	</tbody>
</table>
<p>For brevity, I have omitted the components and interactions that will make up the user dialogs.
We will see them later in this chapter, but suffice it to say, it is the responsibility of <b>ToDoProject.vue</b> to manage the interaction using modal dialogs.</p>
<h3>Step 3 – identify user interactivity elements (inputs, dialogs, notifications, and more)</h3>
<p>This step answers the question: <i>What dynamic elements will enter or leave the scene, and what events or application states will they be </i><i>triggered by?</i></p>
<p>In our application, the main CRUD operations (<b>CRUD</b> stands for <b>Create, Read, Update, and Delete</b> data) involve using modal dialogs presented to the user. As previously mentioned, it is the <b>ToDoProject.vue</b> component that controls this interaction as a response to certain events. This process is illustrated in this sequence diagram:</p>
<div>
	<div>
		<img src="images/Figure_4.03_B18602.jpg" alt="Figure 4.3 – User interaction through modals – edit an item" width="460" height="253">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – User interaction through modals – edit an item</p>
<p>In this diagram, the <b>ToDoProject</b> component shares the to-do list with the <b>ToDoList</b> component. When the user triggers the <b>edit</b> event, the child component notifies the parent by raising such an event. The parent then makes a copy of the item and opens a modal dialog, passing said copy. When the dialog is accepted, the parent modifies the original item with the changes. Then, Vue’s reactivity reflects the state change in the child components.</p>
<p>Often, these interactions help us identify the need for additional components that were not evident in <i>Step 1</i>, such as the implementation of design patterns... which is the next step.</p>
<h3>Step 4 – identify design patterns and trade-offs</h3>
<p>This step answers the question: <i>What design patterns can we apply that best serve the use case, </i><i>considering trade-offs?</i></p>
<p>Deciding what patterns to use can be a very creative process. There is no silver bullet, and multiple solutions can provide different results. It is common to make several prototypes to test different approaches.</p>
<p>In our new application, we have introduced the concept of modal dialogs to capture user input. Modal dialogs are used when an operation requires a user action or decision to proceed. The user can accept or reject the dialog, and cannot interact with any other part of the application until such a decision is made. Given these conditions, one possible pattern to apply is the <b>Async </b><b>Promise</b></span><span class="No-Break"> pattern.</p>
<p>In our code, we want to open a modal dialog as a promise that, by definition, will provide us with a <b>resolve()</b>(accept) or <b>reject()</b> (cancel) function. Moreover, we want to be able to use this solution in multiple projects, and globally in our application. We can create a plugin for this purpose, and use the <b>dependency injection pattern</b> to access the modal functionality from any component. These patterns will provide us with the solution we need to make our modal dialog reusable.</p>
<p>At this point, we are almost ready to start implementing the components conceptually. However, to create a more suitable and sturdy application, and implement the aforementioned patterns, we should take a moment to learn more about Vue components.</p>
<h2>Components in depth</h2>
<p>Components are the building blocks of the framework. In <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_01.xhtml#_idTextAnchor017"><i>Chapter 1</i></span></a>, <i>The Vue 3 Framework</i>, we saw how to work with components, declare reactive variables, and more. In this section, we will explore more advanced features <span class="No-Break">and definitions.</p>
<h3>Local and global components</h3>
<p>When we start our Vue 3 application, we mount the main component (<b>App.vue</b>) to an HTML element in the <b>main.js</b> file. After that, in the script section of each component, we can import other components to use locally through this command:</p>
<pre class="source-code">import MyComponent from "./MyComponent.vue"</pre>
<p>In this manner, to use <b>MyComponent</b> in another component, we need to import it again in such a component. If one component is used continuously in multiple components, this repetitive action breaks the development DRY principle (see <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a>, <i>Software Design Principles and Patterns</i>). The alternative is to declare the component as <b>global</b>, by attaching it directly to our Vue application instead of each component. In the <b>main.js</b> file, we can use the <b>App.component()</b> method for this <span class="No-Break">use case:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Main.js</p>
<pre class="source-code">Import { createApp } from "vue"
import App from './App.vue'
<b>Import MyComponent from "./MyComponent.vue"</b>
createApp(App)
&nbsp;&nbsp;&nbsp;&nbsp;<b>.component('MyComponent', MyComponent)</b>
&nbsp;&nbsp;&nbsp;&nbsp;.mount("#app")</pre>
<p>The <b>component()</b> method receives two arguments: a <b>String</b> that represents the HTML tag for the component, and an object with the component definition (either imported or in-lined). After registration, it is available to all the components in our application. There are, however, a few drawbacks to using global components:</p>
<ul>
	<li>The component will be included in the final build, even if never used</li>
	<li>Global registrations obscures the relationship and dependencies between components</li>
	<li>Name collision may occur with locally imported components</li>
</ul>
<p>The recommendation is to globally register only those components that provide generic functionality and avoid those that are an integral part of a workflow or specific context.</p>
<h3>Static, asynchronous, and dynamic imports</h3>
<p>So far, all the components we have imported have been <i>statically</i> defined with the <b>import XYZ from "filename"</b> syntax. Bundlers such as <b>Vite</b> include them in a single JavaScript file. This increases the bundle’s size and could create delays in the startup of our application as the browser needs to download, parse, and execute the bundle and all its dependencies before any user interaction may take place. This code may include features that are seldom used or accessed. The clear alternative to this is to split our bundle file into multiple smaller files and load them as needed. In this case, we have two approaches – one provided by Vue 3 and another one provided by the newest JavaScript syntax for dynamic imports.</p>
<p>Vue 3 provides a function called <b>defineAsyncComponent</b>. This function takes a parameter another function that returns a dynamic import as an argument. Here is an example:</p>
<pre class="console">import {<b>defineAsyncComponent</b>} from "vue"
const MyComponent = <b>defineAsyncComponent</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()=&gt;import("MyComponent.vue")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</pre>
<p>The use of this function makes it safe to use in most bundlers. An alternative to this syntax is used by Vue Router, which we will see in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>Chapter 5</i></span></a>, <i>Single-Page Applications</i>: the <b>import()</b> dynamic declaration provided by JavaScript (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import</a>), This has a very <span class="No-Break">similar syntax:</p>
<pre class="source-code">const MyComponent = () =&gt; import('./MyComponent.vue')</pre>
<p>As you can see, this syntax is more succinct. However, it can only be used when defining routes with Vue Router as, internally, the way that Vue 3 and Vue Router handle lazy loading components is different. In the end, both approaches will split the main bundle file into multiple smaller files that will be automatically loaded when needed in our application.</p>
<p>However, <b>defineAsyncComponent</b> has some advantages. We can also pass any function that returns a promise that resolves to a component. This allows us to implement logic to control the process dynamically at runtime. Here is an example where we have decided to load one component based on the value of an input:</p>
<pre class="source-code">const ExampleComponent=defineAsyncComponent(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(some_input_value_is_true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import OneComponent from "OneComponent.vue"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(OneComponent)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import AnotherComponent from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"AnotherComponent.vue"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(AnotherComponent)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;})
})</pre>
<p>The third syntax for <b>defineAsyncComponent</b> is probably the most useful. We can pass an object with attributes as an argument, which provides more control over the loading operation.
It has these attributes:</p>
<ul>
	<li><b>loader</b> (mandatory): It must provide a function that returns a promise that loads the component</li>
	<li><b>loadingComponent</b>: The component to display while the asynchronous component is loading</li>
	<li><b>delay</b>: The number of milliseconds to wait before displaying </span><span class="No-Break"><b>loadingComponent</b></li>
	<li><b>errorComponent</b>: The component to display if the promise rejects, or if the loading fails for any reason</li>
	<li><b>timeout</b>: The time in milliseconds before considering the operation to have failed and displaying </span><span class="No-Break"><b>errorComponent</b></li>
</ul>
<p>Here is an example that uses all these attributes:</p>
<pre class="console">const HeavyComponent = defineAsyncComponent(<b>{</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>loader</b>: ()=&gt; import("./HeavyComponent"),
&nbsp;&nbsp;&nbsp;&nbsp;<b>loadingComponent</b>: SpinnerComponent,
&nbsp;&nbsp;&nbsp;&nbsp;<b>delay</b>: 200,
&nbsp;&nbsp;&nbsp;&nbsp;<b>errorComponent</b>: LoadingError,
&nbsp;&nbsp;&nbsp;&nbsp;<b>timeout</b>: 60000
<b>&nbsp;&nbsp;&nbsp;&nbsp;}</b>)</pre>
<p>While the browser retrieves the component from the <b>loader</b> attribute, we display a <b>SpinnerComponent</b> to inform the user that the operation is underway. After 1 minute of waiting, as defined by <b>timeout</b>, it will display the <b>LoadingError</b> component automatically.</p>
<p>With this approach, our code is better optimized. Now, let’s learn how to receive data and notify other components through events.</p>
<h3>Props, events, and the v-model directive</h3>
<p>We have seen basic uses for props and events as means of passing data in and out of a component to its parent. But more powerful definitions are possible with multiple syntaxes. Props can be defined in the <b>script setup</b> syntax with <b>defineProps</b> and any of the following argument formats:</p>
<ul>
	<li>As an array of strings – for example:</li>
</ul>
<p><b>const $props=defineProps(</b><b>[‘name’, ‘last_name’]</b><b>)</b></p>
<ul>
	<li>As an object, whose attributes are used as a name, and the value is of the data type – for example,</li>
</ul>
<p><b>const $props=defineProps(</b><b>{name: String, age: Number}</b><b>)</b></p>
<p>As an object, whose attributes define an object with a type and default value – for example,</p>
<p><b>const $props=defineProps(</b><b>{</b></p>
<p><b>&nbsp;&nbsp;&nbsp;&nbsp;name: { type: String, default: “John”},</b></p>
<p><b>&nbsp;&nbsp;&nbsp;&nbsp;last_name: {type: String, default: “Doe”}</b></p>
<p><b> }</b><b>)</b></p>
<p>We need to keep in mind that primitive values are passed to the component by <b>value</b><b> </b>(meaning that changing their value inside the child component will not affect their value in the parent). However, complex data types, such as objects and arrays, are passed as <b>references</b>, so changes to their inner keys/values will reflect in the parent.</p>
<h6>A note on complex types</h6>
<p class="callout">When defining props of the <b>Object</b> or <b>Array</b> type with default values, the default attribute must be a function that returns said object or array. Otherwise, the reference to the object/array will be shared by all the instances of the component.</p>
<p><i>Events</i> are signals that our child component emits to the parent. This is an example of how to define the events for a component in the <b>script </b><b>setup</b></span><span class="No-Break"> syntax:</p>
<pre class="console">const $emit=<b>defineEmits(</b>['eventName']<b>)</b></pre>
<p>Unlike props, emits only accept an array of strings declaration. Events can also pass a value to the receiver. Here is an example of the invocation from the aforementioned definition:</p>
<pre class="source-code">$emit('eventName', some_value)</pre>
<p>As you can see, <b>defineEmits</b> returns a function that accepts one of the same names provided in the definition array as the first argument. The second argument, <b>some_value</b>, is optional.</p>
<h3>Custom input controllers</h3>
<p>One special application with props and events acting together is to create custom input controllers. In the previous examples, we used the Vue <b>v-model</b> directive on basic HTML input elements to capture their value. Props and events that follow a special naming convention allow us to create input components that accept the <b>v-model</b> directive. Let’s take a look at the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Parent component template</p>
<pre class="source-code">&lt;MyComponent <b>v-model</b>="parent_variable"&gt;&lt;/MyComponent&gt;</pre>
<p>Now that we have the <b>MyComponent</b> in use inside our parent component, let’s see how we create the tie in:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">MyComponent script setup</p>
<pre class="source-code">const $props=defineProps(['<b>modelValue'</b>]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$emit=defineEmits(['<b>update:modelValue'</b>])</pre>
<p>We are using the array definition of <b>Props</b> for brevity. Notice that the name of the prop is <b>modelValue</b>, and the event is <b>update:modelValue</b>. This syntax is expected. When the parent assigns a variable with <b>v-model</b>, the value will be copied to <b>modelValue</b>. When the child emits the <b>update:modelValue</b> event, the parent variable’s value will be updated. In this way, you can create powerful input controls. But there’s more – you can have multiple</span><span class="No-Break"><b> v-models!</b></p>
<p>Let’s consider that <b>modelValue</b> is the default when using <b>v-model</b>. Vue 3 has introduced a new syntax for this directive so that we can have multiple models. The declaration is very simple. Consider the following child component’s declaration:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Child component props and event</p>
<pre class="source-code">const
&nbsp;&nbsp;$props=defineProps(['modelValue', <b>'title'</b>]),
&nbsp;&nbsp;$emit=defineEmits(['update:modelValue',<b>'update:title'</b>])</pre>
<p>With the preceding props and emits definition, we can now reference both from the parent component as the following example shows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Parent component template</p>
<pre class="source-code">&lt;ChildComponent <b>v-model</b>="varA" <b>v-model:title</b>="varB"&gt;&lt;/ChildComponent&gt;</pre>
<p>As we can see, we can attach a modifier to the <b>v-model:name_of_prop</b> directive. In the <b>Child</b> component, the event’s name now has to include the <b>update:</b></span><span class="No-Break"> prefix.</p>
<p>The use of props and events allows a direct data flow to occur between parent and child components. This implies that if data needs to be shared with multiple children, it has to be managed at the parent level. One issue with this restriction appears when the parent needs to pass data not to a child, but to a grandchild or other deeply nested component in the hierarchy tree. That is where the <i>dependency injection pattern</i> comes in to save the day. Vue implements this naturally with the <b>Provide</b> and <b>Inject</b> functions, which we will cover in more detail in the next section.</p>
<h3>Dependency injection with Provide and Inject</h3>
<p>When data in the parent needs to be available in a deeply nested child, using only props, we would have to “pass” the data between components, even if they don’t need it or use it. This issue is called <i>props drilling</i>. The same occurs with events traveling in the opposite direction, having to “bubble” upwards. To solve this issue, Vue offers an implementation of the dependency injection pattern with two functions named <b>Provide</b> and <b>Inject</b>. Using these, the parent or root component <i>provides</i> data (either by value or reference, such as an object), that can be <i>injected</i> into any of its children down the hierarchy tree. Visually, we can represent this situation as follows:</p>
<div>
	<div>
		<img src="images/Figure_4.04_B18602.jpg" alt="Figure 4.4 – Representation of Provide/Inject" width="481" height="157">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Representation of Provide/Inject</p>
<p>As you can see, the process is very simple, as well as the syntax to implement the pattern:</p>
<ol>
	<li>In the parent (root) component, we import the <b>provide</b> function from Vue and create a provision with a key (name) and the data to pass along:<pre class="console">import {provide} from "vue"
provide("provision_key_name", data)</pre></li>
	<li>In the receiving component, we import the <b>inject</b> function and retrieve the data by key (name):<pre class="console"><b>import {</b><b>inject</b><b>} from "vue"</b>
<b>const $received_data = </b><b>inject</b><b>("</b><b>provision_key_name”</b><b>)</b></pre></li>
</ol>
<p>We can also provide a resource at the application level in the following manner:</p>
<pre class="source-code">const app = createApp({})
<b>app.provide(</b>'provision_key_name', data_or_value<b>)</b></pre>
<p>In this way, the provision can be injected into any component of our application. It is worth mentioning that we can also provide complex data types, such as arrays, objects, and reactive variables. In the following example, we are providing an object with functions and references to the parent methods:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">In the parent/root component</p>
<pre class="source-code">import {provide} from "vue"
function logMessage(){console.log("Hi")}
const _provision_data={<b>runLog</b>: logMessage}
provide("service_name", _provision_data)</pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">In the child component</p>
<pre class="source-code">import {inject} from "vue"
const $service = inject("service_name")
$service.<b>runLog</b>()</pre>
<p>In this example, we have effectively provided an <b>application programming interface</b> (<b>API</b>) through an object system-wide. A good practice when naming the “provision key” (service name) is to adhere to a convention that the entire team will understand and follow to identify the functionality, context, and maybe the source of the service provided, and to avoid possible collisions. For example, an injectable service named <b>Admin.Users.Individual.Profile</b> is more descriptive than <b>user_data</b>. It is up to the team and the developer to define the naming convention (a path-like naming is just a suggestion, not a standard). As mentioned before in this book, once you’ve decided upon a convention, what matters is that you are consistent throughout the source code. Later in this chapter, we will use this method to create a plugin to display modal dialogs, but before that, we need to see a few more concepts regarding special components and templates.</p>
<h2>Special components</h2>
<p>The hierarchy of components is very powerful but has limitations. We have seen how we can apply the dependency injection pattern to solve one of those, but there are other cases where we need a bit more flexibility, reusability, or power to share code or templates, or even move a component that’s rendering outside the hierarchy.</p>
<h3>Slots, slots, and more slots...</h3>
<p>Through the use of props, our component can receive JavaScript data. With analog reasoning, it is also possible to pass template fragments (HTML, JSX, and so on) into specific parts of a component’s template using placeholders called <b>slots</b>. Just like props, they accept several types of syntax. Let’s start with the most basic: the <i>default slot</i></span><span class="No-Break">.</p>
<p>Let’s assume we have a component named <b>MyMenuBar</b> that acts as a placeholder for a top menu. We want the parent component to populate the options in the same way that we use a common HTML tag such as <b>header</b> or <b>div</b>, like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Parent component</p>
<pre class="source-code">&lt;MyMenuBar&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<b>&lt;button&gt;Option 1&lt;/button&gt;</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>&lt;button&gt;Option 2&lt;/button&gt;</b>
&lt;/MyMenuBar&gt;</pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">MyMenuBar component</p>
<pre class="source-code">&lt;template&gt;
&lt;div class="..."&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<b>&lt;slot&gt;&lt;/slot&gt;</b>
&lt;/div&gt;
&lt;/template&gt;</pre>
<p>Provided that we applied the necessary styling and classes in <b>MyMenuBar</b>, the final rendered template may look something like this:</p>
<div>
	<div>
		<img src="images/Figure_4.05_B18602.jpg" alt="Figure 4.5 – A menu bar using slots" width="209" height="43">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – A menu bar using slots</p>
<p>The logic that’s applied is quite straightforward. The <b>&lt;slot&gt;&lt;/slot&gt;</b> placeholder will be replaced at runtime by whatever content is provided by the parent component inside the child tags. In the preceding example, if we inspect the rendered final HTML, we may find something like this (considering that we are using <b>W3.css</b></span><span class="No-Break"> classes):</p>
<pre class="source-code">&lt;div class="w3-bar w3-border w3-light-grey"&gt;
&nbsp;&nbsp;&lt;button&gt;Option 1&lt;/button&gt;
&nbsp;&nbsp;&lt;button&gt;Option 2&lt;/button&gt;
&lt;/div&gt;</pre>
<p>This is a fundamental concept in user interface design. Now, what if we need multiple “slots” – for example, to create a layout component? Here, an alternative syntax called <i>named slots</i> comes into play. Consider the following example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">MyLayout component</p>
<pre class="source-code">&lt;div class="layout-wrapper"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;section&gt;&lt;slot <b>name="sidebar"</b>&gt;&lt;/slot&gt;&lt;/section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;header&gt;&lt;slot <b>name="header"</b>&gt;&lt;/slot&gt;&lt;/header&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;main&gt;&lt;slot <b>name="content"</b>&gt;&lt;/slot&gt;&lt;/main&gt;
&lt;/div&gt;</pre>
<p>As you can see, we have named each slot through the <i>name attribute</i>. In the parent component, we must now use the <b>template</b> element with the <b>v-slot</b> directive to access each one. Here is how a parent component would make use of </span><span class="No-Break"><b>MyLayout</b></span><span class="No-Break">:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Parent component</p>
<pre class="source-code">&lt;MyLayout&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;template <b>v-slot="sidebar"</b>&gt; ... &lt;/template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;template <b>v-slot="header"</b>&gt; ... &lt;/template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;template <b>v-slot="content"</b>&gt; ... &lt;/template&gt;
&lt;/MyLayout&gt;</pre>
<p>The <b>v-slot</b> directive receives one argument, matching the slot name, with these remarks:</p>
<ul>
	<li>If the name does not match any available slot, the content is not rendered.</li>
	<li>If no name is provided, or the name <b>default</b> is used, then the content is rendered in the default nameless slot.</li>
	<li>If no content is provided for a template, then the default elements inside of the slot definition will be shown. Default content is placed in between the slot tags: <b>&lt;slot&gt;...default </b><b>content here...&lt;/slot&gt;</b></span><span class="No-Break">.</li>
</ul>
<p>There is also a shorthand notation for the <b>v-slot</b> directive. We just prefix the name of the slot with a numeral sign (<b>#</b>). For example, the templates in the preceding parent component can be simplified like so:</p>
<pre class="source-code">&lt;template <b>#sidebar</b>&gt; ... &lt;/template&gt;
&lt;template <b>#header</b>&gt; ... &lt;/template&gt;
&lt;template <b>#content</b>&gt; ... &lt;/template&gt;</pre>
<p>Slots in Vue 3 are very powerful, to the point that they even admit a way to pass props to the parent if needed. The syntax varies depending on whether we are using a <i>default slot</i> or <i>named slots</i></span><span class="No-Break">.
For example, consider the following component template definition:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PassingPropsUpward component</p>
<pre class="source-code">&lt;div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot <b>:data="some_text"</b>&gt;&lt;/data&gt;
&lt;/div&gt;</pre>
<p>Here, the slot is passing a prop to the parent, named <b>data</b>. The parent component can then access it with the following syntax:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Parent component receiving props from the slot</p>
<pre class="source-code">&lt;PassingPropsUpward <b>v-slot="upwardProp"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<b>{{upwardProp.data}} </b>//Renders the content of some_text
&lt;/PassingPropsUpward&gt;</pre>
<p>In the parent component, we use the <b>v-slot</b> directive and assign a local name to the props passed by the slot – in this case, <b>upwardProp</b>. This variable will receive an object similar in function to the props object but scoped to the element. Because of this, these types of slots are called <i>named scoped slots</i>, and the syntax is similar. Take a look at this example:</p>
<pre class="source-code">&lt;template <b>#header="upwardProp"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{{<b>upwardProp</b>.data}}
&lt;/template&gt;</pre>
<p>There are other advanced uses for slots that cover edge cases, but we will not cover those in this book. Instead, I encourage you to investigate the topic further in the official documentation at </span><a href="https://vuejs.org/guide/components/slots.html"><span class="No-Break">https://vuejs.org/guide/components/slots.html</span></a><span class="No-Break">.</p>
<p>There is one more concept related to this topic that we will see later in this book, in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>Chapter 7</i></span></a>, <i>Data Flow Management</i>, that applies to reactive central state management. Now, let’s look at some special components that behave a bit out of <span class="No-Break">the ordinary.</p>
<h3>Composables and mixins</h3>
<p>In Vue 2, a special component named <b>mixin</b> allowed us to share code between components, thus avoiding code repetition. This approach created several issues and troubling side effects, whose solution evolved into creating the Composition API in Vue 3. The use of mixins is still supported for backward compatibility, but strongly discouraged. We will not cover mixins in this book; instead, we will focus on the technology that has replaced and surpassed them: </span><span class="No-Break"><b>composables</b></span><span class="No-Break">.</p>
<p>A <b>composable</b> is a function that uses the Composition API to encapsulate and reuse <i>stateful logic</i> between components. It is important to distinguish composables from service classes or other encapsulations of <i>business logic</i>. The main purpose of a composable is to share <i>user interface or user interaction logic</i>. In general, each composable does the following:</p>
<ul>
	<li>Exposes a function that returns <i>reactive</i></span><span class="No-Break"> variables.</li>
	<li>Follows a naming convention prefixed with <b>use</b> in <i>camelCase</i> format – for example, <b>useStore()</b>, <b>useAdmin()</b>, <b>useWindowsEvents()</b>, and so on.</li>
	<li>It is self-contained in its own module.</li>
	<li>It handles <i>stateful logic</i>. This means that it manages data that persists and changes over time.</li>
</ul>
<p>The classical example of a composable attaches itself to environmental events (window resizing, mouse movements, sensors, animations, and so on). Let’s implement a simple composable that reads the vertical scroll of the document:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">DocumentScroll.js</p>
<pre class="source-code">import {<b>ref, onMounted, onUnmounted}</b> from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
function <b>useDocumentScroll</b>(){
&nbsp;&nbsp;&nbsp;&nbsp;<b>const y=ref(window.scrollY)</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;function update(){<b>y.value=window.scrollY</b>}
&nbsp;&nbsp;&nbsp;&nbsp;onMounted(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener('scroll', update)})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&nbsp;onUnmounted (()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.removeEventListener('scroll', update)})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
<b>&nbsp;&nbsp;&nbsp;&nbsp;return {y}</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
}
export <b>{useDocumentScroll}</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6</pre>
<p>In this small composable, we start by importing component's life cycle events and the reactive constructor from Vue (<b>//1</b>). Our main function, <b>useDocumentScroll</b>, contains the entire code that we will share and export later (<b>//6</b>). In <b>//2</b>, we create a reactive constant and initialize it to the current window vertical scroll. Then, we create an internal function, <b>update</b>, that updates the value of <b>y</b>. We add this function as a listener to the document scroll event in <b>//3</b>, and then remove it in <b>//4 </b>(principle<i> “Clean after yourself,” </i>from <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a>, <i>Software Design Principles and Patterns</i>). Finally, in <b>//5</b>, we return our reactive constant wrapped in an object. Then, in a component, we use this composable in <span class="No-Break">this way:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">SomeComponent.js – script setup</p>
<pre class="source-code">import {useDocumentScroll} from "./DocumentScroll.js"
const {y}=useDocumentScroll()
...</pre>
<p>Once we have imported the reactive variable, we can use it in our code and template as usual. If we need to use this bit of logic in more than one component, we just need to import the composable (<b>DRY</b></span><span class="No-Break"> principle).</p>
<p>Finally, <a href="https://vueuse.org/">https://vueuse.org/</a> has an impressive collection of composables for our projects.
It is worth checking out.</p>
<h3>Dynamic components with “component:is”</h3>
<p>The Vue 3 framework provides a special component called <b>&lt;component&gt;</b> whose job is to be a placeholder to render other components dynamically. It works with a special attribute, <b>:is</b>, that can receive either a <b>String</b> with the name of a component, or a variable with the component definition. It also accepts some basic expressions (a line of code that resolves to a value). Here is a simple example using an expression:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoinFlip component</p>
<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import <b>Heads </b>from "./heads.vue"
&nbsp;&nbsp;&nbsp;&nbsp;import <b>Tails </b>from "./tails.vue"
&nbsp;&nbsp;&nbsp;&nbsp;function <b>flipCoin</b>(){return Math.random() &gt; 0.5}
&lt;/script&gt;
&lt;template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;component <b>:is="flipCoin()?Heads:Tails"</b>&gt;&lt;/component&gt;
&lt;/template</pre>
<p>When this component is rendered, we will see either the <b>Heads</b> or <b>Tails</b> component based on the result of the <b>flipCoin()</b></span><span class="No-Break"> function.</p>
<p>At this point, you might be wondering, why not use a simple <b>v-show/v-if</b>? The power of this component becomes apparent when managing components dynamically and we don’t know which ones are available at the time of creating the template. The official Vue Router, which we will see in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>Chapter 5</i></span></a>, <i>Single-Page Applications</i>, uses this special component to simulate <span class="No-Break">page navigation.</p>
<p>There is an edge case, however, that we need to be aware of. While most template attributes will pass through to the dynamic component, the use of some directives such as <b>v-model</b> will not work on <i>native input elements</i>. This situation is so rare that we will not discuss it in detail, but it can be found in the official documentation at </span><a href="https://vuejs.org/api/built-in-special-elements.html#component"><span class="No-Break">https://vuejs.org/api/built-in-special-elements.html#component</span></a><span class="No-Break">.</p>
<p>Now that we have a deeper understanding of components, let’s put this new knowledge to work in two projects: a plugin, and a new version of our To-Do application.</p>
<h2>A real-world example – a modals plugin</h2>
<p>We have seen multiple approaches for sharing data and functionality <i>within</i> a project. Plugins are a design pattern for sharing functionality between projects and at the same time augmenting a system’s capabilities. Vue 3 provides a very simple interface to create plugins and attach them to our application instance. Any object that exposes an <b>install()</b> method or a function that accepts the same parameters can become a plugin. A plugin can do the following:</p>
<ul>
	<li>Register global components and directives</li>
	<li>Register an injectable resource at the application level</li>
	<li>Create and attach new properties or methods to the application</li>
</ul>
<p>In this section, we will create a plugin that implements modal dialogs as global components. We will use dependency injection to provide them as a resource and leverage Vue’s reactivity to manage them through promises.</p>
<h3>Setting up our development project</h3>
<p>Follow the instructions in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>Chapter 3</i></span></a>, <i>Setting Up a Working Project</i>, so that you have a starting point. In the <b>src/</b> directory, create a new folder named <b>plugins/</b>, with a sub-folder named <b>modals/</b>. It is a standard approach to place our plugins in individual directories inside the <span class="No-Break"><b>plugins/</b></span><span class="No-Break"> folder.</p>
<h3>The design</h3>
<p>Our plugin will install a component globally and keep an internal reactive state to track the current modal dialog status. It will also provide an API to be injected as a dependency to those components that need to open a modal dialog. This interaction can be represented like this:</p>
<div>
	<div>
		<img src="images/Figure_4.06_B18602.jpg" alt="Figure 4.6 – The modal plugin’s representation" width="480" height="177">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The modal plugin’s representation</p>
<p>Components will implement a modal element, and we will open the dialog through code. When a modal is open, it will return a promise following the async pattern. When the user accepts the modal, the promise will resolve, and reject upon cancellation. The content of the modal will be provided by the parent component through the use of slots.</p>
<h3>The implementation</h3>
<p>For this plugin, we will only need two files – one for the plugin's logic and one for our component. Go ahead and create the <b>index.js</b> and <b>Modal.vue</b> files in the <b>src/plugins/modal</b> folder. At the moment, just scaffold the component with the section’s script setup, template, and style. We will come back later to complete it. With those files in place, let’s start, step by step, with the <b>index.js</b></span><span class="No-Break"> file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/plugins/modals/index.js</p>
<pre class="source-code">import { reactive } from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
import Modal from "./Modal.vue"
const
&nbsp;&nbsp;&nbsp;&nbsp;_current = reactive({}),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;api = {},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&nbsp;<b>plugin = {</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;install(App, options) {</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;App.component("Modal", Modal)</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;App.provide("$modals", api)</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;}</b>
export default <b>plugin</b></pre>
<p>We start in <b>//1</b> by importing the <b>reactive</b> constructor from Vue, and a <b>Modal </b>component whose file we have not yet created. Then, in line <b>//2</b>, we create an internal state property, <b>_current</b>, and in <b>//3</b>, an object that will be our API. For now, these are just placeholders. The important section is in line <b>//4</b>, where we define the <b>install()</b> function. This function receives two parameters in order:</p>
<ol>
	<li>The application instance (</span><span class="No-Break"><b>App</b></span><span class="No-Break">).</li>
	<li>An object with options, if one was passed during the installation process.</li>
</ol>
<p>With the application instance, we register <b>Modal</b> as a global component and provide the API as an injectable resource under the name <b>$modals,</b> both at the application level. To use the plugin in our application, we must import it into <b>main.js</b> and register it with the <b>use</b> method. The code looks like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/Main.js</p>
<pre class="source-code">import { createApp } from 'vue'
import App from './App.vue'
<b>import Modals from "./plugins/modals"</b>
createApp(App)<b>.use(Modals)</b>.mount('#app')</pre>
<p>As you can see, creating and using a plugin is rather simple. However, thus far, our plugin doesn’t do much. Let’s go back to our plugin code and complete the API. What we need is the following:</p>
<ul>
	<li>A <b>show()</b> method that takes a name that identifies a modal dialog implementation and returns a promise. We will then save the name and references to the <b>resolve()</b> and <b>reject()</b> functions in our reactive state.</li>
	<li>An <b>accept()</b> and <b>cancel()</b> methods, to resolve and reject the promise, respectively.</li>
	<li>An <b>active()</b> method to retrieve the name of the current modal.</li>
</ul>
<p>Following these guidelines, we can complete the code so that our <b>index.js</b> file looks like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/plugins/modals/index.js</p>
<pre class="source-code">import { reactive } from "vue"
import Modal from "./Modal.vue"
const
_current = reactive({<b>name:"",resolve:null,reject:null</b>}),
api = {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active()</b> {return _current.name;},
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show(name)</b> {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current.name = name;</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Promise(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(resolve = () =&gt; { }, reject = () =&gt; { }) =&gt; {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current.resolve = resolve;</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_current.reject = reject;</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>},
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accept()</b> {<b>_current.resolve();_current.name = "" </b>},
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancel()</b> {<b>_current.reject();_current.name = "" </b>}
},
plugin = {...} // Omitted for brevity
export default plugin;</pre>
<p>Our internal state is kept with a <b>reactive</b> variable and only accessed through our API. In general, this is a good design for any API. Now, it is time to make the magic happen in our <b>Modal.vue</b> component, to complete the workflow. I’m omitting the classes and styles for brevity, but the full code can be found in this book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></a><span class="No-Break">.</p>
<p>Our modal component will have to do the following:</p>
<ul>
	<li>Cover the entire viewable area with a translucent element to block interaction with the rest of the application</li>
	<li>Provide the dialog to be displayed:</span><ul><li>A <i>prop</i> to register the name of the component, as provided by <span class="No-Break">the parent.</span></li><li>A <i>header</i> to display a title. The title will also be <span class="No-Break">a prop.</span></li><li>An area for the parent component to populate with <span class="No-Break">custom content.</span></li><li>A footer with <i>accept</i> and <span class="No-Break"><i>cancel</i></span><span class="No-Break"> buttons.</span></li><li>A reactive property that triggers when the component <span class="No-Break">should appear.</li></ul></li>
</ul>
<p>With our definition in place, let’s work on the template:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/plugins/modals/Modal.vue</p>
<pre class="source-code">&lt;template&gt;
&lt;div class="viewport-wrapper" <b>v-if="_show"</b>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
&nbsp;&nbsp;&lt;div class="dialog-wrapper"&gt;
&nbsp;&nbsp;&nbsp;&lt;header&gt;<b>{{$props.title}}</b>&lt;/header&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&lt;main&gt;<b>&lt;slot&gt;&lt;/slot&gt;</b>&lt;/main&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&lt;footer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button <b>@click="closeModal(true)"</b>&gt;Accept&lt;/button&gt;&nbsp;&nbsp;&nbsp;//4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button <b>@click="closeModal(false)</b>"&gt;Cancel&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;/footer&gt;
&nbsp;&nbsp;&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
<p>In line <b>//1</b>, the reactive variable, <b>_show</b>, controls the visibility of the dialog modal. We display the prop <b>title </b>in line <b>//2</b>, and reserve a slot in line <b>//3</b>. The buttons in line <b>//4</b> will close the modal on the click event, each one with a representative Boolean value.</p>
<p>Not, it’s time to write the logic of the component. In our script, we need to do the following:</p>
<ul>
	<li>Define two props: <b>title</b> (for display) and <b>name</b> (for identification)</li>
	<li>Inject the <b>$modals</b> resource so that we can interact with the API and do these things:</span><ul><li>Check if the modal’s name matches the current component (this “opens” the <span class="No-Break">modal dialog)</span></li><li>Close the modal by resolving or rejecting <span class="No-Break">the promise</li></ul></li>
</ul>
<p>Following these directions, we can complete our <b>script setup:</b></p>
<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;import { <b>inject</b>, computed } from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
&nbsp;&nbsp;const
&nbsp;&nbsp;$props = defineProps({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: { type: String, default: "" },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title: { type: String, default: "Modal dialog" }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),
&nbsp;&nbsp;<b>$modals = inject("$modals")</b>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;_show = computed(() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <b>$modals.active() == $props.name</b>
&nbsp;&nbsp;})
&nbsp;&nbsp;function closeModal(accept = false) {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accept?$modals.accept():$modals.cancel()</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
&nbsp;&nbsp;}
&lt;/script&gt;</pre>
<p>We begin in line <b>//1</b> by importing the <b>inject</b> and <b>computed</b> functions. In line <b>//2</b>, we create the props with sensible defaults. In line <b>//3</b>, we inject the <b>$modals</b> resource (dependency) that we will use in the computed property in line <b>//4</b> to retrieve the current active modal and compare it with the component. Finally, in line <b>//5</b>, based on the click of the buttons, we trigger the resolution or rejection of the promise.</p>
<p>To use this plugin from any component in our application, we must follow these steps:</p>
<ul>
	<li>In <b>template</b>, define a modal component with the name registered in our plugin (<b>Modal</b>). Notice the use of the attributes for props:<pre class="console">&lt;Modal name=<b>"myModal"</b> title="Modal example"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some important content here
&lt;/Modal&gt;</pre></li>
	<li>In our script setup, inject the dependency with the following code:<pre class="console">const $modals = inject("$modals")</pre></li>
	<li>Display the modal component by the given name with this code:<pre class="console">$modals.show(<b>"myModal"</b>).then(() =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Modal accepted.
}, () =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Modal cancelled
})</pre></li>
</ul>
<p>With this, we have completed our first plugin in Vue 3. Let’s put it to good use in our new To-Do list application.</p>
<h2>Implementing our new To-Do application</h2>
<p>At the beginning of this chapter, we saw a design for our new to-do application, and we sliced it into hierarchical components (see <i>Figure 4</i></span><i>.1</i>). To follow the rest of this section, you will need a copy of the source code from this book’s GitHub repository (<a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</a>). As our code base grows, it is not possible to see each piece of implementation in detail, so we will focus on the main changes and specific bits of code. With that in mind, let’s review the changes from the previous implementation, roughly in order of file execution. To start, we added two new directories to <span class="No-Break">our project:</p>
<ul>
	<li><b>/src/plugins</b>, where we placed our <b>Modals</b></span><span class="No-Break"> plugin.</li>
	<li><b>/src/services</b>, where we place modules with our business or middleware logic. Here, we created a service object to handle the business logic of our To-Do list: the <b>todo.js</b></span><span class="No-Break"> file.</li>
</ul>
<p>In <b>main.js</b>, we import and add our plugin to the application object, using the <b>.use(Modals)</b> method to register our plugin.</p>
<p>The <b>App.vue</b> file has become primarily a layout component, without any other application logic. We import and use a header, <b>(MainHeader.vue)</b>, and a parent component to manage our To-Do list and UI, (<b>ToDoProject.vue)</b>, just like in the design shown in <i>Figure 4</i></span><span class="No-Break"><i>.2</i></span><span class="No-Break">.</p>
<p>The <b>ToDoProject</b> component contains the state of the list through reactive variables, where we have the following:</p>
<ul>
	<li><b>_items</b> is an array that contains our To-Do items</li>
	<li><b>_item</b> is an auxiliary reactive variable that we use to create new items or edit a duplicate of an item</li>
	<li><b>_filter</b> is another auxiliary reactive variable that we use to input a string to filter on our list</li>
</ul>
<p>It is worth mentioning that we also declare a constant, <b>$modals</b>, that receives the injected <b>Modals</b> object API. Notice how the <b>showModal()</b> function opens and manages the result of the dialog for new and edited items using this object. Then, the modal in question appears in the template, by the ending marked with a comment. It is customary to place all the modal templates toward the end of a component, instead of being spaced all over the template.</p>
<p>The <b>ToDoProject</b> component delegates state data through props to child components to display summary and list items. It also receives events from them, with instructions to manipulate the list. You can consider this component as the <i>root</i> of functionality. Our application only has one, but this begins to hint at the idea of how a web application starts to get organized by functionality.</p>
<p>There is another point worth mentioning, which is the use of <i>service objects and classes</i>. In our application, we have <b>todo.js</b>, which we import as <b>todoService</b> where needed. In this case, this is a <i>singleton</i>, but it could also be a class constructor. <i>Notice that it does not contain any interface logic, only application or business logic</i>. This is a defining factor that differentiates it from <i>composables</i>, which we have seen before.</p>
<p>Another change is that the To-Do items now have multiple states, and we can cycle through them with a click. We have implemented this logic in the <b>toggleStatus()</b> function of the service, <i>not in the component</i>. The flow between the states can be represented like this:</p>
<div>
	<div>
		<img src="images/Figure_4.07_B18602.jpg" alt="Figure 4.7 – A circular finite state machine" width="480" height="205">
	</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – A circular finite state machine</p>
<p>You may recognize the design, as it represents a <b>circular finite state machine</b>. <i>Finite state machines</i> are very handy for representing the possible states of an item, and the conditions that trigger each change (in our case, a user’s click). There are many ways to implement a state machine, but one of the simplest is with a <b>switch</b> statement, like in our example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Todo.js</p>
<pre class="source-code">[function] toggleStatus(status){
&nbsp;&nbsp;&nbsp;&nbsp;switch(status){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "not_started":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "in_progress"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "in_progress":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "completed"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "completed":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "not_started"
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
<p>This function, given its current status, will return the next one. Calling this function on each click, we can update the state of each item in a clean manner.</p>
<p>The final point to remark about this new implementation is the use of computed properties in the <b>ToDoSummary</b> component. We use them to display summary cards with the different states of our items. Notice how well the reactivity works – the moment we alter the state of an item in the list, the summary is immediately updated!</p>
<p>With the new implementation in order, it is time to take a step back and view our work with a critical mind.</p>
<h2>A small critique of our new To-Do application</h2>
<p>This new version of the To-Do application is a clear improvement over our first approach, but it can be improved:</p>
<ul>
	<li>We still have only one list of tasks.</li>
	<li>Everything still happens in just one page.</li>
	<li>Our items are ephemeral. They disappear when we close or refresh the browser.</li>
	<li>There is no security, no way to have multiple users, and so on.</li>
	<li>We can only add plain text. How about images or rich text?</li>
	<li>With a bit of work, we could expand our application so that it manages multiple projects, additional content, assignments, and more.</li>
	<li>We have made good progress, but there is still more to do.</li>
</ul>
<h2>Summary</h2>
<p>In this chapter, we dived deep into components and learned how they can communicate, share functionality, and implement design patterns within the framework. We also saw an approach to transform a rough sketch or detailed design into components. We then learned about special components, created a plugin for modal dialogs using the framework’s dependency injection, and applied other patterns to make our coding easier and more congruent. Furthermore, we refactored our application and expanded its capabilities while taking a glimpse at better state management, independent from the HTML element we used before. We have made good progress, but there is still more to go.</p>
<p>In the next chapter, we will create a <b>single-page application</b> (<b>SPA</b>) with what we learned this far.</p>
<h2>Review questions</h2>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ul>
	<li>How can we start from a visual design or prototype and plan the implementation with components?</li>
	<li>What are the many ways that components can communicate with each other?</li>
	<li>How we can reuse code in multiple components? Is there any other way?</li>
	<li>What is a plugin, and how can we create one?</li>
	<li>Which patterns have we applied to the new To-Do application?</li>
	<li>What would you change in the implementation?</li>
</ul>
</div>
</div></div>