import{_ as s,o as a,c as e,X as n}from"./chunks/framework.049a4bb5.js";const m=JSON.parse('{"title":"Полезные советы","description":"","frontmatter":{},"headers":[],"relativePath":"development/misc.md","filePath":"development/misc.md"}'),l={name:"development/misc.md"},p=n(`<h1 id="полезные-советы" tabindex="-1">Полезные советы <a class="header-anchor" href="#полезные-советы" aria-label="Permalink to &quot;Полезные советы&quot;">​</a></h1><details class="details custom-block"><summary>Как поймать момент когда пользователь доскролил до определенного места?</summary><p>Intersection Observer</p></details><details class="details custom-block"><summary>i18n - интернационализация приложения</summary><p>NPM библиотека для интернационализации и локализации i18n очень популярна, однако за последние годы она сильно располнела. В ней много возможностей для локализации дат, чисел, установки нужных склонений, поддержки RTL языков, загрузки локалей с сервера и кучи еще чего. На сайте i18next она называется уже даже &quot;интернационализационным фреймворком&quot;.</p><p>В то же время часто для локализации сайта в большинстве случаев требуются очень простые вещи, занимающие всего пару процентов от всего функционала тяжеловеса i18n.</p><p>По сути обычно нужна реактивная функция, по ключу и текущей локали возвращающая строку.</p><p>Вариант реализации через композабл - в <a href="https://habr.com/ru/articles/736530/" target="_blank" rel="noreferrer">этой статье</a></p><p>Ваш бандл &quot;похудеет&quot; на 50Кб.</p></details><details class="details custom-block"><summary>Ref или Reactive?</summary><p>Отличие в плане использования - Reactive работает только с объектами и не отслеживает замену объекта. Ref работает со всем и отслеживает замену переменной:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// is OK</span></span>
<span class="line"><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// is NOT OK</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span></code></pre></div><p>Реализации реактивных переменных в Vue 2 и Vue 3 отличаются. Во Vue 2 была своя (фреймворка) реализация отслеживания изменений. Во Vue 3 для этого используется объект Proxy, введенный в ES6. Из-за поддержки данного функционала на уровне языка (JavaScript engine), соответствующий код фреймворка получается эффективней и проще.</p><p>Reactive непосредственно использует Proxy объект.</p><p>Ref на объекте использует напрямую Reactive, а для примитивов оборачивает их в объект и снова использует Reactive.</p><p>Если хотите претенциозной эффективности - используйте на объектах Reactive, на примитивах - Ref. В ином случае можно все делать через Ref.</p></details><details class="details custom-block"><summary>shallowRef()</summary><p>Когда у вас массив с большим количеством элементов, но данные внутри элементов массива не меняются, а может меняться только сам массив (добавление элементов, удаление, замена массива) - используйте <code>shallowRef</code>.</p><p>Он работает как Ref, но не отслеживает изменения внутри элементов массива, что дает значительное улучшение производительности.</p></details>`,5),o=[p];function t(c,r,i,y,C,D){return a(),e("div",null,o)}const d=s(l,[["render",t]]);export{m as __pageData,d as default};
