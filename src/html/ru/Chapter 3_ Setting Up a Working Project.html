			<h1>Установка рабочего проекта</h1>
			<p>В предыдущих главах мы заложили теоретические основы проектирования веб-приложений на JavaScript с использованием фреймворка <i>Vue 3</i>. Однако до сих пор мы не приступили к реальному проекту. Именно этому и посвящена данная глава. С помощью нового набора инструментов, поставляемых вместе с Vue 3, мы создадим проект с нуля и подготовим шаблон, который будем использовать в других проектах. Как обычно, начальным проектом для веб-приложения является создание списка дел <i>To-Do</i> (эквивалент <i>Hello World</i>). По мере внедрения каждой новой концепции мы будем дорабатывать приложение, превращая его в нечто гораздо более полезное или, по крайней мере, более интересное.</p> <p>
			<p>Некоторые из практических навыков, которые мы будем осваивать здесь, следующие:</p>
			<ul>
				<li>Настройка рабочей среды и <b>интегрированной среды разработки</b><b> (</span><span class="No-Break">) (</span><span class="No-Break"><b>IDE</b></span><span class="No-Break">)</li>.
				<li>Использование новых инструментов командной строки и нового <b>Vite</b> bundler для создания лесов нашего приложения</li>.
				<li>Модификация базового шаблона и структуры папок с учетом <i>лучших практик</i> и продвинутых архитектурных <i>шаблонов</i></li>.
				<li>Интеграция готовых <b>CSS-фреймворков</b> в наше приложение</li>.
				<li>Конфигурирование Vite bundler под наши нужды</li>.
			</ul>
			<p>В отличие от предыдущих глав, эта будет в основном практической, и в ней будут даны ссылки на официальную документацию по каждому элементу экосистемы, поскольку они периодически меняются. Запоминать шаги не нужно, так как начало проекта с нуля не так часто встречается в крупных проектах, а инструменты для их реализации развиваются. Давайте начнем.</p>
			<h2>Технические требования</h2>
			<p>Для выполнения практических шагов, описанных в этой главе, вам потребуется следующее:</p>
			<ul>
				<li>Компьютер под управлением <b>Windows</b>, <b>Linux</b> или <b>macOS</b> с 64-разрядной архитектурой. Я буду использовать <b>Ubuntu 22.04</b>, но эти инструменты являются кроссплатформенными, и шаги можно выполнять на разных ОС (если что-то будет отличаться, я укажу на это).</li>
				<li><b>Node.js 16.16.0 LTS</b> с установленным <b>npm</b> (<b>node package manager</b>). Шаги по установке Node.js можно найти в официальной документации по адресу <a href="https://nodejs.org/">https://nodejs.org/</a>. Инструменты сборки работают поверх Node.js, так что без него вы не сможете продвинуться далеко. Node.js - это версия JavaScript, адаптированная для работы на серверах и в системах "вне" браузера, что делает ее очень и очень удобной и мощной. Большинство современных пакетных программ для веб-разработки так или иначе используют Node.js, если не хотя бы из-за большого удобства, которое он обеспечивает.</li>
				<li>Текстовый редактор</b>, работающий с обычным текстом в формате UTF-8, желательно IDE. Для этого инструмента нет недостатка в выборе. Теоретически можно обойтись и без IDE, но я настоятельно рекомендую ее приобрести, хотя бы ради помощи в работе с кодом (известной также как <b>IntelliSense</b>, <b>завершение кода</b> и т.д.). Вот некоторые из наиболее популярных вариантов:</span><ul><li><b>Visual Studio Code</b> (бесплатно): Отличный и очень популярный среди разработчиков вариант от Microsoft, который обеспечивает хорошую поддержку Vue 3 через плагин <b>Volar</b>. Официальный сайт - <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>, и в этой книге мы будем использовать этот редактор в качестве рекомендуемой IDE для работы с Vue <span class="No-Break">и Vite.</span></li><li><b>Sublime Text</b> (бесплатная пробная/платная версия): Это еще один популярный вариант, особенно среди пользователей macOS. Официальный сайт <span class="No-Break"> - </span><a href="https://www.sublimetext.com/"><span class="No-Break">https://www.sublimetext.com/</span></a><span class="No-Break">.</span></li><li><b>Jetbrains WebStorm</b> (бесплатная пробная версия, платная): Официальный сайт <span class="No-Break">это </span><a href="https://www.jetbrains.com/webstorm/"><span class="No-Break">https://www.jetbrains.com/webstorm/</span></a><span class="No-Break">.</span></li><li><b>Komodo IDE</b> (бесплатно): Официальный сайт <span class="No-Break">это </span><a href="https://www.activestate.com/products/komodo-ide/"><span class="No-Break">https://www.activestate.com/products/komodo-ide/</span></a><span class="No-Break">.</span></li><li><b>NetBeans IDE</b> (бесплатно): Официальный сайт <span class="No-Break">это </span><a href="https://netbeans.apache.org/"><span class="No-Break">https://netbeans.apache.org/</span></a><span class="No-Break">.</li></ul></li>
				<li>Консоль</b> или <b>эмулятор терминала</b>. Наиболее знакома эта концепция пользователям Linux и macOS. Пользователи Windows могут использовать <b>Command Prompt</b>, встроенный в некоторые IDE терминал, или установить <b>Windows Terminal</b> из Microsoft Store.</li> <li>Современный веб-браузер</b>.
				<li>Современный веб-браузер, основанный на движке Chromium (Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi и др.) или Mozilla Firefox.</li>
			</ul>
			<p>Установив все это, мы готовы к рассмотрению примеров и базовых проектов. Однако я рекомендую также установить <b>Git</b> для контроля версий кода. Мы будем использовать его позже в этой книге, в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_09.xhtml#_idTextAnchor199"><i>главе 9</i></span></a>, <i>Тестирование и контроль исходных текстов</i>. В современной разработке трудно представить себе работу над проектом без какого-либо инструмента для отслеживания изменений кода и контроля версий. Git стал отраслевым стандартом. Установить его можно, руководствуясь документацией с официального сайта <span class="No-Break">at </span><a href="https://git-scm.com/"><span class="No-Break">https://git-scm.com/</span></a><span class="No-Break">.</p> <p>Код, приведенный в данной статье, содержит информацию о том, как можно установить Git.
			<p>Файлы кода этой главы можно найти на GitHub здесь: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03</span></a><span class="No-Break">.</p> <p>Код главы можно найти на GitHub здесь.
			<p>Посмотрите следующее видео, чтобы увидеть код в действии: </span><a href="https://packt.link/CmuO9"><span class="No-Break">https://packt.link/CmuO9</a></p> <p>Код в действии.
			<p>Теперь, имея все необходимые инструменты, мы готовы начать наш первый проект на Vue 3.</p>
			<h2>Настройка проекта и инструменты</h2>
			<p>Мы создадим новый проект, используя <b>Vite</b> в качестве нашего бандлера, непосредственно из командной строки. Откройте окно терминала в каталоге, где будет размещен наш проект, и выполните следующие шаги:</p> <p>
			<ol>
				<li>Наберите следующую команду:</li>
			</ol>
			<p><b>$ npm create vite@latest</b></p>
			<ol>
				<li value="2">Если появится запрос на установку дополнительных пакетов, введите <b>Y</b></span><span class="No-Break"> (да).</li>.
				<li>Следующим шагом вам будет предложено ввести информацию о проекте в следующем порядке:</span><ol><li><b>Имя проекта</b>: Оно будет использоваться для идентификации проекта и создания новой папки для его размещения. Если вы хотите, чтобы проект был установлен в текущую папку, введите точку (<b>.</b>) в качестве <span class="No-Break">имени.</span></span></li><li><b>Имя пакета</b>: Это имя будет использоваться для внутренней конфигурации пакета. В данном примере введите <b>chapter-3</b> (или любое другое имя по вашему выбору). Эта опция может не отображаться, если вы ввели или приняли имя проекта или приняли предложенное по умолчанию имя. Если вы ввели точку (<b>.</b>) в качестве имени для создания проекта в текущем каталоге, то эта опция будет <span class="No-Break">обязательной.</span></li><li><b>Выбрать фреймворк</b>: Здесь помощник отобразит меню с вариантами. Выберите <b>vue</b> с помощью клавиш со стрелками и <span class="No-Break">нажмите </span><span class="No-Break"><i>Enter</i></span><span class="No-Break">.</span></li><li><b>Выберите вариант:</b> Как и раньше, используйте клавиши со стрелками и выберите JavaScript (или TypeScript, но мы будем использовать обычный JavaScript на протяжении всей <span class="No-Break">этой книги).</li></ol></li>.
			</ol>
			<p> Далее вы увидите, как помощник загружает дополнительное содержимое на основе выбранных вами параметров и формирует проект. Он создаст структуру каталогов с множеством файлов. Однако если мы собираемся запустить проект, то вскоре обнаруживаем, что он просто не работает. Это связано с тем, что при установке лесов не устанавливаются зависимости, а только скелет. Поэтому остается сделать еще один шаг - установить зависимости с помощью <b>npm</b>. В терминале введите следующую команду и нажмите <i>Enter</i> (если установка производилась в текущий каталог; если нет, то сначала войдите в только что созданный каталог):</p>
			<pre class="console">$ npm install</pre>
			<p>Менеджер пакетов скачает и установит зависимости для нашего проекта и поместит их в новый каталог <b>node_modules</b>. Как вы уже догадались, наша среда разработки для <b>Vue</b> с <b>Vite</b> - это <b>Node.js</b></span><span class="No-Break"> проект.</p>
			<p>После установки зависимостей настало время запустить проект и посмотреть, что приготовил нам инструмент scaffolding. В терминале введите следующую команду:</p>
			<pre class="console">$ npm run dev</pre>.
			<p> То, что произойдет дальше, может оказаться довольно быстрым. Vite разберет файлы вашего проекта и запустит на вашей машине сервер разработчика с веб-адресом, который вы можете использовать в браузере. В терминале вы увидите примерно следующее:</p>
			<div>
				<div>
					<img src="images/Figure_3.01_B18602.jpg" alt="Рисунок 3.1 - Результат запуска сервера разработки с помощью Vite" width="794" height="115">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 3.1 - Результат работы сервера разработки с Vite</p>
			<p>Самой важной информацией здесь является <b>localhost</b> и порт, на котором обслуживается сайт вашего проекта. Миллисекунды здесь указаны только для того, чтобы вы поняли, насколько быстро Vite может запустить сервер разработки (хвастовство, если хотите знать мое мнение). Далее, чтобы увидеть результаты наших трудов, откройте в браузере <b>локальный адрес</b>, и перед вами должен появиться сайт, выглядящий примерно так:</p> <p>
			<div>
				<div>
					<img src="images/Figure_3.02_B18602.jpg" alt=" Рисунок 3.2: Базовый проект Vite + Vue в браузере" width="1453" height="724">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 3.2: Базовый проект Vite + Vue в браузере</p>
			<p>Этот сайт вполне работоспособен, если не сказать очень производителен. Чтобы проверить, что Vue 3 работает, нажмите на кнопку в центре экрана, и вы увидите, как счетчик увеличивается с каждым нажатием. Это и есть реактивность в действии! Кроме того, Vite предлагает нам сервер разработки с функцией живого обновления и <b>Hot Module Replacement</b> (<b>HMR</b>), то есть как только мы внесем изменения в код и сохраним файлы, сайт обновится автоматически. На практике при разработке пользовательских интерфейсов очень часто приходится держать этот самообновляющийся сайт открытым в браузере для предварительного просмотра нашей работы, а в некоторых случаях и в нескольких браузерах одновременно. Очень удобно! </p>
			<p>Мы продвинулись в нашем путешествии, но это еще далеко не конец. Сайт в виде лесов - это не более чем отправная точка. В оставшейся части главы мы модифицируем его, чтобы он лучше соответствовал нашим целям, и создадим простое приложение To-Do.</p> <p> В следующем разделе мы рассмотрим, как можно улучшить работу с сайтом.
			<p>В следующем разделе мы более подробно рассмотрим структуру и организацию нашего стартового проекта.</p>
			<h2>Структура папок и модификации</h2>
			<p>В <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_01.xhtml#_idTextAnchor017"><i>Глава 1</i></span></a>, <i>Фреймворк Vue 3</i>, мы упоминали, что фреймворки предписывают определенную структуру приложению. Vue 3 не является исключением, но соглашения, используемые в структуре каталогов, минимальны по сравнению с другими фреймворками. Если открыть каталог, в который вы установили проект, в проводнике Files Explorer (либо в ОС, либо в IDE), то вы обнаружите структуру, подобную <span class="No-Break">этой:</p>
			<div>
				<div>
					<img src="images/Figure_3.03_B18602.jpg" alt="Рисунок 3.3: Структура проекта в Visual Code" width="625" height="251">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 3.3: Структура проекта в Visual Code</p>
			<p>Папка <b>.vscode</b> была создана IDE, а <b>node_modules</b> была создана <b>npm</b> для распределения зависимостей. Мы их проигнорируем, так как нам не нужно беспокоиться или работать с ними. Начиная с самого верха, рассмотрим, что представляет собой каждый каталог:</p>
			<ul>
				<li><b>public</b></li>
			</ul>
			<p>Эта папка содержит структуру каталогов и файлы, которые не будут обрабатываться бандлером и будут скопированы непосредственно в конечный сайт. Вы можете свободно размещать здесь свое собственное статическое содержимое. Сюда помещаются изображения, веб-шрифты, сторонние CSS-библиотеки, иконки и т.д. Как правило, здесь размещаются файлы, на которые никогда не будет ссылаться ваш код, например <b>manifest.json</b>, <b>favicon.ico</b>, <b>robots.txt</b> и т.д.</p>.
			<ul>
				<li><b>src</b></li>
			</ul>
			<p>Здесь мы будем размещать наш JavaScript, динамический CSS, компоненты и т.д. 
			<ul>
				<li>Папка <b>assets</b> с SVG-файлом. В эту папку мы можем включить файлы, с которыми будет работать либо код, либо бандлер. Вы можете импортировать их непосредственно в код, а бандлер позаботится об их корректном отображении при передаче на веб-сервер.</li>
				<li>Папка <b>components</b>, в которую мы поместим наши <b>однофайловые компоненты</b> (<b>SFC</b>) с расширением <b>.vue</b>. Здесь мы можем создать структуру каталогов по своему усмотрению. Инструмент scaffolding был размещен внутри компонента <b>HelloWorld.vue</b>.
				<li>Файл <b>App.vue</b>. Это основной компонент нашего приложения и корневой компонент нашей иерархии. Его принято называть именно так.</li> <li>Файл <b>mue</b>.
				<li>Файл <b>main.js</b>, который является начальной точкой нашего приложения. Он отвечает за загрузку начальных зависимостей, главного компонента (<b>App.vue</b>), создание приложения Vue 3 со всеми дополнительными функциями (плагины, глобальные директивы и компоненты), а также запуск и установку приложения на веб-страницу.</li>
				<li>Файл <b>styles.css</b>, представляющий собой глобальную таблицу стилей, которая будет применяться ко всему нашему приложению. В предыдущих версиях инструмента для создания лесов он размещался в папке <b>assets</b>, но теперь он переместился в корень <b>src/</b>, заняв более значимое место. Этот файл при импорте в файл <b>main.js</b> будет разобран и объединен с нашим JavaScript.</li>
			</ul>
			<p>Настало время исследовать файлы в корне проекта в том же порядке, в котором они появляются:</p>
			<ul>
				<li><b>.gitignore</b> - это файл, который управляет тем, что исключается из контроля исходных текстов Git. Мы познакомимся с Git'ом в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_09.xhtml#_idTextAnchor199"><i>главе 9</i></span></a>, <i>Тестирование и </i><span class="No-Break"><i>контроль исходных текстов</i></span><span class="No-Break">.</li>
				<li><b>index.html</b> - это главный файл и отправная точка нашего веб-приложения. Пакет будет обращаться к другим файлам и обрабатывать их в порядке их появления, начиная с <b>index.html</b>. Вы можете изменить его в соответствии со своими потребностями, так как сгенерированный файл является достаточно базовым. Обратите внимание, что в конце тега <b>body</b> инструмент scaffolding включил тег <b>script</b> для загрузки нашего файла <b>main.js</b>. Именно этот файл создает наше приложение Vue. В отличие от других бандлеров, которые автоматически генерируют этот файл и затем внедряют его в <b>index.html</b>, Vite требует, чтобы он был импортирован явно. Помимо прочих преимуществ, это позволяет контролировать, когда приложение Vue будет загружаться внутри веб-страницы.</li>
				<li><b>package-lock.json</b> используется <b>npm</b> для управления зависимостями в <b>node_modules</b>. Игнорируйте его.</li>
				<li><b>package.json</b> очень важен. Этот файл определяет проект, отслеживает зависимости для разработки и производства, а также предоставляет некоторые приятные возможности, например, автоматизацию некоторых задач с помощью простых команд. На данный момент интерес представляет секция <b>scripts</b>, в которой задаются простые псевдонимы для команд. Мы можем запускать их из командной строки, набрав <b>npm run &lt;имя скрипта&gt;</b>. Инструмент scaffolding уже подготовил для нас три команды Vite:</span><ul><li><b>npm run dev</b>: Это запустит сайт в режиме разработчика, с локальным сервером и <span class="No-Break">живой перезагрузкой.</span></li><li><b>npm run build</b>: Это позволит собрать наш код в пакет и оптимизировать его для создания <span class="No-Break">готовой к производству версии.</span></span></li><li><b>npm run preview</b>: Это промежуточный вариант между двумя предыдущими. Он позволяет локально увидеть собранную версию, готовую к производству. Это может показаться непонятным, если не учитывать, что в процессе разработки адреса и ресурсы, к которым обращается приложение, а также публичный URL, могут отличаться от тех, что используются в производстве. Эта опция позволяет запускать приложение локально, но при этом ссылаться на производственные конечные точки и ресурсы и использовать их. Рекомендуется запускать "предварительный просмотр" перед развертыванием <span class="No-Break">вашего приложения.</li></ul></li>
				<li><b>vite.config.js</b> - это конфигурационный файл, определяющий поведение Vite во время разработки и при сборке для производства. Некоторые из наиболее важных и распространенных опций мы рассмотрим далее в этой главе.</li>
			</ul>
			<p>Теперь, когда мы имеем более четкое представление о том, что нам дал инструмент Vite scaffolding, самое время приступить к созданию нашего примера приложения. Прежде чем углубиться в код, необходимо рассмотреть еще несколько вопросов: как интегрировать сторонние таблицы стилей и CSS-фреймворки, а также некоторые конфигурации Vite, которые облегчат нам жизнь.</p> <p>
			<h2>Интеграция с CSS-фреймворками</h2>
			<p>Если вспомнить три последних принципа, рассмотренных в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>главе 2</i></span></a>, <i>Принципы и паттерны проектирования программного обеспечения</i>, (<i>не повторяться</i>, <i>сохранять чистоту</i> и <i>код для следующего</i>), то изобретать велосипед в вопросах внешнего вида и графического языка - вещь в большинстве случаев нежелательная. В Интернете существует постоянно растущая коллекция CSS-фреймворков и библиотек, которые мы можем легко внедрять в наши приложения. От старого популярного Bootstrap до атомарного дизайна, от утилитарных классов, таких как Tailwind, до графических языков, таких как Material Design и скеуоморфизм, - спектр возможностей огромен. В Vue уже имеется достаточное количество библиотек компонентов, реализующих некоторые из них, которые можно найти в репозиториях <b>npm</b>. Используя их, вы будете ограничены в изучении и применении соглашений, применяемых дизайнером, которые в некоторых случаях могут полностью определять, как вы можете построить свой пользовательский интерфейс. Типичными примерами являются использование <b>Vue-material</b> (и других), соответствующих спецификациям Material Design от Google, или применение веб-шрифтов и шрифтов-иконок. Невозможно рассказать о каждом из них, но здесь приведены рекомендации и некоторые примеры включения этих библиотек в <span class="No-Break">ваш проект:</p>
			<ol>
				<li>Поместите статические активы, предоставляемые фреймворком или библиотекой, в папку <b>public</b>, следуя их требуемой структуре и соблюдая любую структуру дерева.</li>
				<li>Включите зависимости для CSS-фреймворка или библиотек в файл <b>index.html</b>, следуя их инструкциям. Часто это подразумевает импорт таблиц стилей и файлов JavaScript в раздел <b>head</b> или в тег <b>body</b>. В любом случае убедитесь, что они размещены до загрузки нашего приложения (тег <b>script</b>, ссылающийся на наш файл <b>main.js</b></span><span class="No-Break">).</li>
				<li>Если фреймворк или библиотеку необходимо инстанцировать, сделайте это до того, как мы смонтируем наше приложение. Это можно сделать непосредственно в <b>index.html</b> в теге <b>script</b>, в <b>main.js</b> или в другом модуле.</li>
				<li>Используйте классы (и JavaScript-функции) в секции шаблона вашего компонента обычным образом, как и в обычном HTML, используя эти библиотеки. Некоторые фреймворки создают глобальные объекты JavaScript, привязанные к объекту <b>window</b>, поэтому к ним можно обращаться непосредственно в секции <b>script</b> компонента. Если это не так, рассмотрите возможность инкапсуляции функциональности, чтобы использовать ее в своем приложении, используя паттерны проектирования, такие как <i>синглтон</i>, <i>прокси</i> или <i>декоратор</i></span><span class="No-Break">.</li>.
			</ol>
			<p>А теперь давайте применим эти простые инструкции на примере нашего проекта. Мы включим в него фреймворк, работающий только на CSS (это означает, что он не использует дополнительный JavaScript), а значки шрифтов будут включать базовую иконографию. В промышленной сборке мы должны удалить неиспользуемые правила CSS. Некоторые CSS-фреймворки предоставляют эту возможность из коробки, например, Tailwind (<a href="https://tailwindcss.com/">https://tailwindcss.com/</a>). Однако эта тема выходит за рамки данной книги, но ее стоит изучить в Интернете.</p>
			<h3>Фреймворк w3.css</h3>
			<p>На сайте <a href="http://w3school.com/">w3school.com</a> предлагается бесплатный фреймворк только для CSS, частично основанный на языке Material Design, популярном в Google и используемом во многих мобильных приложениях. Он предлагает множество полезных классов, которые можно без лицензии применять в своих приложениях. Более подробную информацию можно найти на официальном сайте: </span><a href="https://www.w3schools.com/w3css/"><span class="No-Break">https://www.w3schools.com/w3css/</span></a><span class="No-Break">.</p>
			<p>Мы будем следовать рекомендациям, указанным ранее, поэтому давайте выполним следующие шаги:</p>
			<ol>
				<li>Скачайте файл <b>w3.css</b> с сайта <a href="https://www.w3schools.com/w3css/w3css_downloads.asp">https://www.w3schools.com/w3css/w3css_downloads.asp</a> и поместите его в новую папку с именем <b>css</b> в каталоге <b>public</b>. По окончании работы он должен выглядеть следующим образом:</li>
			</ol>
			<div>
				<div>
					<img src="images/Figure_3.04_B18602.jpg" alt="Рисунок 3.4 - Расположение файла w3.css" width="573" height="72">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 3.4 - Расположение файла w3.css</p>
			<ol>
				<li value="2">Модифицируем <b>index.html</b> в корне нашего проекта, добавив ссылку на файл <b>w3.css</b> с помощью тега <b>link</b> следующим образом:<pre class="console">&lt;link rel="stylesheet" href="<b>/css/w3.css</b>"&gt;</pre></li>.
			</ol>
			<p>Таким образом, классы, определенные в CSS-файле, теперь готовы к использованию в шаблонах нашего компонента. Также, чтобы избежать нежелательных стилей в лесах проекта, не забудьте очистить файл<b> styles.css</b>, предоставляемый программой установки. Если теперь запустить сервер разработки с помощью команды <b>npm run dev</b>, то мы увидим, что внешний вид сайта немного изменился, так как новая таблица стилей была успешно применена. Следующим шагом будет добавление шрифта <i>icon</i></span><span class="No-Break">.</p>
			<h2>FontAwesome - это просто замечательно</h2>
			<p>Одним из способов экономии ресурсов разработчиков при работе с множеством пиктограмм является использование <b>шрифтовых пиктограмм</b>. Это файлы шрифтов, в которых вместо символов отображаются значки. Эта концепция не нова, но она находит широкое применение в веб-разработке. Использование шрифтов для иконок в отличие от других приемов (например, спрайтовых листов CSS) имеет массу преимуществ. Одним из наиболее значимых является то, что с такими иконками можно работать так же, как и с обычными шрифтами, поэтому мы можем легко изменять их размер, цвет и т.д., сохраняя при этом согласованность с остальным текстом. Но не все так радужно и счастливо, поскольку теперь основной компромисс заключается в том, что эти значки отображаются только одним или максимум двумя цветами и по необходимости должны быть довольно простыми.</p> <p> <p><b>ФонтА</b>.
			<p><b>FontAwesome</b> - это сайт, предлагающий <b>шрифты-иконки</b> для использования в наших приложениях, как веб-, так и десктопных. Он занимается этим уже много лет и располагает одними из лучших коллекций иконок. Мы можем скачать и использовать его бесплатный уровень для нашего проекта. Давайте еще раз проследим за тем, как их использовать в нашем проекте:</p>
			<ol>
				<li>Скачайте шрифты <i>для веб</i> с сайта <a href="https://fontawesome.com/download">https://fontawesome.com/download</a>. При этом будет загружен довольно большой ZIP-файл со всеми различными вариантами.</li>
				<li>Из ZIP-файла скопируйте директории <b>css/</b> и <b>webfonts/</b> как есть, в нашу папку <b>public/</b>. Мы не будем использовать все, что находится в этой папке, в наших проектах, поэтому то, что мы не используем, можно будет удалить позже.</li>
				<li>Редактируем файл <b>index.html</b>, чтобы добавить таблицы стилей, которые мы будем использовать. Эти CSS-файлы будут автоматически загружать шрифты иконок из папки <b>/</b><b>webfonts/</b></span><span class="No-Break">:<pre class="console">&lt;link rel="stylesheet"<b> </b>href="<b>/css/fontawesome.min.css</b>"
&gt;
&lt;link rel="stylesheet" href="<b>/css/solid.min.css</b>"&gt;
&lt;link rel="stylesheet" href="<b>/css/brands.min.css</b>"&gt;</pre></li>
			</ol>
			<p>Вот и все, что нам нужно сделать, чтобы включить FontAwesome в наш проект. Существуют и другие альтернативы, которые инкапсулируют шрифты в компоненты Vue, и даже веб-сайт предоставляет реализацию Vue. Однако для наших целей в этой книге мы будем использовать <i>прямой</i> подход. Если мы откроем раздел "Значки" на сайте, то сможем просмотреть и найти все доступные значки. Можно ограничить поиск значками "solid" и "brands", поскольку именно их мы включили в наш проект. Например, если необходимо отобразить значок Vue с помощью FontAwesome, мы можем включить в наш шаблон следующее:</p>
			<pre class="source-code">&lt;i class="<b>fa-brands fa-vuejs"</b>&gt;&lt;/i&gt;</pre>
			<p>Эти классы делают всю магию в любом пустом элементе, но по традиции и для удобства мы всегда используем тег <b>i</b>. Более того, их даже не нужно вводить. Как только вы найдете нужный значок, на сайте появится удобная функция "нажать и скопировать" код. Предыдущая строка взята отсюда:</p>
			<div>
				<div>
					<img src="images/Figure_3.05_B18602.jpg" alt="Рисунок 3.5 - Страница значков FontAwesome" width="596" height="200">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Рисунок 3.5 - Страница иконок FontAwesome</p>.
			<p>Следует помнить, что включение большой библиотеки иконок при использовании лишь некоторых из них скажется на производительности. Для производственных сборок следует включать только те значки, которые будут использоваться в приложении, создавая шрифты значков только с необходимыми значками. Для целей нашей книги и во время разработки мы можем пропустить эту практику.</p> <p>
			<p>Получив хорошую таблицу стилей и несколько хороших шрифтов иконок, мы почти готовы приступить к кодированию. Осталось сделать еще одну вещь - включить несколько дополнительных опций в конфигурацию Vite.</p> <p>
			<h2>Опции конфигурации Vite</h2>
			<p>Файл <b>vite.config.js</b> экспортирует конфигурацию, которую Vite будет использовать для разработки, а также для производства. Vite был задуман как функциональный инструмент для различных фреймворков, а не только для Vue 3, хотя он и является официальным бандлером для него. Открыв файл, мы видим, что Vue является плагином для Vite. Внутри Vite использует <b>Rollup.js</b> (<a href="https://www.rollupjs.org/">https://www.rollupjs.org/</a>) и <b>esbuild </b> (<a href="https://esbuild.github.io/">https://esbuild.github.io/</a>), соответственно, для разработки и сборки. Это означает, что мы можем передавать опции в Vite, но также иметь еще более тонкий контроль над некоторыми крайними случаями, передавая аргументы этим двум инструментам подчёркивания. Кроме того, для каждого режима обработки (разработка и производство) можно передавать различные конфигурации, так что без вариантов здесь не обойтись.</p> <p> Мы рассмотрим, как передавать опции в Vite.
			<p>Некоторые специфические конфигурации для развертывания мы рассмотрим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_10.xhtml#_idTextAnchor224"><i>главе 10</i></span></a>, <i>Deploying Your Application</i>, а пока мы сосредоточимся только на части разработки с несколькими дополнениями, чтобы не набирать слишком много текста и не повторяться в <span class="No-Break">коде.</p>
			<p>Откройте файл <b>vite.config.js</b> и добавьте следующий импорт:</p>
			<pre class="console">import path from "path"</pre>
			<p>Да, импорт path - это не JavaScript, а Node.js, и мы можем это сделать, потому что этот файл читается и выполняется в контексте Node.js. Он никогда не попадет в браузер или какой-либо JavaScript</span><span class="No-Break"><b> </b></span><span class="No-Break">контекст.</p> <p>Модифицируйте экспорт.
			<p>Измените конфигурацию экспорта так, чтобы она выглядела следующим образом:</p>
			<pre class="source-code">export default defineConfig<b>({</b>
plugins: [vue()],
&nbsp;&nbsp;<b>resolve:{</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>alias:{</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>"@components":</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.resolve(__dirname, "src", "components")</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>}</b>
&nbsp;&nbsp;<b>}</b>
})</pre>
			<p>В этих строках мы указываем псевдоним <b>@components</b>, сопоставленный с путем проекта <b>/src/components</b>. Таким образом, при импорте компонентов мы можем не писать относительные или полные пути, а просто ссылаться на импорт внутри компонентов следующим образом:</p>
			<pre class="source-code">import <b>MyComponent</b> from "<b>@components/MyComponent.vue"</b></pre>.
			<p>Использование псевдонимов для путей - хорошая возможность для разработчиков. Пути к компонентам в большом проекте могут быть довольно длинными, а реорганизация кода происходит время от времени, что делает обслуживание еще одной точкой возможного сбоя. Наличие определенного псевдонима дает нам большую гибкость, позволяя вносить изменения только в одном месте (<i>принцип: Не </i><i>повторять себя</i></span><span class="No-Break">).</p>
			<p>Полную справку по конфигурационному файлу Vite можно найти на <a href="https://vitejs.dev/config">https://vitejs.dev/config.</a> Vite предлагает короткий список официальных плагинов (например, для Vue) на https://vitejs.dev/plugins/, но сообщество предоставило достаточное количество плагинов для многих сценариев на https://github.com/vitejs/awesome-vite#plugins. Их можно установить и импортировать в наш конфигурационный файл, когда это потребуется.</p> <p>На данный момент мы имеем дело с плагинами для Vite.
			<p>На данный момент мы достаточно подготовились, чтобы двигаться дальше и наконец-то создать наше простое приложение To-Do.</p>
			<h2>Приложение To-Do</h2>
			<p>Наш пример приложения будет построен на основе файлов базового приложения. Оно предоставит нам элемент ввода для ввода пунктов дел и отобразит список невыполненных и выполненных задач.  Цель этого упражнения заключается в следующем:</p>
			<ul>
				<li>Разработать приложение с обновлением в реальном времени</li>.
				<li>Создать компонент с реактивными элементами в синтаксисе <b>script </b><b>setup</b></span><span class="No-Break"></li>.
				<li>Применение стилей и иконографических шрифтов из сторонних библиотек</li>.
			</ul>
			<p>После завершения работы мы получим простой сайт, который должен выглядеть следующим образом (пункты для примера):</p>
			<div>
				<div>
					<img src="images/Figure_3.06_B18602.jpg" alt=" Рисунок 3.6 - Конечный результат нашего приложения To-Do List с примененными стилями" width="537" height="348">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Рисунок 3.6 - Конечный результат работы приложения To-Do List с примененными стилями</p>
			<p>В рамках данного упражнения мы разработаем все приложение To-Do в одном компоненте, который импортируем в наш <b>главный</b> компонент (<b>App.vue</b>). При этом, конечно, намеренно нарушаются некоторые принципы, которые мы рассматривали в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>главе 2</i></span></a>, <i>Принципы проектирования программного обеспечения и паттерны проектирования</i>. В <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><i>главе 4</i></span></a>, <i>Композиция пользовательского интерфейса с помощью компонентов</i>, мы возьмем этот продукт и "доведем его до ума" с помощью <span class="No-Break">многочисленных компонентов.</p>
			<p>В приложении пользователь будет делать следующее:</p>
			<ol>
				<li>Введите краткое описание и нажмите клавишу <i>Enter</i> или щелкните на знаке плюс, чтобы ввести его в качестве задачи.</li>
				<li>Система отобразит ожидающие и выполненные задачи в отдельных списках, показывая, сколько их в каждой группе.</li>
				<li>Пользователь может щелкнуть на любой задаче, чтобы отметить, выполнена она или отменена, и приложение переместит ее в соответствующую группу.</li>
			</ol>
			<p>Зная, как должно работать приложение, перейдем к коду.</p>
			<h4>App.vue</h4>
			<p>Это наш основной компонент. В стартовом приложении нам необходимо удалить содержимое каждой секции и изменить его на следующее (далее мы объясним, что делает каждая часть):</p> <p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import <b>ToDos </b>from "@components/ToDos.vue"
&lt;/script&gt;</pre>
			<p>В секции <b>script</b> нам нужно импортировать только компонент с именем <b>ToDos</b> (этот файл мы создадим далее). Обратите внимание, что мы используем уже псевдоним для пути (<b>@components</b>). Наш основной компонент не будет обрабатывать никакие другие данные или функциональность, и мы используем его только в качестве обертки для управления макетом приложения. Исходя из этого, наш шаблон теперь будет выглядеть следующим образом:</p>
			<pre class="source-code">&lt;template&gt;
&nbsp;&nbsp;&lt;div class="app w3-blue-gray"&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&lt;ToDos /&gt;</b>
&nbsp;&nbsp;&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>Мы объявили элемент <b>div</b> с частным классом (<b>.app</b>), который мы определим в разделе <b>style</b>. Мы также применили один из стилей, импортированных нами из <b>W3.css</b>, чтобы придать нашему приложению цвет фона. Внутри элемента <b>div</b> мы разместим наш компонент <b>ToDos</b>. Обратите внимание, что мы используем то же имя, которое импортировали в нашу секцию <b>script</b> на языке Pascal. Мы можем использовать эту нотацию или эквивалент HTML-кебабного регистра, <b> &lt;to-dos /&gt;</b>, (слова в нижнем регистре, разделенные дефисами). Тем не менее, во избежание конфликтов с компонентами HTML, как нынешними, так и будущими, рекомендуется всегда использовать в наших шаблонах регистр Паскаля при использовании нескольких слов. В окончательном варианте HTML это имя будет преобразовано в регистр kebab.</p> <p> Далее мы будем использовать регистр kebab.
			<p>Следующим шагом мы определим стиль, используя CSS <b>flex</b> макет для центрирования нашего компонента по центру экрана:</p>
			<pre class="source-code">&lt;style scoped&gt;
.app {
&nbsp;&nbsp;display: <b>flex</b>;
&nbsp;&nbsp;justify-content: <b>center</b>;
&nbsp;&nbsp;width: 100vw;
&nbsp;&nbsp;min-height: 100vh;
&nbsp;&nbsp;padding: 5rem;
}
&lt;/style&gt;</pre>
			<p>После установки основного компонента создадим в каталоге <b>/src/components</b> компонент <b>ToDos</b> с правильным названием </span><span class="No-Break"><b>ToDos.vue</b></span><span class="No-Break">.</p>
			<h4>ToDos.vue</h4>
			<p>В этом компоненте мы разместим всю логику этого простого приложения. Нам понадобятся следующие реактивные переменные:</p>
			<ul>
				<li>Переменная для захвата текста из ввода и создания нашей задачи</li>
				<li>Массив, в котором мы будем размещать объекты задачи со следующими полями: уникальный ID, описание и булево значение, указывающее на то, выполнена задача или нет</li>.
				<li>Функция фильтрации или вычисляемое свойство (или свойства) для отображения только завершенных задач</li>.
			</ul>
			<p>В соответствии с вышеизложенными требованиями заполним раздел <b>script</b> следующим кодом:</p>
			<pre class="source-code">import { <b>ref, computed </b>} from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_todo_text </b>= ref(""),
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_todo_list </b>= ref([]),
<b>&nbsp;&nbsp;&nbsp;&nbsp;_pending = computed</b>(() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _todo_list.value.filter(item =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!item.checked)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),
<b>&nbsp;&nbsp;&nbsp;&nbsp;_done = computed(</b>() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _todo_list.value.filter(item =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.checked)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
function <b>clearToDo</b>() {_todo_text.value = ""}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
function <b>addToDo</b>() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_todo_text.value &amp;&amp; _todo_text.value !== "") {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_todo_list.value.push({id:&nbsp;&nbsp;new Date().valueOf(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: _todo_text.value, checked: false})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearToDo()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
			<p>Начнем с импорта конструкторов <b>ref</b> и <b>computed</b> из Vue в строке <b>//1</b>, поскольку это все, что нам понадобится в данном приложении от фреймворка. В строке <b>//2</b> мы начинаем объявлять две константы для указания на реактивные значения: <b>_todo_text</b>, которая будет содержать описание задачи пользователя в элементе ввода, и <b>_todo_list</b>, которая будет представлять собой массив задач (элементов дел). В строках <b>//3</b> и <b>//4</b> мы объявляем два <b>вычисляемых</b> свойства с именами <b>_pending</b> и <b>_done</b>. Первое будет содержать реактивный массив всех незавершенных дел, а второе - всех помеченных как завершенные. Обратите внимание, что благодаря использованию свойства <b>computed</b> нам нужно хранить только один массив со всеми элементами. Вычисляемые свойства используются для получения сегмента представления списка в соответствии с нашими потребностями. Это часто используемый паттерн для подобных случаев, в отличие, например, от того, чтобы иметь два массива для каждой группы и перемещать элементы между ними.</p> <p>Вычисляемые свойства - это то, что нам нужно.
			<p>И наконец, в строке <b>//5</b> у нас есть вспомогательная функция для сброса значения текста элемента, а в строке <b>//6</b> - простая функция, которая проверяет значение описания и создает задачу (элемент дел) для добавления в наш список. Важно отметить, что при изменении <b>_task_list</b> все зависящие от него свойства и переменные будут автоматически переоценены. Так происходит со свойствами <b>computed</b></span><span class="No-Break">.</p>
			<p>Вот и все, что нам понадобится в логике нашего компонента для достижения желаемых результатов. Теперь пришло время создать шаблон на HTML. Для удобства мы разобьем код на участки. Выделенные сегменты обозначают привязки или взаимодействие с фреймворком, а наш код в секции <b>script</b></span><span class="No-Break">:</p>
			<pre class="source-code">&lt;div class="todo-container w3-white w3-card-4"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- Простой заголовок --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div class="w3-container w3-black w3-margin-0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w3-bottombar w3-border-blue"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i class="fa-solid fa-clipboard-list"&gt;&lt;/i&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Список дел
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/h1&gt;
&lt;/div&gt;</pre>
			<p>Шаблон нашего компонента начинается в строке <b>//1</b> с определения элемента-обертки с некоторыми стилями. Затем, в строке <b>//2</b>, мы размещаем простой заголовок со стилями и шрифтом-иконкой. Обратите внимание, что мы используем классы CSS из фреймворка <b>W3 CSS</b>, а также собственные стили. Следующие строки кода будут посвящены перехвату пользовательского ввода:</p>
			<pre class="source-code">&lt;!-- Пользовательский ввод --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>.
&lt;div class="w3-container flex-container w3-light-gray w3-padding"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input class="w3-input w3-border-0" type="text"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;автофокус
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-model="_todo_text"</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>@keyup.enter="addToDo()"</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder="Введите здесь свой пункт дел..."&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button class="w3-button w3-gray" <b>@click="clearToDo()"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i class="fa-solid fa-times"&gt;&lt;/i&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;button class="w3-button w3-blue"<b> @click="addToDo()"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i class="fa-solid fa-plus"&gt;&lt;/i&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&lt;/div&gt;</pre>
			<p>Взаимодействие с пользователем начинается в секции в строке <b>//3</b>, где мы определяем элемент ввода и присоединяем нашу реактивную переменную <b>_todo_text</b> с помощью директивы <b>v-model</b>. С этого момента все, что пользователь набирает в нашем поле ввода, будет значением нашей переменной в коде. Для удобства мы также фиксируем клавишу <i>Enter</i> с помощью следующего атрибута:</p>
			<pre class="source-code">@keyup.enter="addToDo()"</pre>
			<p>Это вызовет функцию <b>addToDo</b> из нашего скрипта. То же самое мы добавим в кнопку с плюсом рядом с полем ввода, также по событию <b>клик</b></span><span class="No-Break">:</p>
			<pre class="source-code">@click="addToDo()"</pre>
			<p>Таким образом, используя несколько событий, связанных с одной и той же функцией, мы получаем два способа ввода описаний в качестве задач для списка дел. Теперь следующий код сосредоточен на отображении вводимых данных:</p>
			<pre class="source-code">&lt;!-- Список отложенных дел --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4
&lt;div class="w3-padding w3-blue"&gt;Pending (<b>{{ _pending.length }}</b>)
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-for="todo in _pending" :key="todo.id"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="checkbox" <b>v-model="todo.checked"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span class="w3-margin-left"&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ todo.text }}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-show="_pending.length == 0"</b>&gt;Нет задач
&lt;/div&gt;
&lt;!-- Список выполненных заданий --&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5
&lt;div class="w3-padding w3-blue"&gt;Завершено (<b>{{ _done.length }}</b>)
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-for="todo in _done" :key="todo.id"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="checkbox" <b>v-model="todo.checked"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span class="w3-margin-left"&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ todo.text }}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
&lt;/div&gt;
&lt;div class="w3-padding" <b>v-show="_done.length == 0"</b>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6
&nbsp;&nbsp;Нет задач
&lt;/div&gt;
&lt;/div&gt;</pre>
			<p>Для отображения списка задач у нас есть два практически одинаковых блока кода, начинающихся на строках <b>//4</b> и <b>//5</b> - один для отложенных задач, другой - для выполненных. Мы остановимся только на первом блоке (начинающемся на строке <b>//4</b>), поскольку поведение этих блоков практически одинаково. В первом элементе <b>div</b> мы создаем небольшой заголовок, который отображает количество элементов в массиве <b>_pending</b>, интерполируя его длину. Для этого используется следующая строка:</p>
			<pre class="source-code">Pending (<b>{{ _pending.length }}</b>)</pre>.
			<p>Обратите внимание, что мы можем обращаться к атрибутам массива непосредственно внутри двойных фигурных скобок, без использования атрибута <b>.value</b>. Хотя в JavaScript-коде мы должны написать это как <b>_pending.value.length</b>, при использовании интерполяции в HTML Vue достаточно умна, чтобы определить реактивную переменную в нашей секции <b>шаблона</b> и получить доступ к ее значению напрямую. Это справедливо как для <b>вычисляемых</b> свойств, так и для реактивных переменных, созданных с помощью </span><span class="No-Break"><b>ref()</b></span><span class="No-Break">.</p>
			<p>В следующем элементе <b>div</b> мы создаем список с помощью директивы <b>v-for/:key</b>, которая будет перебирать наш массив <b>_pending</b> и создавать копию элемента для каждого элемента. Внутри каждого из них мы теперь можем ссылаться на каждый элемент с именем <b>todo</b>, которое мы объявили в директиве <b>v-for</b>. Далее мы обернем флажок <b>input</b> и span внутри элемента <b>label</b> и привяжем свойство <b>todo.checked</b> (Boolean) к input с помощью <b>v-model</b>. Vue позаботится о присвоении значения <b>true</b> или <b>false</b> в зависимости от состояния флажка. Когда это произойдет, он также вызовет пересчет свойств <b>computed</b>, и мы увидим, как при установке/снятии флажка элемент перемещается между группами (ожидающие и завершенные), а также обновляет общее количество каждого блока. У нас также есть элемент <b>span</b> для отображения текста задачи.</p>
			<p>И наконец, для случаев, когда группа списка пуста, в строке <b>//</b><b>6</b></span><span class="No-Break"> (</span><span class="No-Break"><b>_pending.length==0</b></span><span class="No-Break">) имеется элемент <b>div</b>, который будет виден только при пустом списке.</p>
			<p>Как уже упоминалось, часть, отображающая наш список "выполненных" дел, работает аналогичным образом, применяя ту же логику.</p>
			<p>В данном случае объем наших стилей будет невелик, так как нам потребуется всего пара дополнительных настроек, поскольку основная часть работы была выполнена с помощью библиотеки <b>w3.css</b>. Внутри нашей секции <b>style</b> добавьте следующее:</p>
			<pre class="source-code">.todo-container {max-width: 100%; min-width: 30rem;}
label {cursor: pointer; display: flex;}</pre>.
			<p>Класс <b>todo-container</b> ограничивает максимальную и минимальную ширину нашего компонента, а также мы модифицируем элемент <b>label</b> для отображения его дочерних элементов с помощью макета <b>flex</b></span><span class="No-Break">.</p>.
			<p>Чтобы увидеть приложение в действии, сохраните все изменения и запустите сервер разработки Vite, выполнив в терминале следующую команду:</p>
			<pre class="console">$ npm run dev</pre>.
			<p>После того как Vite будет готов, откройте его адрес в браузере, как мы это делали ранее. Если все в порядке, вы должны увидеть, что наш список дел работает так, как ожидалось. В противном случае проверьте исходный код в репозитории, чтобы убедиться, что набранный вами код соответствует полному примеру.</p> <p>
			<h4>Быстрая критика нашего приложения To-Do</h4>
			<p>Приложение, которое мы только что сделали, работает и является немного более продвинутым, чем простое <b>Hello World</b> или кнопка счетчика. Однако мы не применили все лучшие практики и паттерны, которые должны или могли бы применить. Это сделано специально, в качестве обучающего упражнения. Иногда, чтобы понять, как правильно построить что-то, нужно сначала построить это так, чтобы оно работало как есть. В целом, все инженерные практики понимают, что существует итеративный процесс доработки, который обеспечивает обучение и совершенствование с каждым взаимодействием. Как только мы создали первый прототип, самое время сделать шаг назад и подвергнуть его искренней критике, подумав о том, как мы можем его улучшить и сделать лучше. В данном случае, вот наша критика:</p>
			<ul>
				<li>В нашем шаблоне есть дублирование кода, поскольку вычисляемые свойства <b>_pending</b> и <b>_done</b> в принципе одинаковы, с небольшим отличием, основанным на значении переменной.</li>
				<li>Мы не используем возможности компонентов, поскольку все построено в одном компоненте.</li>
				<li>Наш компонент также создает наши модели (элементы To-Do), поэтому наша бизнес-логика привязана к нашему компоненту.</li>
				<li>Мы сделали очень мало в плане санитарной обработки и контроля ввода. Можно предвидеть, что некоторый код, даже с одинаковыми входными данными, сломает наше приложение.</li>
				<li>Наш список дел непостоянен. Обновление страницы может очистить наш список.</li>
				<li>В нашей задаче есть только два состояния (выполнено и отложено). А что, если мы хотим иметь третье или более состояний? Например, "в процессе", "в ожидании" или "следующий в очереди"</li>.
				<li>Текущий дизайн не предусматривает возможности редактирования или удаления задачи после ее создания.</li>
				<li>Мы можем одновременно управлять только одним списком элементов.</li>
			</ul>
			<p>По мере продвижения вперед мы будем совершенствовать наше приложение и применять принципы и паттерны, чтобы сделать его более устойчивым и полезным. В следующей главе мы рассмотрим, как скомпоновать веб-приложение с помощью веб-компонентов более доступным способом.</p> <h>Обзор</h>.
			<h2>Обзор</h2>
			<p>В этой главе мы начали создавать приложения, используя реальные инструменты, от IDE до инструментов командной строки, для создания лесов, предварительного просмотра и сборки приложения. Мы также создали простое приложение To-Do и узнали, как можно интегрировать сторонние CSS-библиотеки и шрифты иконок в наше приложение, а также определили некоторые общие рекомендации по использованию других библиотек. Мы также критически подошли к нашему простому приложению, чтобы улучшить его функциональность, а заодно и свои навыки. В следующей главе мы рассмотрим, как лучше организовать наш код и создать иерархию компонентов для создания пользовательских интерфейсов.</p>
			<h2>Вопросы к обзору</h2>
			<ul>
				<li>Каковы требования к разработке приложения Vue 3 с помощью Vite? </li>
				<li>Возможно ли интегрировать сторонние библиотеки и фреймворки с Vue 3? </li>
				<li>Каковы шаги по интеграции библиотеки, работающей только с CSS, в приложение Vue? </li>
				<li>Является ли хорошей идеей создание приложения внутри одного компонента? Почему да или нет? Можете ли вы назвать сценарии, когда однокомпонентное приложение является подходящим вариантом? А как насчет сценария, когда это не так?
				<li>Почему разработка программного обеспечения - это итеративный процесс совершенствования? </li>
			</ul>
		</div>
	</div></div>