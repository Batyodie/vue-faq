		<h1>Фреймворк Vue 3</h1>
			<p>Современная всемирная паутина претерпела значительные изменения по сравнению с теми временами, когда Интернет представлял собой лишь набор связанных между собой страниц, предназначенных для академических и научных целей. По мере развития технологий и увеличения мощности машин к прежним протоколам добавлялись все новые и новые возможности, конкурировали новые методы и технологии, пока, наконец, не были приняты стандарты. Дополнительные возможности появились в виде плагинов для браузера и встроенного контента. Распространенными были Java-апплеты, Flash, Macromedia, Quicktime и другие плагины. Именно с появлением HTML5 большинство из них, если не все, были постепенно вытеснены стандартами.</p> <p>Современные стандарты
			<p>Сегодня существует четкое различие между структурой, стилем и поведением. <b>Язык разметки гипертекста</b> (<b>HTML</b>) определяет структурные элементы, из которых состоит веб-страница. <b>Каскадные таблицы стилей</b> (<b>CSS</b>) предоставляют правила, изменяющие внешний вид HTML-элементов, включая даже анимацию и трансформацию. И, наконец, JavaScript - язык программирования, который обеспечивает поведение и может обращаться и изменять как HTML, так и CSS. Такое количество различных возможностей также привело к высокой <i>сложности</i> и несовместимости между браузерами. Именно здесь и зародились библиотеки и фреймворки, которые сначала решали проблемы несовместимости и стандартизации внешнего вида, но вскоре стали включать в себя и другие парадигмы программирования, выходящие за рамки простого манипулирования HTML и CSS.</p> <p>
			<p>Некоторые из наиболее популярных сегодня библиотек и фреймворков используют <b>реактивную парадигму</b>. Они умело вносят изменения в JavaScript, которые автоматически отражаются в HTML/CSS. Vue 3 - это последняя версия прогрессивного фреймворка, в котором в значительной степени используется концепция реактивности. В нем также реализованы другие парадигмы и паттерны проектирования программного обеспечения, позволяющие создавать все: от простых взаимодействий на статичной веб-странице до сложных приложений, которые могут даже устанавливаться локально и конкурировать с нативными настольными приложениями.</p> <p> В книге мы рассмотрим, как можно реализовать прогрессивный фреймворк на базе Vue.
			<p>В этой книге мы познакомимся с фреймворком Vue 3 и изучим различные паттерны проектирования, которые помогут нам создавать первоклассные приложения: от простых веб-страниц до мощных <b>прогрессивных веб-приложений</b> <b>(PWA</b>). Попутно мы рассмотрим лучшие практики и хорошо зарекомендовавшие себя паттерны в программной инженерии.</p> <p> В главе рассматриваются различные паттерны проектирования.
			<p>В этой главе рассматриваются следующие темы:</p>
			<ul>
				<li>Прогрессивный фреймворк</li>
				<li>Однофайловые компоненты</li>
				<li>Различные варианты синтаксиса для написания компонентов</li>
			</ul>
			<p>К концу этой главы вы будете иметь базовое представление о том, какое место Vue 3 занимает в ландшафте JavaScript и какие возможности он предоставляет. Для пользователей Vue 2 в этой книге есть приложение, в котором описаны изменения, на которые необходимо обратить внимание при переносе приложения. По мере продвижения по книге мы будем наращивать знания на основе этих концепций.</p>
			<h2>Прогрессивный фреймворк</h2>
			<p>Перед тем как рассказать о том, что представляет собой Vue, необходимо провести различие между терминами <i>библиотека</i> и <i>фреймворк</i>. Они часто используются как взаимозаменяемые, но разница между ними есть, и хороший разработчик должен знать об этом, выбирая тот или иной вариант для создания веб-приложения.</p> <p>Выбирая тот или иной вариант для создания веб-приложения, мы должны понимать, что это такое.
			<p>Давайте рассмотрим определения этих терминов:</p>
			<ul>
				<li>Библиотека - это коллекция многократно используемого кода в виде функций, классов и т.д., который был разработан кем-то другим и может быть легко импортирован в вашу программу. Они не предписывают, как и где их использовать, но обычно предоставляют документацию по их применению. Программист сам решает, когда и как их применять. Эта концепция существует в большинстве языков разработки, вплоть до того, что некоторые из них полностью основаны на понятии импорта библиотек для обеспечения функциональности.</li>
				<li>В <b>фреймворке</b> также есть наборы классов и функций для использования, но в нем прописаны спецификации, определяющие, как должна работать программа, с какой архитектурой, в каких условиях может быть использован ваш код. Ключевой атрибут, на который следует обратить внимание, заключается в том, что фреймворк инвертирует управление в приложении, то есть определяет поток программы и данных. Тем самым он подчеркивает структуры или стандарты, которых должен придерживаться программист.</li>
			</ul>
			<p>Разделив понятия, теперь возникает вопрос, когда использовать библиотеку, а когда фреймворк. Прежде чем ответить на этот вопрос, давайте поймем, что при создании реальных приложений между ними существует огромная "серая зона". Теоретически одно и то же приложение можно построить, используя любой из этих двух вариантов.
Как и всегда в программной инженерии, необходимо определиться с компромиссами для каждого подхода. Так что воспринимайте то, что будет написано дальше, с щепоткой соли; это не закон, написанный на камне:</p>
			<ul>
				<li>Вы можете использовать <i>библиотеку</i> при создании приложений малого и среднего размера или при необходимости добавления дополнительной функциональности в приложение (в общем случае, вы можете использовать дополнительные библиотеки внутри фреймворков). Существуют и исключения из правила "размера". Например, <b>React</b> - это библиотека, но на ее основе построены огромные приложения, такие как Facebook. Компромисс заключается в том, что использование только библиотек без фреймворка потребует выработки общих подходов и большей координации внутри команды, поэтому усилия по управлению и руководству могут значительно возрасти. С другой стороны, библиотека, используемая в рамках обычного программирования на JavaScript, может предложить некоторые важные улучшения производительности и обеспечить значительную гибкость.</li>
				<li>Вы можете захотеть использовать <i>фреймворк</i> при создании приложений среднего и большого размера, когда вам нужна структура, помогающая координировать разработку, или когда вы хотите быстро начать, минуя "азы" разработки общей функциональности с нуля. Существуют фреймворки, построенные поверх других фреймворков, например, <b>Nuxt</b> построен поверх <b>Vue</b>. Компромисс заключается в том, что для построения приложения вам предписывается архитектурная модель, которая часто соответствует определенному подходу и образу мышления. Вам и вашей команде придется изучить фреймворк и его ограничения и жить в этих границах. Всегда есть вероятность того, что в будущем ваше приложение может перерасти рамки. В то же время некоторые из преимуществ таковы: более легкая координация работы, значительный выигрыш от стартового рывка, верное и проверенное решение общих проблем, ориентация на конкретные ситуации (например, торговые приложения в сравнении с социальными сетями) и многое другое. Однако в зависимости от фреймворка вы можете столкнуться с небольшим снижением производительности за счет дополнительной обработки данных или трудностями масштабирования. Вам предстоит взвесить компромиссы в каждом конкретном случае.</li>
			</ul>
			<p> Итак, что же такое Vue? По определению, <i>Vue - это прогрессивный фреймворк</i> для создания пользовательских интерфейсов. Прогрессивность означает, что он обладает архитектурными преимуществами фреймворка, а также скоростью и модульными преимуществами библиотеки, поскольку функции и функциональность могут быть реализованы постепенно. На практике это означает, что Vue предписывает определенные модели построения приложения, но в то же время позволяет начинать с малого и расширять его настолько, насколько это необходимо. Вы даже можете использовать несколько приложений Vue на одной странице или взять на себя все приложение. При необходимости можно даже импортировать и использовать другие библиотеки и фреймворки. Весьма причудливо! </p>
			<p>Еще одной фундаментальной концепцией Vue является <b>реактивность</b>. Она подразумевает возможность автоматического отображения в HTML значения или изменений, внесенных в переменную в JavaScript, а также внутри вашего кода. В этом заключается большая часть волшебства, предлагаемого Vue.</p> <p>В традиционном программировании, когда переменная изменяется, она автоматически отображается в HTML.
			<p>В традиционном программировании, когда переменной присваивается значение, оно сохраняется до тех пор, пока не будет программно изменено. Однако в реактивном программировании, если значение переменной зависит от других переменных, то при изменении одной из этих зависимостей переменная примет новое результирующее значение. Возьмем, к примеру, следующую простую формулу:</p>
			<pre class="console">A = B + C</pre>.
			<p>В реактивном программировании каждый раз, когда <b>B</b> или <b>C</b> меняют значение, изменяется и <b>A</b>. Как вы увидите далее в этой книге, это очень мощная модель для построения пользовательских интерфейсов. В данном примере, в соответствии с терминологией, <b>A</b> - это зависимый, а <b>B</b> и <b>C</b> - зависимые.</p> <p>В следующих главах мы будем рассматривать <b>A</b> как зависимый.
			<p>В следующих главах мы будем изучать этот <i>прогрессивный</i> атрибут в процессе создания примеров приложений. Но перед этим нам нужно посмотреть, что предлагает Vue 3 в самом базовом виде.</p> <h>Подробнее
			<h2>Использование Vue в веб-приложении</h2>
			<p>Существует несколько вариантов использования Vue в веб-приложении, и это во многом зависит от того, какую цель вы преследуете:</p>
			<ul>
				<li>Для размещения на странице небольшого автономного приложения или фрагмента кода можно напрямую импортировать Vue и код внутри тега script</li>.
				<li>Для создания более крупного приложения вам понадобится инструмент сборки, который возьмет ваш код и <i>составит</i> его для распространения</li>.
			</ul>
			<p>Обратите внимание, что я использую слово <i>сборка</i>, а не <i>компиляция</i>, поскольку JavaScript-приложения интерпретируются и выполняются во время исполнения в браузере. Это станет очевидным позже, когда мы введем понятие <b>однофайловых компонентов</b></span><span class="No-Break">.</p> <p>Подробнее
			<p>Давайте кратко рассмотрим пример первого случая на примере очень простой HTML-страницы:</p>
			<pre class="source-code">&lt;html&gt;
&lt;head&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt;</b>
&lt;/head&gt;
&lt;body&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div <b>id="app"</b>&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{message}}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
&lt;script&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const {createApp} = Vue</b>
&nbsp;&nbsp;&nbsp;&nbsp;createApp(<b>{</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data(){</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {message:'Hello World!'}</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>).mount("#app")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>В разделе <b>head</b> мы определяем тег <b>script</b> и импортируем Vue из бесплатной <b>сети доставки контента</b> (<b>CDN)</b>. При этом создается глобальная переменная <b>Vue</b>, которая открывает все методы и функции фреймворка. Внутри нашего тега <b>body</b> мы объявляем элемент <b>div</b> с <b>id="app"</b>. Это определяет, где будет размещено наше небольшое приложение и какой частью страницы будет управлять фреймворк Vue. Обратите внимание на содержимое <b>div: {{message}}</b>. Двойные фигурные скобки определяют точку, в которой содержимое будет заменено во время выполнения на значение переменной <b>message</b>, которую мы определяем в JavaScript. Это называется <b>интерполяцией</b> и является основным способом отображения значения (строки, числа и т.д.) на веб-странице.</p>
			<p>В конце <b>body</b> мы создаем элемент сценария с нашим приложением. В начале мы извлекаем из Vue функцию <b>createApp</b> и используем ее для создания приложения, передавая объект. Этот объект имеет определенные поля, которые определяют <b>компонент</b>. В данном случае этот компонент раскрывает только метод <b>data()</b>, который, в свою очередь, возвращает объект. Имена полей в этом объекте будут рассматриваться как реактивные переменные, которые мы можем использовать как в JavaScript, так и в HTML. Наконец, конструктор <b>createApp()</b> возвращает экземпляр приложения Vue 3, поэтому мы передаем вызов по цепочке и вызываем метод <b>mount()</b>, чтобы смонтировать наше скромное приложение на элемент с идентификатором <b>app</b>. Обратите внимание, что в качестве аргумента мы используем CSS-селекторы (знак фунта указывает на свойство <b>id</b>, следовательно, <b>id="app"</b> выбирается </span><span class="No-Break"><b>#app</b></span><span class="No-Break">).</p> <p>Кроме того, мы вызываем метод <b>mount()</b>, чтобы установить наше скромное приложение на элемент с идентификатором <b>app</b>.
			<Поскольку этот способ использования Vue не так распространен (и не так популярен), мы сосредоточимся на более важных вещах и будем использовать <b>бандлер</b> для организации рабочего процесса и значительно лучшего опыта разработчика... Но сначала нам нужно узнать немного больше о Vue и о том, что делает его таким замечательным.</p>
			<h3>Путь bundler, лучший путь...</h3>
			<p>Как вы можете себе представить, импортировать Vue непосредственно в веб-страницу можно только для очень маленьких приложений. Вместо этого Vue построен на концепции <i>компонентов</i>, которые представляют собой многократно используемые изолированные наборы JavaScript-кода, HTML и CSS, ведущие себя как единое целое. Их можно рассматривать как строительные блоки для создания веб-страницы. Очевидно, что браузер ничего об этом не знает, поэтому мы будем использовать <i>бандлер</i> для преобразования нашего приложения в то, что браузер может интерпретировать, с дополнительным преимуществом - выполнением ряда оптимизаций в процессе. Именно здесь вступает в действие "фреймворк", который предписывает, как должны быть написаны эти компоненты и какие методы должны содержать.</p> <p> При использовании бандлера мы получаем в свое распоряжение все необходимые компоненты.
			<p>При использовании бандлера весь наш код будет упакован в один или несколько JavaScript-файлов, которые браузер будет загружать во время выполнения. Рабочий процесс выполнения в браузере для приложения Vue можно упростить следующим образом:</p> <p>
			<div>
				<div>
					<img src="images/Figure_1.01_B18602.jpg" alt="Рисунок 1.1: Очень упрощенный вид порядка выполнения нашего приложения при использовании бандлера" width="697" height="302">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 1.1: Очень упрощенное представление порядка выполнения нашего приложения при использовании бандлера</p> <p>Браузер загрузит браузер.
			<p>Браузер, как обычно, загрузит страницу <b>index.html</b>, а затем загрузит и выполнит файл <b>bundle.js</b>, как и любой другой JavaScript. Пакет упакует все наши файлы и выполнит их в заданном порядке:</p>
			<ol>
				<li>Файл <b>main.js</b> импортирует и запускает приложение Vue 3.</li>.
				<li>Затем начнется композиция страницы из <i>главного </i>компонента, заключенного в файл <b>App.vue</b>. Этот компонент порождает другие компоненты, формируя таким образом дерево компонентов, из которых состоит страница.</li>
			</ol>
			<p>Не волнуйтесь, если сейчас это звучит несколько странно. Мы увидим эти понятия в действии по мере создания наших примеров приложений на протяжении всей книги. В <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>главе 3</i></span></a>, <i>Установка рабочего проекта</i>, мы запустим простое приложение, используя эту <span class="No-Break">такую же диаграмму.</p>
			<p>До сих пор вы имели представление о том, что такое библиотеки и фреймворки, и лишь бегло ознакомились с тем, что предлагает Vue. Важно помнить, что в современном мире JavaScript принято использовать бандлеры, которые помогают нам организовать наши приложения и оптимизировать код для браузера. В дальнейшем мы будем работать с официальным бандлером Vue 3, <b>Vite</b>. Но сначала нам нужно знать еще несколько базовых понятий.</p>
			<h2>Понимание однофайловых компонентов</h2>
			<p>Как вы уже догадались, файл <b>App.vue</b>, упомянутый ранее, представляет собой <b>однофайловый компонент</b> (<b>SFC</b>), что является одним из главных достижений Vue. В файле этого типа мы можем описать HTML, CSS и JavaScript, определяющие компонент. Веб-страница состоит из иерархии компонентов, начиная с точки входа (традиционно называемой <b>App.vue</b>) и заканчивая последней настраиваемой кнопкой, если хотите. Более подробно о компонентах мы поговорим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><i>главе 4</i></span></a>, <i>Композиция пользовательского интерфейса с помощью компонентов</i>, а пока запомните, что это путь, предписанный фреймворком. Если у вас есть опыт работы с объектно-ориентированными языками, это может показаться вам знакомым (и вы не ошибетесь <span class="No-Break">).</p
			<p> SFC - это обычный текстовый файл с расширением <b>.vue</b>, содержащий следующие секции:</p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Здесь мы пишем наш JavaScript
&lt;/scrip&gt;
&lt;шаблон&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello World! Это чистый HTML&lt;/h1&gt;
&lt;/template&gt;
&lt;style scoped&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h1{color:purple}
&lt;/style&gt;</pre>
			<p>Поначалу может показаться странным, что все это содержимое собрано в одном месте, но именно это и делает его отличным. Вот описание каждого раздела:</p>
			<ul>
				<li>Тег <b>script </b>, который окружает наш JavaScript и, в зависимости от синтаксиса, экспортирует объект с четко определенными полями. На практике это превращается в <i>модуль</i>, который является современным способом разделения кода в JavaScript. Обратите также внимание, что мы используем атрибут-модификатор <b>setup</b>. Он определяет интерфейс приложения, который мы будем использовать для написания нашего кода на Vue. Мы также можем объявить атрибут <b>lang="ts"</b>, чтобы использовать TypeScript вместо обычного JavaScript.</li>
				<li>Тег <b>template</b> окружает HTML для нашего компонента. Здесь мы можем использовать элементы HTML, другие компоненты, директивы и т. д. Большим преимуществом Vue является то, что мы можем использовать обычный HTML для написания нашего HTML. Это может показаться очевидным, но другие библиотеки работают с этим совершенно иначе и имеют свой собственный синтаксис для этого. Однако Vue 3 позволяет использовать и другие синтаксисы с помощью плагинов bundler. Здесь мы не остаемся без вариантов.</li>
				<li>Тег <b>style</b>, в котором мы разместим CSS для нашего компонента. В данном случае мы используем атрибут <b>scoped</b>, который инкапсулирует правила и ограничивает их рамками нашего компонента, тем самым предотвращая их "утечку" в остальное приложение. Как и в предыдущих разделах, мы также можем использовать различный синтаксис для написания стилей, если он поддерживается бандлером.</li>
			</ul>
			<h6>Лучшая практика</h6>
			<p class="callout">Всегда выделяйте стили, если только вы не определяете стили для родительского компонента или CSS-переменные, которые вы хотите передать всему приложению в явном виде. Для стилей, распространяющихся на все приложение, используйте отдельный CSS-файл.</p>
			<p>Важно помнить, что SFC содержит эти три элемента, определяющие один компонент. Приложение bundler сделает свою магию, отделит каждую часть и поместит ее туда, где она должна быть, чтобы браузер мог правильно интерпретировать ее. Мы будем использовать для этого быстрый и новый <b>Vite</b> в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>главе 3</i></span></a>, <i>Установка рабочего проекта</i>, и в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><i>Глава 4</i></span></a>, <i>Композиция пользовательского интерфейса с компонентами</i>, мы подробно рассмотрим компоненты и то, как управлять потоком управления и информации между ними. Но сначала давайте рассмотрим, как мы пишем <span class="No-Break">наши компоненты.</p>
			<h2>Разные штрихи - опции, состав и API настройки скриптов</h2>.
			<p>Классический способ описания компонента в Vue 2 получил название <i>Options API</i>. Для сохранения обратной совместимости этот же синтаксис поддерживается и в Vue 3. Однако существует и новый синтаксис, названный <i>Composition API</i>, который мы и будем использовать в этой книге.</p> <p>Синтаксис <i>Options API</i>.
			<p>Аппликация <i>Options API</i> унаследована от Vue 2 и предписывает, что компонент определяется объектом с определенными полями, ни одно из которых не является обязательным. Более того, некоторые из них имеют определенные параметры и ожидаемые выходы. Например, вот наиболее часто используемые поля (список также не является исчерпывающим):</p>
			<ul>
				<li><b>data</b> должна быть функцией, возвращающей объект, поля которого станут реактивными переменными.</li>
				<li><b>methods</b> - это объект, содержащий наши функции. Эти функции имеют доступ к реактивным переменным из data, используя формат <b>this.variableName</b></span><span class="No-Break">.</li>
				<li><b>components</b> - объект, каждое поле которого содержит имя шаблона, а значение указывает на конструктор другого компонента (дочернего по отношению к текущему).</li>
				<li><b>computed</b> - это объект, атрибуты которого определяют "вычисляемые" свойства. Каждый член - это функция или объект, который может быть использован в качестве реактивных переменных в нашем шаблоне и коде. Функции будут доступны только для чтения, а объекты могут содержать логику для чтения и записи в них значений. Эта концепция будет проясняться по мере просмотра примеров кода в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>главе 3</i></span></a>, <i>Setting Up a </i><span class="No-Break"><i>Working Project</i></span><span class="No-Break">.</li>
				<li><b>props</b> и <b>emits</b> объявляют параметры для получения данных от родительского компонента и объявляют события, диспетчеризируемые родительскому компоненту. Это обеспечивает формальный способ связи и передачи данных между связанными компонентами, но не единственный, как мы увидим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>главе 7</i></span></a>, <i>Data </i><span class="No-Break"><i>Flow Management</i></span><span class="No-Break">.</li>
				<li>Методы Life cycle hooks - это ряд функций, которые запускаются в течение жизненного цикла компонента.</li>
				<li>Миксины - это объекты, описывающие общую функциональность, которая может быть использована совместно в нескольких компонентах. Это не единственный способ повторного использования кода в Vue 3. Использование миксинов в API Options вызвало некоторые сложности, которые привели к появлению API Composition. Мы не будем подробно рассматривать миксины, но рассмотрим другие подходы к обмену функциональностью между компонентами (например, "composables").</li>
			</ul>
			<p>Этот синтаксис хорошо определен, но имеет ряд ограничений. Для небольших компонентов он слишком сильно загромождает код, а для больших компонентов организация кода сильно страдает и получается очень многословной. Кроме того, для обращения к реактивным переменным, объявленным в секции <b>data</b>, или к другим методам во внутреннем коде приходится использовать ключевое слово <b>this </b> (например, <b>this.data_variable_name</b> или <b>this.myMethod()</b>). Ключевое слово <b>this</b> относится к созданному экземпляру компонента. Проблема заключается в том, что зарезервированное слово <b>this</b> меняет значение в зависимости от области и контекста использования. Есть и другие недостатки, проявившиеся со временем, которые привели к созданию Composition API. Однако данный синтаксис актуален и полностью поддерживается в Vue 3. Одним из его преимуществ является возможность легкой миграции кода из Vue 2 (с определенными оговорками, как показано далее в <i>Приложении - Миграция из </i><i>Vue 2</i></span><span class="No-Break">).</p> <p>Аппликация Composition API раскрывает возможности Vue 2.
			<p>Аппликация Composition API предоставляет метод <b>Setup()</b>, который выполняется перед установкой компонента. В этом методе мы импортируем функции и компоненты, объявляем переменные и т.д., которые определяют наш компонент, вместо того чтобы объявлять их как "опции". Это означает, что вы можете писать свой код в большей степени на JavaScript. Это дает вам свободу импортировать, повторно использовать и лучше организовывать свой код.</p>
			<p>Давайте сравним эти два подхода на примере реактивной переменной,<b> </b><b>_hello="Hello World"</b></span><span class="No-Break">:</p>
			<p><b>Опции API</b></p>
			<pre class="source-code">&lt;script&gt;
 export default{
&nbsp;&nbsp;&nbsp;&nbsp;data(){<b>return {_hello: "Hello World"}</b>}
 }
&lt;/script&gt;</pre>
			<p><b>Композиционный API</b></p>
			<pre class="source-code">&lt;script&gt;
<b>&nbsp;&nbsp;import {ref} from "vue"</b>
&nbsp;&nbsp;export default{
&nbsp;&nbsp;&nbsp;&nbsp;setup(){
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const _hello=ref("Hello World")</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {_hello}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
&lt;/script&gt;</pre>
			<p>В API Options мы просто используем поле <b>data</b>, чтобы вернуть объект, поля которого превратятся в реактивные переменные. Vue позаботится об интерпретации этого объекта. Однако обратите внимание, что в API Composition нам необходимо сначала импортировать из Vue конструктор <b>ref</b>, который создаст для нас реактивную константу или переменную. Конечный результат тот же, но здесь мы имеем более тонкий контроль над тем, что и где делается. При использовании нового бандлера Vite такой тонкий контроль над тем, что импортируется в наши компоненты, может привести к ускорению процесса создания кода и времени разработки.</p> <p> На первый взгляд, результат тот же самый.
			<p>На первый взгляд кажется, что Composition API более многословен, чем Options API, и так оно и есть для такого тривиального примера. Однако по мере роста нашего компонента все становится наоборот. Но все равно, многословность... Итак, существует альтернативный синтаксис для Composition API, называемый <i>script setup</i>, и именно его мы будем использовать в этой книге. Давайте теперь сравним, как выглядит этот компонент с новым синтаксисом:</p>
			<p><b>Composition API - </b><b>script setup</b></p>
			<pre class="source-code">&lt;script <b>setup</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import {<b>ref</b>} from "vue"
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const _hello=ref("Hello World")</b>
&lt;/script&gt;</pre>
			<p>Две строки кода! Это трудно превзойти. Поскольку мы добавили атрибут <b>setup</b> в тег <b>script</b>, программа bundler знает, что все, что мы здесь делаем, относится к области Composition API, и все функции, переменные и константы автоматически отображаются в шаблон. Нет необходимости определять экспорт. Если нам что-то нужно, мы импортируем это напрямую и используем. Кроме того, теперь у нас есть несколько дополнительных преимуществ, например, следующие:</p>
			<ul>
				<li>Мы можем иметь реактивные и нереактивные переменные, отображаемые в нашем шаблоне</li>
				<li>Мы знаем, что весь код выполняется до того, как компонент будет смонтирован</li>
				<li>Синтаксис ближе к ванильному JavaScript (большой плюс!!!), поэтому мы можем организовать наш код так, как нам удобно и приятно</li>.
				<li>Меньший размер пакета (я уже говорил об этом? Да, это важно!)</li>
			</ul>
			<p>Но подождите, вы можете заметить, что я определяю реактивную переменную как <i>константу</i>! Да, это так! И нет, это не ошибка. В JavaScript константа указывает на конкретное неизменяемое значение, которым в данном случае является объект, но это относится только к объекту, а не к его членам. Конструктор <b>ref()</b> возвращает объект, поэтому константа применяется к ссылке на объект, и мы <i>можем</i> изменять значения его членов.
Если вы работали с указателями в Java, C или другом подобном языке, то, возможно, узнаете эту концепцию как использование <b>указателей</b>. Однако за все это приходится платить. Для того чтобы получить доступ к значению и изменить его, теперь необходимо получить доступ к атрибуту <b>значение</b> объекта. Вот пример:</p>
			<pre class="source-code">_hello.value="Некоторое другое значение";</pre>
			<p>Но, в то же время, ничего не изменилось в способе доступа к этой переменной в шаблоне:</p>
			<pre class="source-code">&lt;div&gt;{{_hello}}&lt;/div&gt;</pre>
			<p>Кроме того, каждый раз, когда переменная объявляется как реактивная с помощью конструктора <b>ref()</b>, необходимо ссылаться на ее значение в формате <b>constant_name.value</b>, и именно как <b>constant_name</b> в шаблоне (HTML). Когда имя константы используется в шаблоне, Vue уже знает, как получить доступ к ее значению, и вам не нужно ссылаться на нее явно, как в JavaScript.</p> <h>Советы</h>.
			<h6>Совет</h6>
			<p class="callout">Примите соглашение о коде, чтобы знать, когда идентификатор относится к переменной, константе, функции, классу и т. д.</p> <h2>Совет</h2>.
			<h2>Изучение встроенных директив в Vue 3</h2>
			<p>В Vue также предусмотрены специальные атрибуты HTML, называемые <b>директивами</b>. Директива объявляется в открывающем теге HTML-элемента и влияет на динамическое поведение или функциональность этого элемента. Мы также можем создавать собственные директивы в Vue. Те из них, которые предоставляются фреймворком, имеют специальную нотацию, начинающуюся с <b>v-</b>. В рамках данной книги рассмотрим наиболее часто используемые директивы Vue:</p>
			<h3>v-bind: (сокращение ":")</h3>
			<p>Директива <b>v-bind:</b> связывает значение HTML-атрибута со значением переменной JavaScript. Если переменная является реактивной, то при каждом обновлении ее значения оно будет отражаться в html. Если переменная не реактивная, то она будет использоваться только один раз при первоначальном рендеринге HTML. Чаще всего мы используем только сокращенный префикс <b>:</b> (точка с запятой). Например, реактивная переменная <b>my_profile_picture</b> содержит веб-адрес к картинке:</p>
			<p><b>&lt;</b><b>img :src="my_profile_picture"&gt;</b></p>
			<p>Атрибут <b>src</b> получит значение переменной <b>my_profile_picture</b></span><span class="No-Break">.</p>
			<h3>v-show</h3>
			<p>Эта директива показывает или скрывает элемент, не удаляя его из документа. Она эквивалентна модификации атрибута CSS <b>display</b>. Она ожидает переменную, которая дает булево значение (или то, что может быть интерпретировано как true или непустое). Например, переменная <b>loading</b> имеет булево значение:</p>
			<p><b>&lt;</b><b>div v-show="loading"&gt;...&lt;/div&gt;</b></p>
			<p>Этот <b>div</b> появится, когда переменная <b>loading</b> будет равна true.</p>
			<p>Важно иметь в виду, что <b>v-show</b> будет использовать стиль объекта, чтобы отобразить его или нет, но элемент все равно будет частью <b>объекта документа</b><b>Model</b></span><span class="No-Break"> (</span><span class="No-Break"><b>DOM</b></span><span class="No-Break">).</p> <h3>v-if</b>.
			<h3>v-if, v-else и v-else-if</h3>
			<p>Эти директивы ведут себя так же, как и условные предложения в JavaScript, показывая и скрывая элемент в зависимости от значения, определяемого переданным выражением. Они похожи на <b>v-show</b> в том смысле, что показывают или скрывают элемент, но с той разницей, что они полностью удаляют элемент из DOM. Из-за этого при неправильном использовании в больших масштабах с элементами, часто меняющими свое состояние, они могут быть дороги в вычислительном отношении, так как фреймворку приходится выполнять больше операций для манипулирования DOM, в отличие от <b>v-show</b>, когда нужно изменить только стиль отображения.</p> <h>Примечание</h>.
			<h6>Примечание</h6>
			<p class="callout">Используйте <b>v-if</b> для показа или отображения элементов, которые не будут переключаться после показа или скрытия (и предпочтительно, если начальное состояние скрыто). Используйте <b>v-show</b>, если элемент будет часто переключать состояния. Это улучшит производительность при отображении больших списков элементов.</p>
			<h3>v-for и :key</h3>
			<p>В сочетании эти два атрибута ведут себя подобно циклу <b>for</b> в JavaScript. Они создают столько копий элемента, сколько прописано в итераторе, каждая из которых имеет соответствующее интерполированное значение. Это очень удобно для отображения коллекций элементов данных. Атрибут <b>:key</b> используется внутри цикла для более эффективного отслеживания изменений и должен ссылаться на уникальный атрибут элемента, по которому выполняется цикл, - например, на поле <b>id</b> объекта или на индекс в массиве, если индексы не меняются. Вот пример:</p>
			<p><b>&lt;span v-for="i in 5" :key="i"&gt; {{</b><b>i}} &lt;/span&gt;</b></p>.
			<p>Таким образом на веб-странице будет отображено пять элементов <b>span</b> с интерполяцией <b>i</b>, что выглядит следующим образом:</p>
			<p><b>1 2 3 4 5</b></p>
			<h3>v-model</h3>
			<p>Эта директива - чистая магия. При присоединении к элементу ввода (input, textarea, select и т.д.) она присваивает значение, возвращаемое HTML-элементом, ссылаемой переменной, поддерживая тем самым синхронизацию состояния DOM и JavaScript, что называется <b>двусторонним связыванием</b>. Вот пример:</p>
			<p><b>&lt;input </b><b>type="text" v-model="name"&gt;</b></p>
			<p>Когда пользователь вводит текст в HTML, переменной <b>"name"</b> в JavaScript сразу же присваивается это значение. В этих примерах мы используем примитивные типы данных, такие как числа и строки, но мы можем использовать и более сложные значения, такие как объекты или массивы. Подробнее об этом будет рассказано в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><i>главе 4</i></span></a>, <i>"Композиция пользовательского интерфейса с компонентами"</i>, когда мы рассмотрим компоненты <span class="No-Break">в деталях.</p>
			<h3>v-on: (и сокращение @)</h3>
			<p>Эта директива ведет себя несколько иначе, чем предыдущие. Она ожидает не переменную, а функцию или выражение, и связывает HTML-событие с функцией JavaScript для его выполнения. Событие должно быть объявлено сразу после двоеточия. Например, чтобы отреагировать на событие <b>клик</b> на кнопке,
мы напишем следующее:</p>
			<pre class="source-code"><b>&lt;button v-on:click="printPage()"&gt;Print&lt;/button&gt;</b></pre>.
			<p>Когда кнопка вызывает событие <b>клик</b>, будет выполнена функция JavaScript <b>"printPage()"</b>. Кроме того, для этой директивы чаще используется сокращение, которое мы и будем использовать в дальнейшем в этой книге: просто замените <b>v-on:</b> на <b>@</b>. Тогда предыдущий пример превратится в следующий:</p>
			<p><b>&lt;</b><b>button @click="printPage()"&gt;Print&lt;/button&gt;</b></p>.
			<p>Полный список встроенных директив можно найти в официальной документации здесь: <a href="https://vuejs.org/api/built-in-directives.html">https://vuejs.org/api/built-in-directives.html</a> . По мере продвижения вперед мы увидим и другие.</p> <p> Пока что мы видим, что директивы встроены в систему.
			<p>До сих пор мы видели, что приложения Vue 3 строятся с помощью компонентов, которые мы можем использовать в нашем HTML и которые мы создаем с помощью SFC. Фреймворк также предоставляет нам директивы для работы с элементами HTML, но это еще не все. В следующем разделе мы увидим, что фреймворк также предоставляет несколько удобных готовых компонентов, которые мы можем использовать.</p> <h>Встроенные компоненты</h>.
			<h2>Встроенные компоненты</h2>
			<p>Фреймворк также предоставляет нам несколько встроенных компонентов, которые мы можем использовать, не импортируя их явно в каждый SFC. Я привел здесь небольшое описание каждого из них, поэтому за синтаксисом и примерами можно обратиться к официальной документации (см. </span><a href="https://vuejs.org/api/built-in-components.html"><span class="No-Break">https://vuejs.org/api/built-in-components.html</span></a><span class="No-Break">):</p>
			<ul>
				<li><b>Transition</b> и <b>TransitionGroup</b> - это два компонента, которые могут работать вместе для обеспечения анимации и перехода элементов и компонентов. Они требуют создания CSS-анимации и классов переходов для реализации анимации при вставке или удалении элементов на странице. В основном (или часто) они используются при отображении списка элементов с помощью директив <b>v-for</b>/<b>:key</b> или <b>v-if</b></span><span class="No-Break">/</span><span class="No-Break"><b>v-show</b></span><span class="No-Break">.</li>
				<li><b>KeepAlive</b> - это еще один компонент-обертка (то есть окружение других компонентов), используемый для сохранения состояния (внутренних переменных, элементов и т.д.), когда компонент, обернутый в него, больше не отображается. Обычно при размонтировании экземпляры компонентов очищаются и "собираются в мусор". <b>KeepAlive</b> сохраняет их в кэше, чтобы их состояние было восстановлено, когда они снова появятся на экране.</li>
				<li><b>Teleport</b> - совершенно новый компонент в Vue 3, который позволяет переносить HTML компонента в другое место на странице, даже за пределы дерева компонентов вашего приложения. Это помогает в некоторых случаях, когда необходимо вывести информацию за пределы компонента, но она должна быть обработана внутренней логикой компонента.</li>
				<li><b>Suspense</b> - новый компонент в Vue 3, но пока он находится в экспериментальной стадии, поэтому его будущее на момент написания статьи не определено. Основная идея заключается в отображении "запасного" контента до тех пор, пока все асинхронные дочерние компоненты/элементы не будут готовы к рендерингу. Она предоставляется в качестве удобства, поскольку существуют шаблоны, которые можно использовать для решения этой проблемы. Мы рассмотрим их позже.</li>
				<li><b>Component-is</b> - это специальный элемент, который будет загружать компонент во время выполнения, как предписано содержимым переменной - например, если нам нужно отобразить компонент на основе значения переменной, а использование других директив может быть громоздким. Она также может быть использована для вывода HTML-элементов. Рассмотрим пример:<pre class="console">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import EditItem from "EditItem.vue"
&nbsp;&nbsp;&nbsp;&nbsp;import ViewItem from "ViewItem.vue"
&nbsp;&nbsp;&nbsp;&nbsp;import {ref} from "vue"
&nbsp;&nbsp;&nbsp;&nbsp;const action=ref("ViewItem")
&lt;/script&gt;
&lt;template&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&lt;component :is="action"&gt;&lt;/component&gt;</b>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="action='EditItem'"&gt;Edit&lt;/button&gt;
&lt;/template&gt;</pre></li>.
			</ul>
			<p>В этом простом примере, когда пользователь нажмет кнопку <b>Edit</b>, значение action изменится на <b>EditItem</b>, и компонент поменяется местами. Документацию можно найти здесь:</span><a href="https://vuejs.org/api/built-in-special-elements.html"><span class="No-Break"> https://vuejs.org/api/built-in-special-elements.html.</a></p>
			<p>Поняв, что такое фреймворки и компоненты, мы теперь лучше подготовлены к дальнейшей работе.</p>
			<h2>Кодовые соглашения в книге</h2>
			<p>В этой книге мы будем использовать набор кодовых соглашений и рекомендаций, которые являются хорошей практикой для Vue 3. Они помогут вам не только понять примеры, приведенные в этой книге, но и код, который вы можете встретить в природе, поскольку все больше разработчиков используют его. Давайте начнем с самого начала.</p>
			<h3>Переменные и реквизиты</h3>
			<p>Они всегда пишутся в нижнем регистре, а пробелы заменяются знаком подчеркивания, например, <b>total_count</b> и </span><span class="No-Break"><b>person_id</b></span><span class="No-Break">...</p>
			<h3>Константы</h3>
			<p>Ссылки на инжектируемые объекты начинаются со знака <b>$</b> (доллар), например, <b>$router</b>, <b>$modals</b> и </span><span class="No-Break"><b>$notifications</b></span><span class="No-Break">.</p>
			<p>Ссылки на реактивные данные начинаются с <b>_</b> и набираются в змеином регистре, например, <b>_total</b> и </span><span class="No-Break"><b>_first_input</b></span><span class="No-Break">.</p>
			<p>Ссылки на константные значения обозначаются заглавными буквами, например, <b>OPTION</b> и </span><span class="No-Break"><b>LANGUAGE_CODE.</b></p>.
			<p>Функции-конструкторы для инжектируемых зависимостей будут начинаться с <b>use</b>, например, <b>const $store=useStore().</b></p>
			<h3>Имена классов и компонентов</h3>
			<p>Они записываются в PascalCase (каждое слово начинается с буквы верхнего регистра), например, <b>Person</b>, <b>Task</b> и </span><span class="No-Break"><b>QueueBuilder</b></span><span class="No-Break">.</p>
			<h3>Функции, методы, события и имена файлов</h3>.
			<p>Они пишутся в верблюжьем регистре, например, <b>doSubscribe()</b> и</span><span class="No-Break"></span><span class="No-Break"> </span><span class="No-Break"><b>processQueue()</b></p>.
			<h3>Instances</h3>
			<p>Экземпляры будут иметь абстрактное имя, за которым следует слово <b>Service</b> в случае обычных JavaScript-объектов, предоставляющих функции, <b>Model</b> для моделей состояний и так далее. Мы будем использовать сервисы для инкапсуляции функциональности.</p> <p>Например.
			<p>Приведем пример: <b>const </b><b>projectService=new ProjectService().</b></p>
			<h6>Совет</h6>
			<p class="callout">В своей команде всегда используйте кодовые соглашения, с которыми все согласны. Это сделает код более читаемым и удобным для сопровождения. Можно также порекомендовать использовать линкер (процессор для фиксации соглашений в коде).</p> <p> Как уже говорилось, эти соглашения могут быть использованы в коде.
			<p>Как уже говорилось, эти соглашения набирают популярность, поэтому вы можете встретить их во многих проектах. Однако они не являются обязательными стандартами и уж точно не предписаны фреймворком. Вы можете писать все заглавными буквами, если это ваш стиль, но на самом деле важно, чтобы вы и ваша команда определили и соблюдали свои собственные соглашения в последовательной манере. В конечном итоге важно, чтобы при написании кода у всех нас был общий язык.</p>
			<h2>Подведение итогов</h2>
			<p>В этой главе мы прошли путь от основ библиотек и фреймворков до директив Vue 3, компонентов и даже кодовых соглашений. Эти понятия все еще немного абстрактны, поэтому мы будем доводить их до реализации по мере продвижения по книге и работы с реальным кодом. Однако сейчас мы находимся на безопасной позиции для изучения принципов проектирования и паттернов в следующей главе.</p>
			<h2>Вопросы для обзора</h2>
			<p>Для того чтобы помочь вам закрепить содержание этой главы, вы можете воспользоваться следующими вопросами:</p>
			<ul>
				<li>В чем разница между библиотекой и фреймворком? </li>
				<li>Почему Vue является "прогрессивным" фреймворком? </li>
				<li>Что такое однофайловые компоненты? </li>
				<li>Какие директивы наиболее часто используются при разработке Vue? </li>
				<li>Почему важны соглашения в коде? </li>
			</ul>
			<p>Если вы можете быстро ответить на эти вопросы в уме, то вы готовы к работе! Если нет, то, возможно, вам стоит кратко просмотреть главу, чтобы убедиться, что у вас есть основа для дальнейшей работы.</p> <p>
		</div>
	</div></div>