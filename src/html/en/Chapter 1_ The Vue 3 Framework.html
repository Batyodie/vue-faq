		<h1>The Vue 3 Framework</h1>
			<p>The world wide web of today has changed by many magnitudes since the early days when the internet was just a collection of linked pages for academic and scientific purposes. As the technology evolved and machines became more powerful, more and more features were added to the earlier protocols, and new techniques and technologies competed until finally, standards were adopted. Extra functionality came in the form of plugins for the browser and embedded content. Java applets, Flash, Macromedia, Quicktime, and other plugins were common. It was with the arrival of HTML5 that most, if not all, of these were gradually replaced by standards.</p>
			<p>Today, a clear distinction exists between structure, style, and behavior. <b>Hyper Text Markup Language</b> (<b>HTML</b>) defines the structural elements that make up a web page. <b>Cascading Style Sheets</b> (<b>CSS</b>) provides rules that modify the appearance of HTML elements, including even animations and transformations. And finally, JavaScript is the programming language that provides behavior and can access and modify both HTML and CSS. So many different capabilities also introduced a high level of <i>complexity</i> and incompatibility between browsers. This is where libraries and frameworks were born, at first to solve incompatibility issues and standardize appearance, but soon evolved to include other programming paradigms beyond the simple manipulation of HTML and CSS.</p>
			<p>Some of the most popular libraries and frameworks today use the <b>reactive paradigm</b>. They cleverly make changes in JavaScript to reflect automatically in the HTML/CSS. Vue 3 is the latest version of the progressive framework, which heavily uses the concept of reactivity. It also implements other paradigms and patterns of software design that allow you to build anything from simple interactions in a static web page to complex applications that can even be installed locally and compete with native desktop applications.</p>
			<p>In this book, we will explore the Vue 3 framework, and study different design patterns to help us build first-class applications: from simple web pages to powerful <b>progressive web applications</b> <b>(PWAs</b>). Along the way, we will look at best practices and well-proven patterns in software engineering.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>The progressive framework</li>
				<li>Single-file components</li>
				<li>Different syntax options to write components</li>
			</ul>
			<p>By the end of this chapter, you will have a basic understanding of where Vue 3 fits into the JavaScript landscape, and what features it provides. For Vue 2 users, there is an appendix to this book, with changes needed to be aware of when migrating an application. As the book progresses, we will build knowledge on top of these concepts.</p>
			<h2>The progressive framework</h2>
			<p>Before we describe what Vue is, we need to make the distinction between the terms <i>library</i> and <i>framework</i>. These are often used interchangeably, but there is a difference, and a good developer should be aware of this when choosing one or the other to build a web application.</p>
			<p>Let’s have a look at the definitions of these terms:</p>
			<ul>
				<li>A <b>library</b> is a collection of reusable code, in the form of functions, classes, and so on, that have been developed by someone else and can be easily imported into your program. It does not prescribe how and where to use it, but normally, they provide documentation on how to use them. It is up to the programmer to decide when and how to implement them. This concept exists in most development languages, to the point that some of them are completely based on the notion of importing libraries to provide functionality.</li>
				<li>A <b>framework</b> also has bundles of classes and functions for your use but prescribes specifications that define how the program runs and should be built, with what architecture, and the conditions where or how your code can be used. The key attribute to consider here is that a framework is inverting the control in the application, so it defines the flow of the program and data. By doing so, it emphasizes structures or standards that the programmer should abide by.</li>
			</ul>
			<p>Having separated the concepts, now it raises the question of when to use a library and when to use a framework. Before answering that, let’s be clear that there is a huge gray area between these two when building real-life applications. In theory, you could build the same application using either one.
As always in software engineering, it is a matter of deciding upon the trade-offs for each approach. So, take what comes next with a pinch of salt; it's not a law written in stone:</p>
			<ul>
				<li>You may want to use a <i>library</i> when building small to medium-sized applications, or when in need to add additional functionality to your application (in general, you can use additional libraries inside frameworks). There are also exceptions to the “size” guideline. For example, <b>React</b> is a library, but there are huge applications built on top of it, such as Facebook. A trade-off to consider is that using only libraries without a framework will need establishing common approaches and more coordination within a team, so management and direction efforts can grow significantly. On the other hand, a library used inside plain JavaScript programming can offer some important performance improvements and give you considerable flexibility.</li>
				<li>You may want to use a <i>framework</i> when you build medium to large-sized applications, when you need a structure to help you coordinate the development, or when you want to have a quick start skipping the “basics” of developing common functionality from scratch. There are frameworks that are built on top of other frameworks, for example, <b>Nuxt</b> is built on top of <b>Vue</b>. The trade-off to consider is that you are prescribed an architecture model to build the application, which often follows a particular approach and way of thinking. You and your team will have to learn about the framework and its limits and live within those boundaries. There is always the chance that your application may outgrow the framework in the future. At the same time, some of the benefits are as follows: easier coordination of work, considerable gains from a head-start, common problems solved true and tested, focus on situations (think shopping applications versus social media, for example), and much more. Depending on the framework, however, you could be facing some small performance loss by the extra processing it takes or difficulties scaling up. It is up to you to weigh up the trade-offs for each case.</li>
			</ul>
			<p>So, what is Vue then? By definition, <i>Vue is a progressive framework</i> for building user interfaces. Being progressive means that it has the architectural benefits of a framework, but also the speed and modular advantages of a library, as features and functionality can be incrementally implemented. In practice, this means that it prescribes certain models to build your application, but at the same time, allows you to start small and grow as much as you need. You can even use multiple Vue applications on a single page or take over the entire application. You can even import and use other libraries and frameworks if needed. Quite fancy!</p>
			<p>Another fundamental concept in Vue is that of <b>reactivity</b>. It refers to the capacity of automatically displaying in the HTML the value or changes made to a variable in JavaScript, but also within your code. This is a big part of the magic offered by Vue.</p>
			<p>In traditional programming, once a variable is assigned a value, it holds true until programmatically changed. However, in reactive programming, if a variable’s value depends on other variables, then when one of those dependencies changes, it will take the new resulting value. Take, for example, the following simple formula:</p>
			<pre class="console">A = B + C</pre>
			<p>In reactive programming, every time <b>B</b> or <b>C</b> changes value, so will <b>A</b>. As you will see later in this book, this is a very powerful model to build user interfaces. In this example, and to be according to the terminology, <b>A</b> is the dependent, and <b>B</b> and <b>C</b> are the dependencies.</p>
			<p>In the coming chapters, we will explore this <i>progressive</i> attribute as we build the example applications. But before that, we need to see what Vue 3 offers in its most basic form.</p>
			<h2>Using Vue in your web application</h2>
			<p>There are several options to use Vue in your web application, and it largely depends on what your objective is:</p>
			<ul>
				<li>To include a small self-contained application or piece of code on a page, you can directly import Vue and code inside a script tag</li>
				<li>To build a larger application, you will need a build tool that takes your code and <i>bundles</i> it for distribution</li>
			</ul>
			<p>Notice that I use the word <i>bundle</i> and not <i>compile</i>, as JavaScript applications are interpreted and executed at runtime on the browser. This will become apparent later on when we introduce the concept of <b>single-file components</b></span><span class="No-Break">.</p>
			<p>Let’s briefly see an example of the first case in a very simple HTML page:</p>
			<pre class="source-code">&lt;html&gt;
&lt;head&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt;</b>
&lt;/head&gt;
&lt;body&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div <b>id="app"</b>&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;{{message}}</b>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
&lt;script&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;const {createApp} = Vue</b>
&nbsp;&nbsp;&nbsp;&nbsp;createApp(<b>{</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data(){</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {message:'Hello World!'}</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;}</b>).mount("#app")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>In the <b>head</b> section, we define a <b>script</b> tag and import Vue from a free <b>content delivery network</b> (<b>CDN)</b>. This creates a global variable, <b>Vue</b>, which exposes all the methods and functions of the framework. Inside our <b>body</b> tag, we declare a <b>div</b> element with <b>id="app"</b>. This defines where our small application will be mounted and what part of the page our Vue framework will control. Notice the content of <b>div: {{message}}</b>. The double curly brackets define a point where the content will be replaced at runtime by the value of the <b>message</b> variable that we define in JavaScript. This is called <b>interpolation</b> and is the primary way in which a value (string, number, etc.) can be displayed on the web page.</p>
			<p>By the end of <b>body</b>, we create a script element with our application. We start by extracting the <b>createApp</b> function from Vue and use it to create an application by passing an object. This object has specific fields that define a <b>component</b>. In this case, this component only exposes a <b>data()</b> method that, in turn, returns an object. The field names in this object will be treated as reactive variables that we can use in our JavaScript as well as in the HTML. Finally, the <b>createApp()</b> constructor returns the Vue 3 application instance, so we chain the invocation and call the <b>mount()</b> method to, well, mount our humble application to the element with the <b>app</b> ID. Notice that we are using CSS selectors as the argument (the pound sign indicates the <b>id</b> property, hence <b>id="app"</b> is selected by </span><span class="No-Break"><b>#app</b></span><span class="No-Break">).</p>
			<p>As this method of using Vue is not that common (or popular), we will focus on greater things and will use a <b>bundler</b> to organize our workflow and have a significantly better developer experience...but first, we need to know a bit more about Vue and what makes it so great.</p>
			<h3>The bundler way, a better way...</h3>
			<p>As you can imagine, importing Vue directly into a web page would only work for very small applications. Instead, Vue is structured in the concept of <i>components</i>, which are reusable isolated sets of JavaScript code, HTML, and CSS that behave as a unit. You can think of them as building blocks to compose a web page. Obviously, a browser knows nothing about this so we will use a <i>bundler</i> to transform our application into something the browser can interpret, with the added benefit of running a number of optimizations in the process. Here is where the “framework” part comes into action, as it prescribes how these components should be written and what methods need to contain.</p>
			<p>When using a bundler, it will wrap up all of our code into one or more JavaScript files that the browser will load at runtime. The execution workflow in a browser for a Vue application could be simplified as follows:</p>
			<div>
				<div>
					<img src="images/Figure_1.01_B18602.jpg" alt="Figure 1.1: A very simplified view of our application execution order when using a bundler" width="697" height="302">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: A very simplified view of our application execution order when using a bundler</p>
			<p>The browser will load the <b>index.html</b> page as usual and then load and execute the <b>bundle.js</b> file, just like any other JavaScript. The bundler will have packaged all our files and execute them in a prescribed order:</p>
			<ol>
				<li>The <b>main.js</b> file will import and launch the Vue 3 application.</li>
				<li>Then, it will start the page composition from the<i> main </i>component, here encapsulated in the <b>App.vue</b> file. This component will spawn other components, thus forming a tree of components that make up the page.</li>
			</ol>
			<p>Don’t worry if this sounds a bit strange right now. We will see these concepts in action as we advance building our example applications throughout the book. In <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>Chapter 3</i></span></a>, <i>Setting Up a Working Project</i>, we will start a simple application using this <span class="No-Break">same diagram.</p>
			<p>So far, you have had a view of what libraries and frameworks are, and just a quick peek into what Vue has to offer. What is important to remember is that in the modern JavaScript world, it is common to use bundlers to help us organize our applications and optimize the code for the browser. We will work with the official Vue 3 bundler, <b>Vite</b>, later on. But first, we need a few more basic concepts.</p>
			<h2>Understanding single-file components</h2>
			<p>As you may have guessed, the <b>App.vue</b> file mentioned before is a <b>single-file component</b> (<b>SFC</b>), one of the great contributions of Vue. In this type of file, we can describe the HTML, CSS, and JavaScript that defines the component. The web page is then composed in a hierarchy of components, starting from an entry point (traditionally named <b>App.vue</b>) down to the last customized button, if you will. We will discuss components in depth in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><i>Chapter 4</i></span></a>, <i>User Interface Composition with Components</i>, but for now, keep in mind that this is the way to go, as prescribed by the framework. If you have experience in an object-oriented language, this may look familiar (and you wouldn’t <span class="No-Break">be wrong).</p>
			<p>An SFC is a plain text file with the <b>.vue</b> extension that contains the following sections:</p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;// Here we write our JavaScript
&lt;/scrip&gt;
&lt;template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello World! This is pure HTML&lt;/h1&gt;
&lt;/template&gt;
&lt;style scoped&gt;
&nbsp;&nbsp;&nbsp;&nbsp;h1{color:purple}
&lt;/style&gt;</pre>
			<p>It may look strange at first, to have all this content in one place, but this is actually what makes it great. Here is a description of each section:</p>
			<ul>
				<li>A <b>script </b>tag that surrounds our JavaScript, and depending on the syntax, it exports an object with well-defined fields. In practice, this becomes a <i>module</i>, which is the modern way to split code in JavaScript. Notice also that we are using a modifier attribute, <b>setup</b>. This will define the application interface that we are going to use to write our code in Vue. We could also declare the <b>lang="ts"</b> attribute to use TypeScript instead of plain JavaScript.</li>
				<li>A <b>template</b> tag surrounds the HTML for our component. Here, we can use HTML elements, other components, directives, and so on. A great advantage of Vue is that we can use plain HTML to write our HTML. This may sound obvious, but other libraries handle this completely differently and have their own syntax for it. However, Vue 3 also allows the use of other syntaxes through the use of bundler plugins. We are not left out of options here.</li>
				<li>A <b>style</b> tag, where we will place the CSS for our component. In this case, we use the <b>scoped</b> attribute, which will encapsulate the rules and limit them to our component, thus preventing them from “bleeding out” to the rest of the application. In the same way as with previous sections, we can also use different syntax to write the styles, as long as it is supported by the bundler.</li>
			</ul>
			<h6>Best practice</h6>
			<p class="callout">Always scope your styles, unless you are defining styles on a parent component or CSS variables that you want explicitly to be passed on to the entire application. For application-wide styles, use a separate CSS file.</p>
			<p>The important concept to remember is that an SFC contains these three elements that define a single component. The bundler application will do its magic and separate each part and place it where it belongs, so the browser can interpret them properly. We will use the fast and new <b>Vite</b> for this in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>Chapter 3</i></span></a>, <i>Setting Up a Working Project</i>, and in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><i>Chapter 4</i></span></a>, <i>User Interface Composition with Components</i>, we will delve in-depth into components and how to handle the flow of control and information between them. But first, let’s take a look at how we write <span class="No-Break">our components.</p>
			<h2>Different strokes – options, composition, and script setup API</h2>
			<p>The classical way to describe a component in Vue 2 has been branded as the <i>Options API</i>. To maintain backward compatibility, the same syntax is also supported in Vue 3. However, there is also a new syntax named the <i>Composition API</i>, which is what we will use in this book.</p>
			<p>The <i>Options API</i> is inherited from Vue 2 and prescribes that a component is defined by an object with defined fields, none of which is actually mandatory. Moreover, some of them have defined parameters and expected outputs. For example, these are the most common fields to use (also, a non-exclusive list):</p>
			<ul>
				<li><b>data</b> should be a function that returns an object whose fields would become reactive variables.</li>
				<li><b>methods</b> is an object that contains our functions. These functions have access to the reactive variables from data by using the <b>this.variableName</b></span><span class="No-Break"> format.</li>
				<li><b>components</b> is an object where each field provides a name for the template, and the value points to the constructor of another component (child to the current one).</li>
				<li><b>computed</b> is an object whose attributes define “computed” properties. Each member is then a function or an object that can be used as reactive variables in our template and code. Functions will be read-only, and objects could include logic to read and write values to them. This concept will be clarified as we see code examples in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><i>Chapter 3</i></span></a>, <i>Setting Up a </i><span class="No-Break"><i>Working Project</i></span><span class="No-Break">.</li>
				<li><b>props</b> and <b>emits</b> declare parameters to receive data from the parent component and declare events that get dispatched to the parent component. This provides a formal way to communicate and pass data between related components, but is not the only one, as we will see in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>Chapter 7</i></span></a>, <i>Data </i><span class="No-Break"><i>Flow Management</i></span><span class="No-Break">.</li>
				<li>Life cycle hooks methods are a series of functions that are triggered during the life cycle of the component.</li>
				<li>Mixins are objects that describe a common functionality that could be shared across multiple components. This is not the only way to reuse code in Vue 3. The use of mixins in the Options API caused some complications that gave birth to the Composition API. We will not deal with mixins in detail, but will see other approaches to share functionality between components (such as “composables”).</li>
			</ul>
			<p>This syntax is well-defined but has some limitations. For small components, it is too much scaffolding code, and for large components, the code organization suffers greatly and is very verbose. Plus, in order to reference the reactive variables declared in the <b>data</b> section or other methods, the internal code has to use the <b>this </b>keyword (e.g., <b>this.data_variable_name</b> or <b>this.myMethod()</b>). The <b>this</b> keyword refers to the created instance of the component. The problem is when the reserved word <b>this</b> changes meaning depending on the scope and context of use. There are other drawbacks that have appeared over time that led to the creation of the Composition API. However, this syntax is relevant and fully supported by Vue 3. One advantage of this is that you can easily migrate code from Vue 2 (within certain considerations, as shown later in the <i>Appendix – Migrating from </i><i>Vue 2</i></span><span class="No-Break">).</p>
			<p>The Composition API exposes a method called <b>Setup()</b> that is executed before the component is mounted. In this method, we import functions and components, declare variables, and so on, that define our component instead of declaring them as “options.” This means that you can write your code in more of a JavaScript way This gives you the freedom to import, reuse, and organize your code better.</p>
			<p>Let’s see a comparison between the two approaches with a reactive variable,<b> </b><b>_hello="Hello World"</b></span><span class="No-Break">:</p>
			<p><b>Options API</b></p>
			<pre class="source-code">&lt;script&gt;
 export default{
&nbsp;&nbsp;&nbsp;&nbsp;data(){<b>return {_hello:"Hello World"}</b>}
 }
&lt;/script&gt;</pre>
			<p><b>Composition API</b></p>
			<pre class="source-code">&lt;script&gt;
<b>&nbsp;&nbsp;import {ref} from "vue"</b>
&nbsp;&nbsp;export default{
&nbsp;&nbsp;&nbsp;&nbsp;setup(){
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const _hello=ref("Hello World")</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {_hello}</b>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
&lt;/script&gt;</pre>
			<p>In the Options API, we just use the <b>data</b> field to return an object whose fields will turn into reactive variables. Vue will take care of interpreting the object. However, notice how, in the Composition API, we need to first import from Vue the <b>ref</b> constructor, which will create a reactive constant or variable for us. The end result is the same, but here, we have more fine control over what is done and where. When using the new Vite bundler, this fine control of what gets imported into our components may result in faster code building and development times.</p>
			<p>At first sight, it seems that the Composition API is more verbose than the Options API, and so it is for such a trivial example. However, as our component begins to grow, this becomes the opposite. Still, verbose... So, there is an alternative syntax for the Composition API called <i>script setup</i>, and is the one we will use in this book. Let’s compare now how this component looks with this new syntax:</p>
			<p><b>Composition API – </b><b>script setup</b></p>
			<pre class="source-code">&lt;script <b>setup</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import {<b>ref</b>} from "vue"
<b>&nbsp;&nbsp;&nbsp;&nbsp;const _hello=ref("Hello World")</b>
&lt;/script&gt;</pre>
			<p>Two lines of code! That is hard to beat. Because we added the <b>setup</b> attribute in the <b>script</b> tag, the bundler knows everything we do here is in the realm of the Composition API, and all the functions, variables, and constants are automatically exposed to the template. There's no need to define exports. If we need something, we import it directly and use it. Also, we now have a few extra advantages, such as the following:</p>
			<ul>
				<li>We can have reactive and non-reactive variables displayed in our template</li>
				<li>We know that all the code is executed before the component is mounted</li>
				<li>The syntax is closer to vanilla JavaScript (a big plus!!!), so we can organize our code to our convenience and pleasure</li>
				<li>Smaller bundle size (did I mention this before? Yes, it is important!)</li>
			</ul>
			<p>But wait, you may notice that I’m defining a reactive variable as a <i>constant</i>! Yes, I am! And no, it is not an error. In JavaScript, a constant points to a particular immutable value, which, in this case, is an object, but this applies only to the object, not to its members. The <b>ref()</b> constructor returns an object, so the constant applies to the object reference and we <i>can</i> change the value of its members.
If you have worked with pointers in Java, C, or a similar language, you may recognize this concept as the use of <b>pointers</b>. But all this comes at a cost. In order to access and modify the value, now we need to access the <b>value</b> attribute from the object. Here is an example:</p>
			<pre class="source-code">_hello.value="Some other value";</pre>
			<p>But, at the same time, nothing has changed in the way to access this variable in the template:</p>
			<pre class="source-code">&lt;div&gt;{{_hello}}&lt;/div&gt;</pre>
			<p>So, in brief, every time a variable is declared as reactive using the <b>ref()</b> constructor, you need to reference its value with the <b>constant_name.value</b> format, and just as <b>constant_name</b> in the template (HTML). When the constant name is used in the template, Vue already knows how to access the value and you don’t need to reference it explicitly as in JavaScript.</p>
			<h6>Tip</h6>
			<p class="callout">Adopt a code convention so you’ll know when an identifier refers to a variable, constant, function, class, and so on.</p>
			<h2>Exploring built-in directives in Vue 3</h2>
			<p>Vue also provides special HTML attributes called <b>directives</b>. A directive is declared in the opening tag of an HTML element and will affect or provide dynamic behavior or functionality to that element. We can also create our own directives in Vue. Those provided by the framework have a special notation starting with <b>v-</b>. As for the purpose of this book, let’s explain the most commonly used Vue directives:</p>
			<h3>v-bind: (shorthand ":")</h3>
			<p>The <b>v-bind:</b> directive binds the value of an HTML attribute to the value of a JavaScript variable. If the variable is reactive, each time it updates its value, it will be reflected in the html. If the variable is not reactive, it will be used only once during the initial rendering of the HTML. Most often, we use only the <b>:</b> shorthand prefix (semi-colon). For example, the <b>my_profile_picture</b> reactive variable contains a web address to a picture:</p>
			<p><b>&lt;</b><b>img :src="my_profile_picture"&gt;</b></p>
			<p>The <b>src</b> attribute will receive the value of the <b>my_profile_picture</b></span><span class="No-Break"> variable.</p>
			<h3>v-show</h3>
			<p>This directive will show or hide the element, without removing it from the document. It is equivalent to modifying the CSS <b>display</b> attribute. It expects a variable that gives a Boolean value (or something that can be interpreted as true or non-empty). For example, the <b>loading</b> variable has a Boolean value:</p>
			<p><b>&lt;</b><b>div v-show="loading"&gt;…&lt;/div&gt;</b></p>
			<p>The <b>div</b> will appear when the <b>loading</b> variable is true.</p>
			<p>It is important to keep in mind that <b>v-show</b> will use the style of the object to display it or not, but the element will still be part of the <b>Document Object </b><b>Model</b></span><span class="No-Break"> (</span><span class="No-Break"><b>DOM</b></span><span class="No-Break">).</p>
			<h3>v-if, v-else, and v-else-if</h3>
			<p>These directives behave as you would expect with conditional sentences in JavaScript, showing and hiding the element based on the value resolved by the expression passed. They are similar to <b>v-show</b> in the sense that they will show or hide the element, but with the difference that they remove completely the element from the DOM. Because of this, it can be expensive computationally if used improperly at a large scale with elements that switch their state often, as the framework has to perform more operations to manipulate the DOM, as opposed to <b>v-show</b>, when only the display style needs to change.</p>
			<h6>Note</h6>
			<p class="callout">Use <b>v-if</b> to show or display elements that will not toggle once shown or hidden (and preferred when the initial state is hidden). Use <b>v-show</b> if an element will switch states often. This will improve the performance when displaying large lists of elements.</p>
			<h3>v-for and :key</h3>
			<p>These two attributes, when combined, behave like a <b>for</b> loop in JavaScript. They will create as many copies of the element as prescribed in the iterator, each one with the corresponding interpolated value. It is extremely useful to display collections of data items. The <b>:key</b> attribute is used internally to keep track of changes more efficiently, and must reference a unique attribute of the item being looped on – for example, the <b>id</b> field of an object, or the index in an array when the indexes won‘t change. Here is an example:</p>
			<p><b>&lt;span v-for="i in 5" :key="i"&gt; {{</b><b>i}} &lt;/span&gt;</b></p>
			<p>This will display five <b>span</b> elements on the web page with the interpolation of <b>i</b> showing the following:</p>
			<p><b>1 2 3 4 5</b></p>
			<h3>v-model</h3>
			<p>This directive is pure magic. When attached to an input element (input, textarea, select, etc.), it will assign the value returned by the HTML element to the referenced variable, thus keeping the DOM and JavaScript state in synchronization – something that is called <b>two-way binding</b>. Here is an example:</p>
			<p><b>&lt;input </b><b>type="text" v-model="name"&gt;</b></p>
			<p>When the user enters text in HTML, the <b>"name"</b> variable in JavaScript will immediately have that value assigned. In these examples, we are using primitive data types such as numbers and strings, but we can also use more complex values such as objects or arrays. More of this will come in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><i>Chapter 4</i></span></a>, <i> User Interface Composition with Components</i>, when we see components <span class="No-Break">in depth.</p>
			<h3>v-on: (and the shorthand @)</h3>
			<p>This directive behaves a bit differently than the ones seen before. It expects not a variable, but a function or an expression, and it ties an HTML event to a JavaScript function to execute it. The event needs to be declared immediately after the colon. For example, to react to a <b>click</b> event on a button,
we would write the following:</p>
			<pre class="source-code"><b>&lt;button v-on:click="printPage()"&gt;Print&lt;/button&gt;</b></pre>
			<p>When the button triggers the <b>click</b> event, the JavaScript <b>"printPage()"</b> function will be executed. Also, the shorthand for this directive is more commonly used, and we will use that from now on in this book: just replace the <b>v-on:</b> with <b>@</b>. Then, the previous example becomes the following:</p>
			<p><b>&lt;</b><b>button @click="printPage()"&gt;Print&lt;/button&gt;</b></p>
			<p>You can find the complete list of built-in directives in the official documentation here: <a href="https://vuejs.org/api/built-in-directives.html">https://vuejs.org/api/built-in-directives.html</a> . We will see others as we move forward.</p>
			<p>So far, we have seen that Vue 3 applications are built with components that we can use in our HTML and that we create using SFCs. The framework also provides us with directives to manipulate HTML elements, but that is not all. In the next section, we’ll see that the framework also provides some handy prebuilt components for us to use.</p>
			<h2>Built-in components</h2>
			<p>The framework also provides us with several built-in components that we can use without explicitly importing them into each SFC. I have provided here a small description of each one, so you can refer to the official documentation for the syntax and examples (see </span><a href="https://vuejs.org/api/built-in-components.html"><span class="No-Break">https://vuejs.org/api/built-in-components.html</span></a><span class="No-Break">):</p>
			<ul>
				<li><b>Transition</b> and <b>TransitionGroup</b> are two components that can work together to provide animations and transition to elements and components. They need you to create the CSS animations and transition classes to implement the animation when inserting or removing elements into the page. They are mainly (or often) used when you are displaying a list of elements with <b>v-for</b>/<b>:key</b> or <b>v-if</b></span><span class="No-Break">/</span><span class="No-Break"><b>v-show</b></span><span class="No-Break"> directives.</li>
				<li><b>KeepAlive</b> is another wrapper component (meaning that it surrounds other components) used to preserve the state (internal variables, elements, etc.) when the component wrapped inside is no longer on display. Usually, component instances are cleared out and “garbage collected” when they are unmounted. <b>KeepAlive</b> keeps them cached so their state is restored when they come back on display.</li>
				<li><b>Teleport</b> is a brand-new component in Vue 3, that allows you to transport the HTML of the component into another location anywhere on the page, even outside the component tree of your application. This helps in some cases where you need to display information outside your component but it has to be processed by your component’s internal logic.</li>
				<li><b>Suspense</b> is a new component in Vue 3, but is still in an experimental phase, so its future is uncertain at the time of this writing. The basic idea is to display “fallback” content until all the asynchronous child components/elements are ready to be rendered. It is provided as a convenience since there are patterns that you could use to solve this problem. We will see some later on.</li>
				<li><b>Component-is</b> is a special element that will load a component at runtime, as prescribed by the content of a variable – for example, if we need to display a component based on the value of a variable, and the use of other directives may be cumbersome. It can also be used to render HTML elements. Let’s see an example:<pre class="console">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import EditItem from "EditItem.vue"
&nbsp;&nbsp;&nbsp;&nbsp;import ViewItem from "ViewItem.vue"
&nbsp;&nbsp;&nbsp;&nbsp;import {ref} from "vue"
&nbsp;&nbsp;&nbsp;&nbsp;const action=ref("ViewItem")
&lt;/script&gt;
&lt;template&gt;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&lt;component :is="action"&gt;&lt;/component&gt;</b>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="action='EditItem'"&gt;Edit&lt;/button&gt;
&lt;/template&gt;</pre></li>
			</ul>
			<p>In this simple example, when the user clicks the <b>Edit</b> button, the action value will change to <b>EditItem</b>, and the component will be swapped in place. You can find the documentation here:</span><a href="https://vuejs.org/api/built-in-special-elements.html"><span class="No-Break"> https://vuejs.org/api/built-in-special-elements.html.</a></p>
			<p>With the idea of frameworks and components, we are now better prepared to move forward.</p>
			<h2>Book code conventions</h2>
			<p>In this book, we will use a set of code conventions and guidelines that are good practices for Vue 3. They will help you not only understand the examples of this book but also the code in the wild that you may come across, as more and more developers use it. Let’s start from the beginning.</p>
			<h3>Variables and props</h3>
			<p>These are always in lowercase and spaces are replaced with an underscore, for example, <b>total_count</b> and </span><span class="No-Break"><b>person_id</b></span><span class="No-Break">..</p>
			<h3>Constants</h3>
			<p>References to injected objects start with a <b>$</b> (dollar) sign, for example, <b>$router</b>,<b> $modals</b>, and </span><span class="No-Break"><b>$notifications</b></span><span class="No-Break">.</p>
			<p>References to reactive data start with <b>_</b> and are typed in snake case, for example, <b>_total</b> and </span><span class="No-Break"><b>_first_input</b></span><span class="No-Break">.</p>
			<p>References to constant values are all in capital letters, for example, <b>OPTION</b> and </span><span class="No-Break"><b>LANGUAGE_CODE.</b></p>
			<p>Constructor functions for injected dependencies will start with <b>use</b>, for example, <b>const $store=useStore().</b></p>
			<h3>Classes and component names</h3>
			<p>These are written in PascalCase (each word starts with an upper case letter), for example, <b>Person</b>, <b>Task</b>, and </span><span class="No-Break"><b>QueueBuilder</b></span><span class="No-Break">.</p>
			<h3>Functions, methods, events, and filenames</h3>
			<p>These are written in camel case, for example, <b>doSubscribe()</b> and</span><span class="No-Break"></span><span class="No-Break"> </span><span class="No-Break"><b>processQueue()</b></p>
			<h3>Instances</h3>
			<p>Instances will have the abstract name, followed by the word <b>Service</b> in the case of plain JavaScript objects that provide functions, <b>Model</b> for state models, and so forth. We will use services to encapsulate functionality.</p>
			<p>Here's an example: <b>const </b><b>projectService=new ProjectService().</b></p>
			<h6>Tip</h6>
			<p class="callout">With your team, always use a code convention that all agree upon. This will make the code more readable and maintainable. It can be also recommended to use a linter (a processor to capture conventions in your code).</p>
			<p>As mentioned, these code conventions are gaining popularity, so you may see them in multiple projects. However, these are not mandatory standards and most definitely are not prescribed by the framework. You can write all in capital letters if that is your style, but what really matters is that you and your team define and abide by your own conventions in a consistent manner. What matters in the end, is that we all have a common language when writing code.</p>
			<h2>Summary</h2>
			<p>This chapter has gone from the basics of libraries and frameworks to Vue 3 directives, components,   and even code conventions. These concepts are still a bit abstract, so we will bring them down to implementation as we move through the rest of the book and work with real code. However, we are on safe footing now to learn about design principles and patterns in the next chapter.</p>
			<h2>Review questions</h2>
			<p>To help you consolidate the contents of this chapter, you can use these review questions:</p>
			<ul>
				<li>What is the difference between a library and a framework?</li>
				<li>Why is Vue a “progressive” framework?</li>
				<li>What are single-file components?</li>
				<li>What are some of the most common directives used in Vue development?</li>
				<li>Why are code conventions important?</li>
			</ul>
			<p>If you can answer these questions quickly in your mind, you’re good to go! If not, you may want to review the chapter briefly to make sure you have the basis to move on.</p>
		</div>
	</div></div>