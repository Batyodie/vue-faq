			<h1>Multithreading with Web Workers</h1>
			<p>In this chapter, we will cover important topics that will highly improve the performance of a web application, especially single-page applications. First, we will learn how websites and JavaScript work, and how to use <b>web workers</b> to leverage our application processing power, data access, and network communications. Then, we will introduce two new conceptual design patterns and will implement them in an example application together with other patterns that we have previously seen. On top of this, we will also introduce two libraries that will facilitate our network communications as well as the handling of our persistent database(s) in IndexedDB. We will also implement a simple Node.js server to provide us with feedback and test our work in a highly decoupled architecture, where our frontend and backend services communicate using standard APIs over the HTTP protocol.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>WebWorkers</li>
				<li>Business and dispatcher patterns</li>
				<li>Network communication inside a </span><span class="No-Break"><b>WebWorker</b></li>
				<li>A browser’s persistent embedded database – IndexedDB</li>
				<li>How to build a simple Node.js API server for testing</li>
			</ul>
			<p>The concepts in this chapter can be considered “advanced,” but we will condense them down into understandable pieces that we will implement right away. By the end of this chapter, you will have a solid knowledge of how to implement multithreading in your web applications and also a reference framework to scale and facilitate the use of complex browser APIs.</p>
			<h2>Technical requirements</h2>
			<p>This chapter does not add additional requirements to our application. However, we will only see relevant parts of the code, so to see the entire application working, you should refer to the code examples for <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><i>Chapter 8</i></span></a>, <i>Multithreading with Web Workers</i>, in the book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08</span></a><span class="No-Break">.</p>
			<p>Check out the following video to see the Code in Action: </span><a href="https://packt.link/D4EHt"><span class="No-Break">https://packt.link/D4EHt</a></p>
			<h2>An introduction to web workers</h2>
			<p>JavaScript is a single-threaded language, meaning that it doesn’t natively have a way to spawn processes in separate threads. This makes web browsers run the JavaScript in a web page on the same thread as other processes, which directly affects the performance of the page, most notably, the rendering process,that is in charge of presenting the page on the screen. Bowsers make a considerable effort to optimize the performance of all these moving parts to make a page responsive, performant, fast, and efficient. However, there are tasks that a web application must do in JavaScript that are heavy and potentially “render-blocking”. This means that the browser will have to pay attention to the results of the code and use all the resources to complete the running function before it can focus on the rendering (presenting the page to the screen). If you ever find a process on a web page that makes the site seem “unresponsive” or “stuttering” after you start an action (your mouse may even freeze in some cases), this could be one of the causes.</p>
			<p>If we open the developer tools in a modern browser, we can access some performance tools to analyze how a web page behaves and how much time each process step takes. For example, here is a quick view of the first load of YouTube on a shared link, in Firefox for Linux:</p>
			<div>
				<div>
					<img src="images/Figure_8.01_B18602.jpg" alt="Figure 8.1 – The performance of YouTube’s first load, seen using developer tools" width="968" height="314">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The performance of YouTube’s first load, seen using developer tools</p>
			<p>The preceding screenshot has zoomed into the actual processing of the page, showing what happens before the first rendering, meaning before the user can actually see something on the screen. That is represented in the first line, <b>Screenshots</b>, where for this case, the first visible elements appear towards the end of the timeline (<i>#1</i>). The second line shows what the main <b>Parent Process</b><span lang="en-US" xml:lang="en-US"> </span>has been busy doing, and if you pay attention, the very first section (<i>#2</i>) is all about processing JavaScript. The <b>Renderer</b><b> </b>process, highlighted and displayed with a black bar (#3), can’t even start until the JavaScript has been run. When it does run, it draws the page on the screen, and you have the visible content from <i>#1</i>. This gives an approximate idea of the work the browser does each cycle in between screen paints (called “frames”). The browser attempts to produce as many <b>frames per second</b> (<b>fps</b>) as possible. To keep a fluent 60 fps, it needs to do all this processing in about 16.67 milliseconds or less. At best, your JavaScript process should be resolved in half that time to keep a fluid experience for the user. With this in mind, what happens when your JavaScript takes longer than that? Simple enough, the render process is postponed, the fps drop, and the user experiences stuttering and a frozen <b>user interface</b> (<b>UI</b>) may happen. Depending on your web application, this could be an important issue.</p>
			<p>You may say, “Wait a minute, why we don’t make heavy tasks asynchronous? Wouldn’t that resolve the issue?” The answer is: maybe and no. When you declare an asynchronous function, it only means that the execution will be deferred to a place in time when the processing of the sequential code has been executed. Most likely, this pushes the asynchronous code toward the end or after the sequential code has been executed, but then it will be run sequentially as usual. If the rendering process happens before that, you may perceive a performance gain, but if not, you face the same issue if the async function takes longer (as it will affect the next rendering). If we moved all functions to be asynchronous, we would end up potentially with the same result as if everything were sequential, plus the overhead of making the asynchronous calls:</p>
			<div>
				<div>
					<img src="images/Figure_8.02_B18602.jpg" alt="Figure 8.2 – A representation of the execution of async code, moved after the sequential code has been executed (1)" width="543" height="155">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – A representation of the execution of async code, moved after the sequential code has been executed (1)</p>
			<p>Then, if asynchronous operations would not completely solve the performance issue, how do we resolve it? Beyond all the optimizations you could make, there is one technology you should also consider at the top of the list of alternatives: the web workers API.</p>
			<p>Web workers are JavaScript scripts that execute in their own process (or thread, depending on the implementation); thus, they do not compromise the parent process where the rendering happens. The browser API provides a rather simple yet effective way to communicate to and from the parent process: a messaging system. These messages can only pass serializable data. The parent process and each web worker operate in their own environment and memory boundaries, so they cannot share references or functions, hence why all the data passed between them has to be serializable as it is copied into each process. While this may seem like a disadvantage, it is actually an asset when used properly, as we will see soon here. Another caveat of this architecture is that web workers do not have access to the <b>Document Object Model</b> (<b>DOM</b>) or the Window objects and, consequently, to any of their services. They do, however, have access to the network and IndexedDB. This opens up a wealth of opportunities for the architectural design of your frontend application, as you can easily separate what a presentation layer and a business layer is.</p>
			<div>
				<div>
					<img src="images/Figure_8.03_B18602.jpg" alt="Figure 8.3 – A layered representation of a Vue application with background processes using web workers" width="788" height="202">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – A layered representation of a Vue application with background processes using web workers</p>
			<p>As you can see in the previous diagram, we can instantiate multiple web workers to represent different types of layers in our application (<b>Business</b>, <b>Data</b>, <b>Communication</b>, and so on). While a web worker can be started and terminated from the parent process at will, both of these actions are computationally expensive, so the recommendation is that web workers, once created, remain active during the duration of the application and accessed when needed. It is also recommended not to abuse this resource by creating “too many” web workers, as each one is a different process with its own resources reserved. There is no clear definition of what constitutes “too many”, so discretion is advised. In my experience, while the number of web workers remains in the lower single digits, even low-powered devices should handle your application with excellent performance. As with many other things, there can be too much of a good thing, and this also applies with web workers.</p>
			<p>Now that we know what web workers are and what they can do for us, let’s see how to implement them in pure JavaScript and then how to do so with Vite.</p>
			<h3>Implementing a Web Worker</h3>
			<p>Creating a web worker in plain JavaScript is quite simple and straightforward. The <b>window</b><b> </b>object provides a constructor, properly named <b>Worker</b>, which receives as a parameter the path to a script file. For example, considering that our web worker is contained in a <b>my_worker.js</b> file, this is how we can create it:</p>
			<pre class="source-code">if(window.Worker){
&nbsp;&nbsp;&nbsp;&nbsp;<b>let my_worker=new Worker("my_worker.js")</b>
&nbsp;&nbsp;&nbsp;&nbsp;...
}</pre>
			<p>Simple enough, if the constructor exists in the <b>window</b> object, then we just create a new worker accessing the constructor directly. The newly created worker again exposes a simple API:</p>
			<ul>
				<li><b>.postMessage(message)</b>: This will send the message to the web worker. It can be any data type that can be serialized (basic data types, arrays, objects, and so on).</li>
				<li><b>.onmessage(callback(event))</b>: This event is triggered when the workers send a message to the parent process. The event received has a <b>.data</b> field that contains the message/data passed by the worker.</li>
				<li><b>.onerror(callback(event))</b>: When an error occurs in the worker, this event is triggered, and it will contain the following fields:</span><ul><li><b>.filename</b>: With the name of the script filename that generated <span class="No-Break">the error.</span></li><li><b>.lineno</b>: The line number where the <span class="No-Break">error occurred.</span></li><li><b>.message</b>: A string containing the description of <span class="No-Break">the error.</li></ul></li>
			</ul>
			<p>This messaging system allows us to carry on what otherwise could be a very complex form of
<b>inter-process communication</b> (<b>IPC</b>). Our previous code should look as follows due to implementing it:</p>
			<pre class="source-code">let my_worker=new Worker("my_worker.js")
my_worker<b>.onmessage=</b>event=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;// process message here
&nbsp;&nbsp;&nbsp;&nbsp;console.log(event.data)
}
my_worker<b>.onerror=</b>err=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;//process error here
}
my_worker<b>.postMessage</b>("Hello from parent process");</pre>
			<p>To complete this, we now need to implement the <b>my_worker.js</b> script. For this example, it can be something as simple as this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./my_worker.js</p>
			<pre class="source-code">self<b>.onmesssage=</b>event=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;console.log(event.data)
})
setTimeout(()=&gt;{
<b>&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage</b>("Hello from the worker")
},3000)</pre>
			<p>Our example worker is very simple. It prints the data received to the console, and 3 seconds after it has been activated, it sends a message to the parent process. Notice that we are using the <b>self</b> reserved word. This is needed when accessing the API from within a function, as it references the worker itself. This is why it is necessary inside the <b>setTimeout</b> callback. At the root level, it is optional, so you can write <b>self.onmessage</b> as in our example or directly </span><span class="No-Break"><b>onmessage</b></span><span class="No-Break">.</p>
			<p>Web Workers can instantiate other workers and also import other scripts through the <b>self.importScript()</b> method or just <b>importScript()</b>. This method receives a string with the script filename as a parameter. This is analogous to how we use the <b>import</b> statement in our services and components in our main application.</p>
			<p>When using Vite, as we are doing to bundle our Vue application, we have an alternative way to import and create a worker by using a suffix. For example, add the following in our <b>main.js</b></span><span class="No-Break"> script:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./main.js</p>
			<pre class="source-code"><b>import MyWorker from "my_worker.js?worker"</b>
const _myWorker=new <b>MyWorker()</b>
_myWorker.postMessage("Hi there!")
_myWorker.onmessage=(event)=&gt;{...}</pre>
			<p>When using the <b>worker</b> suffix notation, Vite wraps the implementation in a constructor, which we can use to instantiate our worker. This way makes handling workers more akin to using any other class in our application, as we can use the same approach to include it in our application, and this is the syntax we will use in our examples. Additionally, Vite will process the scripts from our worker, so we can use our more familiar syntax to import resources (<b>import ... from ...</b>) instead of the native </span><span class="No-Break"><b>self.importScript()</b></span><span class="No-Break">.</p>
			<p>There is more about web workers to learn. For our purposes, this is enough and what we will use. If you would like to know more, please refer to the documentation on the Mozilla Developer Network (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers</span></a><span class="No-Break">).</p>
			<p>With these building blocks, we can now implement a robust and easier-to-handle connection to our web workers by applying design patterns. Before we do that, we need to learn two more patterns conceptually: the business delegate and the dispatcher patterns.</p>
			<h2>The business delegate pattern</h2>
			<p>This pattern is used to hide the complexity of accessing business services or a business layer from the client or presentation layer by providing a single point of access with a well-defined and simple(r) interface. It can be reasoned to some degree as a variant or evolution of the proxies and decorator patterns that we saw in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a><i>, Software Design Principles and Patterns</i>, but applied at a larger logical scale between architectural layers. It usually involves at least the <span class="No-Break">following entities:</p>
			<ul>
				<li>A <b>business delegate</b> entity, which acts as the single point of entry for the client to all the available services</li>
				<li>A <b>business lookup or router</b> entity whose function is to route the execution of the incoming request to the appropriate service</li>
				<li>The <b>business services</b> that expose a common interface (directly or via a proxy pattern) with the provided function</li>
			</ul>
			<p>The pattern can be represented for our purposes in the following diagram:</p>
			<div>
				<div>
					<img src="images/Figure_8.04_B18602.jpg" alt="Figure 8.4 – A representation of the business delegate pattern" width="605" height="310">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – A representation of the business delegate pattern</p>
			<p>This pattern can be applied to multiple architectural levels. In our particular case, we want to apply this design to our application with web workers. We will consider the parent process as our presentation layer and our web worker as our business layer. In the parent (or main process), we will have our Vue application, as usual, focusing primarily on providing an excellent user experience. The worker will then be responsible for providing us with access to services, either local, as in the case of the IndexedDB, or remote, encapsulating the communication with our server and additional services and any additional computationally intensive function. This separation of concerns has many advantages, not only from the performance point of view but also from the design and implementation of the application as a whole.</p>
			<p>Before we implement the code for this chapter, we need to see one more pattern that we will implement since we can only pass serializable data between processes and cannot execute function calls as a plain Business Delegate pattern proposes. We will expand on the idea of the command pattern and use what is called a dispatcher pattern.</p>
			<h2>The dispatcher pattern</h2>
			<p>We have seen previously that either our parent process or the web worker process can initiate communication by posting (sending) a message to each other. As long as the proper listener (<b>onmessage</b>) has been defined, either one can receive and react to these events. In the Dispatcher pattern, these messages contain information related to the event, such as data. The key factor that separates this design pattern is that <i>the event messages must be published between threads and scheduled for execution upon arrival</i>. Of course, this scheduling can also include the “immediate execution” of some task or function.</p>
			<p>The implementation of this pattern is rather trivial, and you may think of it as akin to the Command Pattern that we saw in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><i>Chapter 2</i></span></a>, <i>Software Design Principles and Patterns</i>, so we will not see this again. Instead, we will take these concepts of communication between threads, scheduling, and events with data to create our solution to work with <span class="No-Break">web workers.</p>
			<h2>Establishing a communication pipeline with the web worker</h2>
			<p>We have now seen the key concepts that we want to apply to our implementation of the communication with web workers for our Vue application. This model can be used repeatedly from application to application and improved upon as needed. As a general plan of action, this is what we will build using the design patterns seen thus far:</p>
			<ul>
				<li>We will create a web worker with a single point of access in our Vue application, following the Business Delegate pattern</li>
				<li>Each message will raise an event to either process (parent-worker or worker-parent) and include command and payload data, as well as tracking information for scheduling as in the Dispatcher Pattern</li>
			</ul>
			<p>Simple enough, the architecture described in the preceding points allows us to establish a workflow as shown here:</p>
			<div>
				<div>
					<img src="images/Figure_8.05_B18602.jpg" alt="Figure 8.5 – Implementation of the communication workflow with the web worker" width="700" height="376">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Implementation of the communication workflow with the web worker</p>
			<p>Now that we have the theoretical basis and a broad understanding of what we will create, it is time to move into the code. We will focus on the most relevant parts of the code that implement the model mentioned previously. To see the entire application code, please review the full source code from the GitHub repository. Let’s start by creating a service that will be our entry point in the client application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./services/WebWorker.js</p>
			<pre class="source-code">import <b>WebWorker </b>from "../webworker/index.js<b>?worker</b>"
const _worker = <b>new WebWorker()</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
const service = {
&nbsp;&nbsp;&nbsp;&nbsp;<b>queue:{},</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>request</b>(command, payload = {}) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let message = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: crypto.randomUUID(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;service.queue[<b>message.id</b>]={resolve, reject}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>&nbsp;_worker.postMessage(message);</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//6</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;<b>processMessage</b>(data) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let id=data.id
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(data.success){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;service.queue[id]<b>.resolve(data.payload)&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//7</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;service.queue[id]<b>.reject(data.payload)</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete service.queue[id];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//8</b>
&nbsp;&nbsp;&nbsp;&nbsp;}
}
_worker.<b>onmessage </b>= (event) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;service.processMessage(<b>event.data</b>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//9</b>
}
export default service;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//10</b></pre>
			<p>This implementation is simple yet effective. It serves us well to understand how these patterns work. We start by importing the web worker constructor using Vite’s special suffix <b>worker</b> and then creating the instance reference in line <i>//1</i>. As usual, this service will be a singleton, so we create it as a JavaScript object, which we will export later in line <i>//10</i>. The service has only three members:</p>
			<ul>
				<li><b>queue</b>: This is defined on line <i>//2</i> and is a dictionary that we will use to store our scheduled calls to the web worker using a unique identification. Each entry will save the reference to the resolution methods of a promise (<b>resolve</b> and </span><span class="No-Break"><b>reject</b></span><span class="No-Break">).</li>
				<li>The <b>request()</b> method: Defined on line //3 here, this will be used by other services and components (the “clients”) to request tasks from the web worker. It always returns a promise (line //4). The message passed to the web worker encapsulates the <b>command</b> and <b>payload</b> received as parameters with a unique identification. We save the reference to the <b>resolve()</b> and <b>reject()</b> methods in the <b>queue</b> (line //5), and finally, using the native messaging method of the web worker, we post the message on line //6.</li>
				<li>The <b>processMessage()</b> method: This receives the data submitted by the web worker, and based on the identification and the result of the operation passed in the <b>.success</b> attribute (Boolean), we access <b>queue</b> and either use the <b>resolve()</b> or the <b>reject()</b> function to resolve or reject the promise (line //7). Finally, we remove the reference from the <b>queue</b> in line //8.</li>
			</ul>
			<p>The last step in this file is to link the incoming messages passing the data directly from the worker to <b>service.processMessage()</b> in line //9. It may be clear by now that we have made some decisions regarding the structure of the message and also the reply. Messages have three components: <b>id</b>, <b>command</b>, and <b>payload</b>. Replies also have three elements: <b>id</b>, <b>success</b>, and <b>payload</b>. On the client side, we have chosen to operate with promises, as they do not “time out”.</p>
			<p>With the client side resolved, now it’s time to work on the web worker script. Create the following <b>index.js</b> file in the <b>webworker</b></span><span class="No-Break"> directory:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./webworker/index.js</p>
			<pre class="source-code">import <b>testService </b>from "./services/test"
const <b>services</b>=[<b>testService</b>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
function <b>sendRequest</b>(id, success=false, payload={}){
&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage({id, success, payload})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
}
<b>self.onmessage</b>=(event)=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&nbsp;&nbsp;&nbsp;&nbsp;const data=event.data;
&nbsp;&nbsp;&nbsp;&nbsp;services.forEach(service=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(service[data.command]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>service[data.command](data.payload)</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//6</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendRequest(data.id, true, result)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//7</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, err=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendRequest(data.id, false, err)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;})
}</pre>
			<p>The web worker is even shorter, and we have also made some decisions regarding the interface implemented by each underlying service: each of their methods has to return a Promise as well. Let’s see the code and find out why.</p>
			<p>We start on line //1<i> </i>by importing <b>testService</b> (we will create it later) and include it in an array of services. This will make it easier to add new services by importing them and just including them in this array (this could be a stepping stone to a plugin architecture but we’ll stay simple for now). We then define a <b>sendRequest()</b> global function, which will send a message to the parent process with a coded message with three fields: <b>id</b>, <b>success</b>, and <b>payload</b>, as expected by the client in our defined . This is what happens in line</span><span class="No-Break"><i> </i></span><span class="No-Break">//2.</p>
			<p>In line //3, we define the <b>onmessage</b> event handler to process the incoming messages. When one is received, we traverse our <b>services</b> array to find a matching command (line //4), and when we do (line //5), we execute the function by passing the payload as a parameter (line //6) after we parse it through the JSON utility. Then, with the resolution or rejection of the promise, we transmit the proper result to the client in line <i>//7</i>. This short piece of code acts as the <i>business delegator and dispatcher</i>. Finally, let’s take a look at <b>testService</b> to see how it works:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./webworker/services/test.js</p>
			<pre class="source-code">const service={
&nbsp;&nbsp;&nbsp;test(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve("Worker alive and working!")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 3000)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
&nbsp;&nbsp;&nbsp;}
}
export default service;</pre>
			<p>As you can appreciate, this test service doesn’t do much other than just return a Promise and set a timer to resolve it after 3 seconds. This delay is artificial since, otherwise, the reply would be immediate.
If you run the example application, when you click the <b>Send request</b> button, you will see the message changing from <b>Waiting...</b> to <b>Worker alive and working!</b> after 3 seconds, just as expected:</p>
			<div>
				<div>
					<img src="images/Figure_8.06_B18602.jpg" alt="Figure 8.6 – The test application dispatches a command to the worker and shows the result" width="803" height="168">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – The test application dispatches a command to the worker and shows the result</p>
			<p>To make this happen, in our <b>App.vue</b> component, we import our web worker service and send our request with the command string as the name of the function in the service we want to execute.
For this example, add the following code:</p>
			<pre class="source-code">import <b>webWorker </b>from "./services/WebWorker.js"
<b>webWorker.request("test")</b>.then(data=&gt;{...}, err=&gt;{...})</pre>
			<p>These simple lines of code to create and manage a web worker provide your application with a considerable increase in computational power and performance. Now that our bases are set, it is time to do something more significant with our service worker. Let’s make it access our local database and the network.</p>
			<h2>Accessing IndexedDB with DexieJS in the web worker</h2>
			<p>IndexedDB is a very powerful key-value database; however, the native implementation provides an API that is rather hard to handle. The actual recommendation is not to use it but, instead, work with it through a framework or library. The database engine is fast and very malleable, so multiple libraries have built upon its foundation and recreated functions and features not present originally. Some libraries even mimic SQL and document-based databases. Some available and free-to-use libraries are the following:</p>
			<ul>
				<li><b>DexieJS</b> (<a href="https://dexie.org/">https://dexie.org/</a>): A very fast and well-documented library that implements a NoSQL document-based database.</li>
				<li><b>PouchDB</b> (<a href="https://pouchdb.com/">https://pouchdb.com/</a>): A database that mimics the functionality of Apache’s CouchDB and provides built-in synchronization with remote servers.</li>
				<li><b>RxDB</b> (<a href="https://rxdb.info/">https://rxdb.info/</a>): This is a database that implements the reactive model.
It also supports replication to CouchDB.</li>
				<li><b>IDB</b> (<a href="https://www.npmjs.com/package/idb">https://www.npmjs.com/package/idb</a>): This is a light wrapper implementation on top of the IndexedDB API, with some changes to improve its usability.</li>
			</ul>
			<p>Depending on your requirements for local storage, these or other options will suit you well. We will use DexieJS for this example as it is well documented and boasts impressive speeds for bulk operations. We will expand our previous example and create a single-component mini-application to store, retrieve, delete, and view notes. This covers very basic <b>create, read, update, and delete</b> (<b>CRUD</b>) operations. When you run the example code, it will look something like this:</p>
			<div>
				<div>
					<img src="images/Figure_8.07_B18602.jpg" alt="Figure 8.7 – A single-component CRUD example" width="526" height="105">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – A single-component CRUD example</p>
			<p>In this example, you can create new notes, view what was saved before (this will be persistent based on the domain), select them to view the text, and also delete them. All the operations will be resolved in the web worker. Let’s include Dexie in our application using </span><span class="No-Break"><b>npm</b></span><span class="No-Break">:</p>
			<pre class="console">$ npm install dexie</pre>
			<p>Next, let’s create our example component application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/components/DbNotes.vue</p>
			<pre class="source-code">&lt;script setup&gt;
import <b>webWorker</b> from "../services/WebWorker"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
import { ref } from "vue"
const _notes=ref([]),_note=ref({}),_selected=ref({})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
loadNotes()
function <b>saveNote</b>(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&nbsp;&nbsp;&nbsp;if(_note.value.title &amp;&amp; _note.value.text){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webWorker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.request("addNote", <b>JSON.stringify(_note.value)</b>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(id=&gt;{loadNotes()},err=&gt;{...})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.finally(()=&gt;{_note.value={}})
&nbsp;&nbsp;&nbsp;}
}
function <b>deleteNote</b>(id){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
&nbsp;&nbsp;&nbsp;WebWorker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.request("deleteNote", {id})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.finally(()=&gt;{loadNotes()})
}
function <b>openNote</b>(note){_selected.value=note;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
function <b>loadNotes</b>(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//6</b>
&nbsp;&nbsp;&nbsp;webWorker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.request("getNotes",[])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(data=&gt;{_notes.value=data;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()=&gt;{_notes.value=]})
}
&lt;/script&gt;
&lt;template&gt;
&lt;div&gt;
&nbsp;&nbsp;&nbsp;&lt;section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt;New note&lt;/h3&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="text"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-model="_note.title"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder="Title"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea v-model="_note.text"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder="Note text..."&gt;&lt;/textarea&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button <b>@click="saveNote()"</b>&gt;Save&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;/section&gt;
&nbsp;&nbsp;&nbsp;&lt;section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt;Notes&lt;/h3&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-for="n in _notes" :key="n.id"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a <b>@click="openNote(n)"</b>&gt;{{ n.title }}&lt;/a&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a <b>@click="deleteNote(n.id)"</b>&gt;[X]&lt;/a&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&lt;/section&gt;
&nbsp;&nbsp;&nbsp;&lt;section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt;Selected note&lt;/h3&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;{{ _selected.title }}&lt;/strong&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;{{ _selected.text }}&lt;/p&gt;
&nbsp;&nbsp;&nbsp;&lt;/section&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>The preceding file has been stripped of styles and other layout elements, so we can focus on the active parts of the code that implement the operations we are learning about. We start by importing our service class to handle the web worker in line <i>//1</i> and create a few internal reactive variables in line <i>//2</i>. We will use <b>_notes</b> to hold the full list of notes as extracted from the database, <b>_note</b> as a placeholder to create new notes, and <b>_selected</b> to display a note clicked on from the list. You can find the CRUD operations in each function (lines <i>//3</i> to <i>//6)</i> and will notice that they are very similar other than handling UI reactive elements. They just gather the necessary information to create a request to the web worker and then apply the result. However, notice how in the <b>saveNote()</b> function, when it is time to pass the object that describes our new note, we are stringifying the Vue reactive value. This is because the proxy implementation that Vue uses to handle reactivity is not serializable, so unless we create a copy of the plain object or apply other similar techniques to extract the values, the web worker communication will fail and throw an error. An easy way to make sure the data object is provided as a clonable object is to convert it into a string with <b>JSON.stringify(_note.value)</b> as in our code (you could also create directly a clone, with <b>JSON.parse(JSON.stringify(_note.value))</b>. You need to keep in mind how the information will be sent so that it can be properly processed at the receiving end of the web worker. This will become apparent now when we see <b>dbService.js</b> in the worker:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./src/webworker/services/dbService.js</p>
			<pre class="source-code">import Dexie from "dexie"
const db=new Dexie("Notes")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
db.version(1).stores({notes: <b>"++id,</b>title"});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
const service={
<b>addNote</b>(note={}){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&nbsp;&nbsp;return new Promise(async (resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result_id=await <b>db.notes.add(JSON.parse(note))</b>&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve({id:result_id})
&nbsp;&nbsp;&nbsp;&nbsp;}catch(err){reject({})}
})},
<b>getNotes</b>(){
&nbsp;&nbsp;return new Promise(async (resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result=await db.notes<b>.toArray()</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result)
&nbsp;&nbsp;&nbsp;&nbsp;}catch{reject([])}
})},
<b>deleteNote</b>({id}){
&nbsp;&nbsp;return new Promise(async (resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await db.notes.delete(id)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//6</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve({})
&nbsp;&nbsp;&nbsp;&nbsp;}catch{reject({})}
})}}
export default service;</pre>
			<p>To use Dexie, we first import the constructor as in line <i>//1</i>, and we create a new database with the name <b>Notes</b>. Before we can actually use it, we need to define the version and a simple schema of tables/collections with the fields that will be indexed. This is what happens in line <i>//2</i>, where we define the <b>notes</b> collection with two indexed fields: <b>id</b> and <b>title</b>. These indexed fields are passed as a string, comma-separated by field names. We also included a double plus sign as a prefix for the <b>id</b> field. This makes the field auto-generated by the database and auto-incremented with each new record.</p>
			<p>The next significant function, <b>addNote()</b>, adds the record to the <b>notes</b> collection. Since we are passing data serializing an object as a string in our component, in line <i>//4</i>, we need to parse the string to recompose the object.</p>
			<p>In the <b>getNotes()</b> function, we just retrieve all the elements from the collection and use the <b>toArray()</b> method provided by Dexie, which will convert it into a JavaScript array (line <i>//5</i>). This way, we can return it directly as our result to resolve the promise.</p>
			<p>A final note on this code is on the <b>deleteNote()</b> method: on line <i>//6</i>, we are not capturing the result of the asynchronous operation. This is because this operation does not return a usable value. In this case, this operation will always resolve unless a database engine error interrupts the execution.</p>
			<p>It is important to keep in mind that errors on the web worker will not affect the parent process, and any operations in that process will be unaffected.</p>
			<p>Now that we have our service in place, it is time to slightly modify the web worker index file. Add the following lines:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./src/webworker/index.js</p>
			<pre class="source-code">import <b>dbService </b>from "./services/dbService";
const services=[<b>dbService,</b> testService];</pre>
			<p>No other change is necessary for this file. As we can see, it does not take much to implement CRUD operations on the web worker. Even though these can be done in the parent process, and there is a small penalty from the interprocess communication, the benefits in performance are considerable and well worth the effort. Especially if our application includes what should be background processes, such as synchronization with a remote server, these should be done by a web worker. Let’s see next how we can access the network and consume a <b>Representational State Transfer API </b>(<b>RESTful API</b>) from a worker as well.</p>
			<h2>Consuming a RESTful API with the web worker</h2>
			<p>One of the most common applications of network APIs today in web development is through the implementation of a RESTful API. It is a protocol where each communication is stateless and representative of the type of action required at the destination. The HTTP protocol used on the web provides a perfect match for this type of API, as each network call exposes a method that identifies the type of operation required:</p>
			<ul>
				<li>The <b>GET</b> operations retrieve data and files</li>
				<li>The <b>PUT</b> operations update data</li>
				<li>The <b>POST</b> operations create new data on the server</li>
				<li>The <b>DELETE</b> operations erase data on the server</li>
			</ul>
			<p>It is easy to see how these methods match CRUD operations, so by making the appropriate network call, the server knows how to process the data received at the proper endpoint. There are many standards used to format the data sent between endpoints. In particular, one of the most common ones is the JSON format, which we so conveniently use in JavaScript.</p>
			<p>Handling asynchronous calls with the native implementation in the browser is, at the very least, cumbersome but not impossible. The recommendation, for practicality and security, is to use a well-known library such as <b>Axios</b>. To install the library, we need to run the following command from the terminal:</p>
			<pre class="console">$ npm install axios</pre>
			<p>After a few moments, the library will be installed into our project as a dependency. The library provides very handy methods to launch network calls for each HTTP method. For example, <b>axios.get</b> makes a <b>GET</b> request, <b>axios.post</b> makes a <b>POST</b> request, and so forth.</p>
			<p>We will implement a simple service for our learning exercise to make network calls to a remote server from within our web worker. For simplicity, we will only create two methods:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./webworker/services/network.js</p>
			<pre class="source-code">import axios from "axios"
<b>axios.defaults.baseURL="http://localhost:3000"</b>
const service={
&nbsp;&nbsp;&nbsp;<b>GET</b>(payload={}){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axios
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<b>get</b>(<b>payload.url,{params:{data:payload.data}}</b>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(result.status&gt;=200 &amp;&amp; result.status&lt;300){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result.data)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{reject()}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).catch(()=&gt;{reject()})
&nbsp;&nbsp;})},
&nbsp;&nbsp;<b>POST</b>(payload={}){
&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axios
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<b>post</b>(<b>payload.url,{data:payload.data}</b>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(result.status&gt;=200 &amp;&amp; result.status&lt;300){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result.data)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{reject()}})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(()=&gt;{reject()})
})}}
export default service;</pre>
			<p>This service is rather simple. In a production application, it would be middleware to serve other services. This example implements only two methods to match the corresponding HTTP request methods. Notice that they are extremely similar, only changing the name of the method and the signature for some of the parameters. The first parameter is always the endpoint (URI) to connect. The second parameter is either data or an object with options. I refer you to the official documentation for how to handle each specific request and handle edge cases (</span><a href="https://axios-http.com/docs/intro"><span class="No-Break">https://axios-http.com/docs/intro</span></a><span class="No-Break">).</p>
			<p>It is worth noting that at the beginning of the file, we set the default domain for all other network calls. This way, we avoid repeating it in each call. We can easily set specific HTTP headers and options with this library, such as <b>JSON Web Tokens</b>, for authentication, as we covered in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>Chapter 5</i></span></a>, <i>Single-Page Applications</i>, when we mentioned different <span class="No-Break">authentication methods.</p>
			<p>To include this service in our web worker, we import it and add it to our <b>services</b> array as we did before. Modify the beginning of this file so it looks like this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./webworker/index.js</p>
			<pre class="source-code">import netService from "./services/network"
const services=[dbService, netService, testService]</pre>
			<p>With this new inclusion, our web worker is now ready. We now implement a single component to test the communication, and it will look like this:</p>
			<div>
				<div>
					<img src="images/Figure_8.08_B18602.jpg" alt="Figure 8.8 – A simple test, where the server mirrors back the information sent" width="601" height="100">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – A simple test, where the server mirrors back the information sent</p>
			<p>Our component will let us select the method for the HTTP request (<b>GET</b> or <b>POST</b>) and will send some arbitrary data. The test server will just mirror the data received back to the client, where the component will present it on the screen. The implementation is quite straightforward:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./src/components/NetworkCommunication.vue</p>
			<pre class="source-code">&lt;script setup&gt;
import webWorker from "../services/WebWorker"
import { ref } from "vue"
const
&nbsp;&nbsp;&nbsp;&nbsp;_data_to_send = ref(""),
&nbsp;&nbsp;&nbsp;&nbsp;_data_received = ref(""),
&nbsp;&nbsp;&nbsp;&nbsp;_method = ref("GET")
function sendData(){
&nbsp;&nbsp;&nbsp;&nbsp;webWorker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.request(<b>_method.value</b>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{url:"/api/test", data: _data_to_send.value}</b>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(reply=&gt;{<b>_data_received.value=reply</b>},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()=&gt;{_data_received.value="Error"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
}
&lt;/script&gt;
&lt;template&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;Text to send&lt;/h4&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type="radio"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value="GET"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="method"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-model="_method"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&gt;GET Method&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type="radio"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value="POST"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="method"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-model="_method"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&gt;POST Method&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="text" v-model="_data_to_send"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="<b>sendData()</b>"&gt;Send&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;Data received from server&lt;/h4&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ _data_received }}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/section&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>In this component, we import the <b>webWorker</b> service and declare three reactive variables to send and receive data and one to hold the selected method to make the request. Our simple test server will receive the request and will just mirror back the data that we submit. We will see later how to create this simple server using Node.js.</p>
			<p>In the template, the user can choose the type of request to send (<b>GET</b> or <b>POST</b>), a choice that we save in the <b>_method</b> variable. We use this value as the command passed to the worker in line <i>//1</i>. We pass the data as a member object as a payload. When this promise resolves, we save the value from the reply in the <b>_data_received</b> variable. The rest of the source code should be trivial to understand at this point, as it deals mainly with the template and presentation of the information on the screen. Before we end this chapter, let’s take a look a how the test server can be implemented using Node.js.</p>
			<h2>A simple NodeJS server for testing</h2>
			<p>To test our network communications, it seems fitting that we implement a small server using Node.js to implement the endpoints that we are testing. In a separate directory from our Vue application, open a terminal window and enter the following command:</p>
			<pre class="console">$ npm init</pre>
			<p>The command-line wizard will ask you a few questions to create the <b>package.json</b> file that represents a Node.js application. When it is done, run this command to install the <b>Express.js</b> dependency, which will give us a framework to create a web server:</p>
			<pre class="source-code">$ npm install express cors</pre>
			<p>Once the process completes, create an <b>index.js</b> file with the following code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./server/index.js</p>
			<pre class="source-code">const <b>express </b>= require("express")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
const cors=require("cors")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
const <b>app=express()</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
const PORT=3000
<b>app.use(cors())</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
<b>app.use(express.json())</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
<b>app.get("/api/test",</b> (req, res)=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//6</b>
&nbsp;&nbsp;&nbsp;&nbsp;const data=req.query&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//7</b>
&nbsp;&nbsp;&nbsp;&nbsp;res.jsonp(data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//8</b>
})
<b>app.post("/api/test",</b> (req, res)=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;const data=req.body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//9</b>
&nbsp;&nbsp;&nbsp;&nbsp;res.jsonp(data)
})
<b>app.listen(PORT,</b> ()=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//10</b>
&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server listening on port " + PORT)
})</pre>
			<p>With these few lines of code, we can start a small server that receives and responds with JSON data. We import the express constructor (line <i>//1</i>), and a plugin (line <i>//2</i>). This is important so that we can access this server from any domain (origin). The <b>Cross-Origin Request Sharing</b> (<b>CORS</b>)serves to circumvent the security measure that servers implement to prevent serving requests from other sources (origins) than their own. It has to be enabled to allow requests from other origins. After we create our server application (line <i>//3</i>), we pass the plugin (line <i>//4</i>). We also pass another plugin (line <i>//5</i>), to make the server identify and reply to network calls with JSON objects. We then proceed to create two endpoints, one for the <b>GET</b> requests (line <i>//6</i>) and another one for a <b>POST</b> request. The first parameter is the URL where the server will be listening for calls. In this case, they are the same, as the only difference will be the type of request method. This is standard practice.</p>
			<p>Each endpoint receives as the last argument a callback function with at least two parameters: <b>req</b> (request) and <b>res</b> (response). These objects contain methods and information about the request received and the necessary methods to create a response to the client.</p>
			<p>For the <b>GET</b> requests, the data received is passed attached to the URL as a “query string”, so in order to access it,<i> Express </i>wraps it nicely as an object in the <b>request.query</b> field (line <i>//7</i>). Since we are just replying with the same data received, in line <i>//8</i>, we use the <b>res</b>(ponse) object to create a padded JSON reply with the same data object. We do this because we consider that we could receive calls from any domain (because we enabled CORS) and want to ensure the reply is fully understood. <b>JSON with Padding</b> (<b>JSONP</b>) is a method to send the response using a different method. We don’t need to worry about this, as both ends (sender and receiver) are handled by the Express server and the Axios client.</p>
			<p>In the <b>post </b>method, the difference is that the data is contained in the body of the message (line <i>//9</i>), hence the different treatment. Finally, the server starts listening on the designated port (line <i>//10</i>). We can now access the server at <a href="http://localhost:3000/">http://localhost:3000</a>, which is the address that we configured in our network service as the default for Axios.</p>
			<p>With the implementation of this server, we can now have a full test of all the parts of the system.</p>
			<h2>Summary</h2>
			<p>In this chapter, we reviewed some very important concepts to fundamentally improve the architecture and performance of our application. Web workers is an amazing technology that allows web applications to take advantage of modern hardware architectures and modern operating systems. From a fixed point of view, multithreading using web workers involves little additional effort and complications, and the gains are highly rewarding. We also saw how to make use of workers to access network services as well as the local persistent database provided by the browser (IndexedDB). We learned about two more design patterns to implement a scalable architecture for our application and tested the concepts and implementations through simple components and services. The use of web workers marks a significant difference in the performance and execution of a well-designed web application. In the next chapter, we will look into tools and techniques to test our code automatically, ensuring the individual parts comply with their intended purpose to match our software specifications and requirements.</p>
			<h2>Review questions</h2>
			<ul>
				<li>What limitations does JavaScript have that can compromise the performance of a web application?</li>
				<li>What are web workers? What are their limitations?</li>
				<li>How can Vue applications communicate with web workers?</li>
				<li>What are the benefits of using a design pattern such as the Business Delegate to work with web workers?</li>
				<li>What can you change in the example code to manage multiple web workers instead of just one? When would this be advisable, in your opinion?</li>
			</ul>
		</div>
	</div></div>